package rpc

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"sync"

	"github.com/colorfulnotion/jam/common"
	"github.com/colorfulnotion/jam/log"
	"github.com/colorfulnotion/jam/statedb"
	"github.com/colorfulnotion/jam/types"
)

// Lazy initialization for bootstrap auth code hash (mirrors EVM builder pattern)
var (
	bootstrap_auth_codehash common.Hash
	bootstrapAuthOnce       sync.Once
)

// getBootstrapAuthCodeHash computes the bootstrap auth code hash lazily
func getBootstrapAuthCodeHash() common.Hash {
	bootstrapAuthOnce.Do(func() {
		// Only compute when actually needed
		authFilePath, err := common.GetFilePath(statedb.BootStrapNullAuthFile)
		if err != nil {
			log.Warn(log.SDB, "Failed to get bootstrap auth file path, using zero hash", "err", err)
			bootstrap_auth_codehash = common.Hash{}
			return
		}
		auth_code_bytes, err := os.ReadFile(authFilePath)
		if err != nil {
			log.Warn(log.SDB, "Failed to read bootstrap null auth file, using zero hash", "err", err)
			bootstrap_auth_codehash = common.Hash{}
			return
		}
		auth_code := statedb.AuthorizeCode{
			PackageMetaData:   []byte("bootstrap"),
			AuthorizationCode: auth_code_bytes,
		}
		auth_code_encoded_bytes, err := auth_code.Encode()
		if err != nil {
			log.Warn(log.SDB, "Failed to encode bootstrap auth code, using zero hash", "err", err)
			bootstrap_auth_codehash = common.Hash{}
			return
		}
		bootstrap_auth_codehash = common.Blake2Hash(auth_code_encoded_bytes)
	})
	return bootstrap_auth_codehash
}

// WorkPackageFile represents the JSON structure of work package files
// generated by the Rust orchard-builder sequence command
type WorkPackageFile struct {
	PreStateRoots      OrchardStateRoots  `json:"pre_state_roots"`
	PostStateRoots     OrchardStateRoots  `json:"post_state_roots"`
	PreStateWitnesses  StateWitnesses     `json:"pre_state_witnesses"`
	PostStateWitnesses StateWitnesses     `json:"post_state_witnesses"`
	UserBundles        []UserBundle       `json:"user_bundles"`
	Metadata           WorkPackageMeta    `json:"metadata"`
}

// StateWitnesses contains Merkle proofs for commitment and nullifier trees
type StateWitnesses struct {
	NullifierAbsenceProofs     []NullifierAbsenceProof `json:"nullifier_absence_proofs"`
	SpentNoteCommitmentProofs  []interface{}           `json:"spent_note_commitment_proofs"`
}

// NullifierAbsenceProof proves a nullifier doesn't exist in the tree
type NullifierAbsenceProof struct {
	Leaf     [32]byte   `json:"leaf"`
	Siblings [][32]byte `json:"siblings"` // Merkle path
	Root     [32]byte   `json:"root"`
	Position uint64     `json:"position"`
}

// OrchardStateRoots captures commitment and nullifier tree state
type OrchardStateRoots struct {
	CommitmentRoot [32]byte `json:"commitment_root"`
	CommitmentSize uint64   `json:"commitment_size"`
	NullifierRoot  [32]byte `json:"nullifier_root"`
	NullifierSize  uint64   `json:"nullifier_size"`
}

// UserBundle contains Orchard actions and bundle bytes
type UserBundle struct {
	Actions     []OrchardAction `json:"actions"`
	BundleBytes []byte          `json:"bundle_bytes"`
}

// OrchardAction represents a single shielded action
type OrchardAction struct {
	Commitment              [32]byte `json:"commitment"`
	Nullifier               [32]byte `json:"nullifier"`
	NullifierAbsenceIndex   uint64   `json:"nullifier_absence_index"`
	SpentCommitmentIndex    uint64   `json:"spent_commitment_index"`
}

// WorkPackageMeta contains metadata like gas limits
type WorkPackageMeta struct {
	GasLimit uint64 `json:"gas_limit"`
}

// LoadWorkPackageFromFile reads and parses a work package JSON file
func LoadWorkPackageFromFile(path string) (*WorkPackageFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read work package file: %w", err)
	}

	var wpFile WorkPackageFile
	if err := json.Unmarshal(data, &wpFile); err != nil {
		return nil, fmt.Errorf("failed to parse work package JSON: %w", err)
	}

	return &wpFile, nil
}

// serializeOrchardExtrinsic wraps a bundle in the Orchard extrinsic format:
// [tag:u8][bundle_len:u32][bundle_bytes][num_proofs:u32][proofs...]
func serializeOrchardExtrinsic(bundleBytes []byte, nullifierProofs []NullifierAbsenceProof) []byte {
	const TAG_BUNDLE_SUBMIT = 0

	// Calculate size: tag(1) + bundle_len(4) + bundle + num_proofs(4) + proofs
	proofSize := 0
	for _, proof := range nullifierProofs {
		// leaf(32) + path_len(4) + path + root(32)
		proofSize += 32 + 4 + len(proof.Siblings)*32 + 32
	}

	extrinsic := make([]byte, 0, 1+4+len(bundleBytes)+4+proofSize)

	// Tag byte
	extrinsic = append(extrinsic, TAG_BUNDLE_SUBMIT)

	// Bundle length (little-endian u32)
	bundleLen := uint32(len(bundleBytes))
	extrinsic = append(extrinsic, byte(bundleLen), byte(bundleLen>>8), byte(bundleLen>>16), byte(bundleLen>>24))

	// Bundle bytes
	extrinsic = append(extrinsic, bundleBytes...)

	// Number of proofs (little-endian u32)
	numProofs := uint32(len(nullifierProofs))
	extrinsic = append(extrinsic, byte(numProofs), byte(numProofs>>8), byte(numProofs>>16), byte(numProofs>>24))

	// Serialize each proof
	for _, proof := range nullifierProofs {
		// Leaf (32 bytes)
		extrinsic = append(extrinsic, proof.Leaf[:]...)

		// Path length (little-endian u32)
		pathLen := uint32(len(proof.Siblings))
		extrinsic = append(extrinsic, byte(pathLen), byte(pathLen>>8), byte(pathLen>>16), byte(pathLen>>24))

		// Path nodes
		for _, node := range proof.Siblings {
			extrinsic = append(extrinsic, node[:]...)
		}

		// Root (32 bytes)
		extrinsic = append(extrinsic, proof.Root[:]...)
	}

	return extrinsic
}

// ConvertToJAMWorkPackageBundle converts the Rust-generated work package format
// to the JAM types.WorkPackageBundle format expected by the node
func (wpf *WorkPackageFile) ConvertToJAMWorkPackageBundle(serviceID uint32, refineContext types.RefineContext, codeHash common.Hash) (*types.WorkPackageBundle, error) {
	if len(wpf.UserBundles) == 0 {
		return nil, fmt.Errorf("work package must contain at least one user bundle")
	}

	// Build extrinsic blobs - wrap each bundle with nullifier proofs in Orchard extrinsic format
	extrinsicBlobs := make([]types.ExtrinsicsBlobs, 1) // One work item
	workItemExtrinsics := make([][]byte, 0, len(wpf.UserBundles))
	workItemExtrinsicHashes := make([]types.WorkItemExtrinsic, 0, len(wpf.UserBundles))

	// Each bundle needs its corresponding nullifier absence proofs
	// For now, use all pre-state nullifier proofs for all bundles
	// (the Rust builder generates one bundle, so this works)
	nullifierProofs := wpf.PreStateWitnesses.NullifierAbsenceProofs

	for i, bundle := range wpf.UserBundles {
		if len(bundle.BundleBytes) == 0 {
			return nil, fmt.Errorf("bundle %d has empty bundle_bytes", i)
		}

		// Wrap bundle in Orchard extrinsic format with nullifier proofs
		extrinsicBytes := serializeOrchardExtrinsic(bundle.BundleBytes, nullifierProofs)
		workItemExtrinsics = append(workItemExtrinsics, extrinsicBytes)

		// Compute hash and length for WorkItemExtrinsic
		hash := common.Blake2Hash(extrinsicBytes)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: hash,
			Len:  uint32(len(extrinsicBytes)),
		})
	}
	extrinsicBlobs[0] = workItemExtrinsics

	// Create work package with single work item
	workPackage := types.WorkPackage{
		AuthCodeHost:          0,
		AuthorizationCodeHash: getBootstrapAuthCodeHash(),
		RefineContext:         refineContext,
		AuthorizationToken:    []byte{},
		ConfigurationBlob:     []byte{},
		WorkItems: []types.WorkItem{
			{
				Service:            serviceID,
				CodeHash:           codeHash,
				RefineGasLimit:     1_000_000_000, // 1B gas for refine
				AccumulateGasLimit: 10_000_000,    // 10MM gas for accumulate
				Payload:            []byte{},      // Orchard doesn't use payload blob
				Extrinsics:         workItemExtrinsicHashes,
				ImportedSegments:   []types.ImportSegment{},
				ExportCount:        0,
			},
		},
	}

	// Create bundle
	bundle := &types.WorkPackageBundle{
		WorkPackage:       workPackage,
		ExtrinsicData:     extrinsicBlobs,
		ImportSegmentData: make([][][]byte, 1), // One work item
		Justification:     make([][][]common.Hash, 1),
	}

	return bundle, nil
}

// SubmitWorkPackage loads a work package from file and submits it to the JAM network
func (r *OrchardRollup) SubmitWorkPackage(ctx context.Context, workPackagePath string) (common.Hash, uint32, error) {
	log.Info(log.Node, "Loading work package", "path", workPackagePath)

	// Load work package from file
	wpFile, err := LoadWorkPackageFromFile(workPackagePath)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to load work package: %w", err)
	}

	log.Info(log.Node, "Loaded work package",
		"bundles", len(wpFile.UserBundles),
		"gas_limit", wpFile.Metadata.GasLimit,
		"pre_commitment_size", wpFile.PreStateRoots.CommitmentSize,
		"post_commitment_size", wpFile.PostStateRoots.CommitmentSize)

	// Get refine context from node
	if r.node == nil {
		return common.Hash{}, 0, fmt.Errorf("node not available for submission")
	}

	refineContext, err := r.node.GetRefineContext()
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to get refine context: %w", err)
	}

	// Get service info to get code hash
	service, ok, err := r.node.GetStateDB().GetService(r.serviceID)
	if err != nil || !ok {
		log.Warn(log.Node, "Could not get service info, using empty code hash", "service_id", r.serviceID)
	}

	codeHash := common.Hash{}
	if service != nil {
		codeHash = service.CodeHash
	}

	// Convert to JAM bundle format
	bundle, err := wpFile.ConvertToJAMWorkPackageBundle(r.serviceID, refineContext, codeHash)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to convert work package: %w", err)
	}

	// Validate bundle
	if err := bundle.Validate(); err != nil {
		return common.Hash{}, 0, fmt.Errorf("work package validation failed: %w", err)
	}

	log.Info(log.Node, "Submitting work package bundle to JAM network")

	stateRoot, timeslot, err := r.node.SubmitAndWaitForWorkPackageBundle(ctx, bundle)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("work package submission failed: %w", err)
	}

	log.Info(log.Node, "Work package submitted successfully",
		"state_root", stateRoot.Hex(),
		"timeslot", timeslot)

	return stateRoot, timeslot, nil
}
