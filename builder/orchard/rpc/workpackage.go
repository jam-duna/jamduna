package rpc

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"os"
	"sort"
	"sync"

	"github.com/colorfulnotion/jam/common"
	"github.com/colorfulnotion/jam/log"
	"github.com/colorfulnotion/jam/statedb"
	"github.com/colorfulnotion/jam/types"
)

// Payload structure:
// - CommitmentRoot (32) + CommitmentSize (8) + FrontierCount (4) + Frontier (variable)
// - NullifierRoot (32) + NullifierSize (8)
// - TransparentMerkleRoot (32) + TransparentUtxoRoot (32) + TransparentUtxoSize (8)
// - SpentCommitmentProofCount (4) + Proofs (variable)
const orchardPreStatePayloadBaseLen = 32 + 8 + 4 + 32 + 8 + 32 + 32 + 8 + 4

var (
	bootstrapOnce           sync.Once
	bootstrap_auth_codehash common.Hash
)

// getBootstrapAuthCodeHash returns the authorization code hash for orchard service bootstrap
func getBootstrapAuthCodeHash() common.Hash {
	bootstrapOnce.Do(func() {
		auth_code_bytes := []byte(`
			package main
			func main() {
				// Bootstrap code for orchard service
			}
		`)
		auth_code := statedb.AuthorizeCode{
			PackageMetaData:   []byte("bootstrap"),
			AuthorizationCode: auth_code_bytes,
		}
		auth_code_encoded_bytes, err := auth_code.Encode()
		if err != nil {
			log.Warn(log.SDB, "Failed to encode bootstrap auth code, using zero hash", "err", err)
			bootstrap_auth_codehash = common.Hash{}
			return
		}
		bootstrap_auth_codehash = common.Blake2Hash(auth_code_encoded_bytes)
	})
	return bootstrap_auth_codehash
}

// WorkPackageFile represents the JSON structure of work package files
// generated by the Rust orchard-builder sequence command
//
// CURRENT FORMAT (3 extrinsics, CompactBlock derived from bundle_bytes):
//
//	pre_state_witness_extrinsic: serialized PreStateWitness (tag=1)
//	post_state_witness_extrinsic: serialized PostStateWitness (tag=2)
//	bundle_proof_extrinsic: serialized BundleProof (tag=3, includes bundle_bytes)
//	transparent_tx_data_extrinsic: optional TransparentTxData (tag=4)
type WorkPackageFile struct {
	// Pre-serialized extrinsics (3 extrinsics: PreStateWitness, PostStateWitness, BundleProof)
	// CompactBlock is derived from bundle_bytes during verification
	PreStateWitnessExtrinsic   []byte                 `json:"pre_state_witness_extrinsic,omitempty"`
	PostStateWitnessExtrinsic  []byte                 `json:"post_state_witness_extrinsic,omitempty"`
	BundleProofExtrinsic       []byte                 `json:"bundle_proof_extrinsic,omitempty"`
	TransparentTxDataExtrinsic []byte                 `json:"transparent_tx_data_extrinsic,omitempty"`
	PreState                   *OrchardStateRoots     `json:"pre_state,omitempty"`
	PostState                  *OrchardStateRoots     `json:"post_state,omitempty"`
	PreStateCommitments        [][32]byte             `json:"pre_state_commitments,omitempty"`
	SpentCommitmentProofs      []SpentCommitmentProof `json:"spent_commitment_proofs,omitempty"`
	BundleType                 OrchardBundleType      `json:"bundle_type,omitempty"`
	OrchardBundleBytes         []byte                 `json:"orchard_bundle_bytes,omitempty"`
	IssueBundleBytes           []byte                 `json:"issue_bundle_bytes,omitempty"`

	// OLD: Legacy format (for backwards compatibility)
	PreStateRoots      OrchardStateRoots `json:"pre_state_roots"`
	PostStateRoots     OrchardStateRoots `json:"post_state_roots"`
	PreStateWitnesses  StateWitnesses    `json:"pre_state_witnesses"`
	PostStateWitnesses StateWitnesses    `json:"post_state_witnesses"`
	UserBundles        []UserBundle      `json:"user_bundles"`
	Metadata           WorkPackageMeta   `json:"metadata"`
}

// OrchardBundleType mirrors NU7 bundle type tags.
type OrchardBundleType uint8

const (
	OrchardBundleVanilla OrchardBundleType = 0x00
	OrchardBundleZSA     OrchardBundleType = 0x01
	OrchardBundleSwap    OrchardBundleType = 0x02
)

// StateWitnesses contains Merkle proofs for commitment and nullifier trees
type StateWitnesses struct {
	NullifierAbsenceProofs    []NullifierAbsenceProof `json:"nullifier_absence_proofs"`
	SpentNoteCommitmentProofs []interface{}           `json:"spent_note_commitment_proofs"`
}

// NullifierAbsenceProof proves a nullifier doesn't exist in the tree
type NullifierAbsenceProof struct {
	Leaf     [32]byte   `json:"leaf"`
	Siblings [][32]byte `json:"siblings"` // Merkle path
	Root     [32]byte   `json:"root"`
	Position uint64     `json:"position"`
}

// OrchardStateRoots captures commitment and nullifier tree state
type OrchardStateRoots struct {
	CommitmentRoot     [32]byte   `json:"commitment_root"`
	CommitmentSize     uint64     `json:"commitment_size"`
	CommitmentFrontier [][32]byte `json:"commitment_frontier,omitempty"`
	NullifierRoot      [32]byte   `json:"nullifier_root"`
	NullifierSize      uint64     `json:"nullifier_size"`

	// Transparent transaction state (optional, may be zero if no transparent txs)
	TransparentMerkleRoot [32]byte `json:"transparent_merkle_root,omitempty"`
	TransparentUtxoRoot   [32]byte `json:"transparent_utxo_root,omitempty"`
	TransparentUtxoSize   uint64   `json:"transparent_utxo_size,omitempty"`
}

// SpentCommitmentProof proves a spent commitment exists in the tree
type SpentCommitmentProof struct {
	Nullifier      [32]byte   `json:"nullifier"`
	Commitment     [32]byte   `json:"commitment"`
	TreePosition   uint64     `json:"tree_position"`
	BranchSiblings [][32]byte `json:"branch_siblings"`
}

type transparentTxEntry struct {
	txid        [32]byte
	txidDisplay string
	raw         []byte
	parsed      *ZcashTxV5
}

// UserBundle contains Orchard actions and bundle bytes
type UserBundle struct {
	Actions     []OrchardAction `json:"actions"`
	BundleBytes []byte          `json:"bundle_bytes"`
}

// OrchardAction represents a single shielded action
type OrchardAction struct {
	Commitment            [32]byte `json:"commitment"`
	Nullifier             [32]byte `json:"nullifier"`
	NullifierAbsenceIndex uint64   `json:"nullifier_absence_index"`
	SpentCommitmentIndex  uint64   `json:"spent_commitment_index"`
}

// WorkPackageMeta contains metadata like gas limits
type WorkPackageMeta struct {
	GasLimit uint64 `json:"gas_limit"`
}

// LoadWorkPackageFromFile reads and parses a work package JSON file
func LoadWorkPackageFromFile(path string) (*WorkPackageFile, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read work package file: %w", err)
	}

	var wpFile WorkPackageFile
	if err := json.Unmarshal(data, &wpFile); err != nil {
		return nil, fmt.Errorf("failed to parse work package JSON: %w", err)
	}

	return &wpFile, nil
}

func buildOrchardPreStatePayload(
	preState OrchardStateRoots,
	frontier [][32]byte,
	spentCommitmentProofs []SpentCommitmentProof,
) []byte {
	payload := make([]byte, 0, orchardPreStatePayloadBaseLen)
	payload = append(payload, preState.CommitmentRoot[:]...)

	var buf [8]byte
	binary.LittleEndian.PutUint64(buf[:], preState.CommitmentSize)
	payload = append(payload, buf[:]...)

	var countBuf [4]byte
	binary.LittleEndian.PutUint32(countBuf[:], uint32(len(frontier)))
	payload = append(payload, countBuf[:]...)
	for _, node := range frontier {
		payload = append(payload, node[:]...)
	}

	payload = append(payload, preState.NullifierRoot[:]...)
	binary.LittleEndian.PutUint64(buf[:], preState.NullifierSize)
	payload = append(payload, buf[:]...)

	// Transparent state (32 + 32 + 8 bytes)
	payload = append(payload, preState.TransparentMerkleRoot[:]...)
	payload = append(payload, preState.TransparentUtxoRoot[:]...)
	binary.LittleEndian.PutUint64(buf[:], preState.TransparentUtxoSize)
	payload = append(payload, buf[:]...)

	binary.LittleEndian.PutUint32(countBuf[:], uint32(len(spentCommitmentProofs)))
	payload = append(payload, countBuf[:]...)
	for _, proof := range spentCommitmentProofs {
		payload = append(payload, proof.Nullifier[:]...)
		payload = append(payload, proof.Commitment[:]...)
		binary.LittleEndian.PutUint64(buf[:], proof.TreePosition)
		payload = append(payload, buf[:]...)
		binary.LittleEndian.PutUint32(countBuf[:], uint32(len(proof.BranchSiblings)))
		payload = append(payload, countBuf[:]...)
		for _, sibling := range proof.BranchSiblings {
			payload = append(payload, sibling[:]...)
		}
	}

	return payload
}

// SerializePreStateWitness builds the PreStateWitness extrinsic (tag=1).
// If preStateRoot is non-zero, it is used as the JAM state root and an optional
// orchard_state read is included for root binding.
func SerializePreStateWitness(
	preState *OrchardStateRoots,
	nullifiers [][32]byte,
	proofs map[[32]byte]NullifierAbsenceProof,
	preStateRoot [32]byte,
	orchardStateValue []byte,
	orchardStateProof [][32]byte,
) ([]byte, error) {
	if preState == nil {
		return nil, fmt.Errorf("pre-state unavailable")
	}

	witness := make([]byte, 0, 64+4)
	root := preStateRoot
	if root == ([32]byte{}) {
		root = preState.NullifierRoot
	}
	witness = append(witness, root[:]...)
	witness = append(witness, root[:]...)

	var buf [4]byte
	readCount := len(nullifiers)
	if len(orchardStateValue) > 0 {
		readCount++
	}
	binary.LittleEndian.PutUint32(buf[:], uint32(readCount))
	witness = append(witness, buf[:]...)

	if len(orchardStateValue) > 0 {
		if err := serializeStateRead(&witness, "orchard_state", orchardStateValue, orchardStateProof); err != nil {
			return nil, err
		}
	}

	for _, nullifier := range nullifiers {
		proof, ok := proofs[nullifier]
		if !ok {
			return nil, fmt.Errorf("missing absence proof for nullifier %x", nullifier[:4])
		}

		key := fmt.Sprintf("nullifier_%x", nullifier[:])
		value := make([]byte, 32)
		if err := serializeStateRead(&witness, key, value, proof.Siblings); err != nil {
			return nil, err
		}
	}

	binary.LittleEndian.PutUint32(buf[:], 0)
	witness = append(witness, buf[:]...)

	extrinsic := make([]byte, 0, 1+4+len(witness))
	extrinsic = append(extrinsic, 1)
	binary.LittleEndian.PutUint32(buf[:], uint32(len(witness)))
	extrinsic = append(extrinsic, buf[:]...)
	extrinsic = append(extrinsic, witness...)
	return extrinsic, nil
}

// SerializePostStateWitness builds the PostStateWitness extrinsic (tag=2).
// Now includes transparent state roots for validator verification.
func SerializePostStateWitness(postState *OrchardStateRoots) ([]byte, error) {
	if postState == nil {
		return nil, fmt.Errorf("post-state unavailable")
	}

	// Pre-nullifier root (32) + post-commitment root (32) + read count (4) + write count (4)
	// + transparent merkle root (32) + transparent utxo root (32) + transparent utxo size (8)
	witness := make([]byte, 0, 32+32+4+4+32+32+8)

	// Shielded state (existing)
	witness = append(witness, make([]byte, 32)...)            // pre-nullifier root (unused, zeros)
	witness = append(witness, postState.CommitmentRoot[:]...) // post-commitment root

	var buf4 [4]byte
	var buf8 [8]byte
	binary.LittleEndian.PutUint32(buf4[:], 0) // state read count
	witness = append(witness, buf4[:]...)
	binary.LittleEndian.PutUint32(buf4[:], 0) // state write count
	witness = append(witness, buf4[:]...)

	// Transparent state (NEW)
	witness = append(witness, postState.TransparentMerkleRoot[:]...)
	witness = append(witness, postState.TransparentUtxoRoot[:]...)
	binary.LittleEndian.PutUint64(buf8[:], postState.TransparentUtxoSize)
	witness = append(witness, buf8[:]...)

	extrinsic := make([]byte, 0, 1+4+len(witness))
	extrinsic = append(extrinsic, 2) // tag=2
	binary.LittleEndian.PutUint32(buf4[:], uint32(len(witness)))
	extrinsic = append(extrinsic, buf4[:]...)
	extrinsic = append(extrinsic, witness...)
	return extrinsic, nil
}

// SerializeBundleProof builds the BundleProof extrinsic (tag=3).
func SerializeBundleProof(vkID uint32, publicInputs [][32]byte, proofBytes, bundleBytes []byte) []byte {
	var buf [4]byte
	extrinsic := make([]byte, 0, 1+4+4+len(publicInputs)*32+4+len(proofBytes)+4+len(bundleBytes))
	extrinsic = append(extrinsic, 3)
	binary.LittleEndian.PutUint32(buf[:], vkID)
	extrinsic = append(extrinsic, buf[:]...)
	binary.LittleEndian.PutUint32(buf[:], uint32(len(publicInputs)))
	extrinsic = append(extrinsic, buf[:]...)
	for _, input := range publicInputs {
		extrinsic = append(extrinsic, input[:]...)
	}
	binary.LittleEndian.PutUint32(buf[:], uint32(len(proofBytes)))
	extrinsic = append(extrinsic, buf[:]...)
	extrinsic = append(extrinsic, proofBytes...)
	binary.LittleEndian.PutUint32(buf[:], uint32(len(bundleBytes)))
	extrinsic = append(extrinsic, buf[:]...)
	extrinsic = append(extrinsic, bundleBytes...)
	return extrinsic
}

// SerializeBundleProofV6 builds the BundleProofV6 extrinsic (tag=5).
func SerializeBundleProofV6(bundleType OrchardBundleType, orchardBundleBytes []byte, issueBundleBytes []byte) []byte {
	var buf4 [4]byte
	extrinsic := make([]byte, 0, 1+1+4+len(orchardBundleBytes)+1+4+len(issueBundleBytes))
	extrinsic = append(extrinsic, 5) // tag=5
	extrinsic = append(extrinsic, byte(bundleType))

	binary.LittleEndian.PutUint32(buf4[:], uint32(len(orchardBundleBytes)))
	extrinsic = append(extrinsic, buf4[:]...)
	extrinsic = append(extrinsic, orchardBundleBytes...)

	if len(issueBundleBytes) > 0 {
		extrinsic = append(extrinsic, 0x01)
		binary.LittleEndian.PutUint32(buf4[:], uint32(len(issueBundleBytes)))
		extrinsic = append(extrinsic, buf4[:]...)
		extrinsic = append(extrinsic, issueBundleBytes...)
	} else {
		extrinsic = append(extrinsic, 0x00)
	}

	return extrinsic
}

// SerializeTransparentTxData builds the TransparentTxData extrinsic (tag=4).
// Format:
//
//	tag (1 byte) = 4
//	data_len (4 bytes)
//	tx_count (4 bytes)
//	for each tx:
//	  tx_len (4 bytes)
//	  raw_tx (tx_len bytes)
//	  input_count (4 bytes)
//	  for each input:
//	    proof_len (4 bytes)
//	    utxo_proof (proof_len bytes)
//	utxo_snapshot_count (4 bytes)
//	for each utxo:
//	  txid (32 bytes)
//	  vout (4 bytes)
//	  value (8 bytes)
//	  script_len (4 bytes)
//	  script_pubkey (script_len bytes)
//	  height (4 bytes)
//	  is_coinbase (1 byte)
func SerializeTransparentTxData(
	txs [][]byte,
	utxoProofs [][]UTXOMerkleProof,
	utxoSnapshot []UtxoSnapshotEntry,
) ([]byte, error) {
	if len(txs) != len(utxoProofs) {
		return nil, fmt.Errorf("tx count (%d) != proof count (%d)", len(txs), len(utxoProofs))
	}

	var buf [4]byte
	data := make([]byte, 0, 4)
	binary.LittleEndian.PutUint32(buf[:], uint32(len(txs)))
	data = append(data, buf[:]...)

	for i, tx := range txs {
		// Serialize raw tx
		binary.LittleEndian.PutUint32(buf[:], uint32(len(tx)))
		data = append(data, buf[:]...)
		data = append(data, tx...)

		// Serialize UTXO proofs for this tx
		proofs := utxoProofs[i]
		binary.LittleEndian.PutUint32(buf[:], uint32(len(proofs)))
		data = append(data, buf[:]...)

		for _, proof := range proofs {
			proofBytes := serializeUTXOMerkleProof(proof)
			binary.LittleEndian.PutUint32(buf[:], uint32(len(proofBytes)))
			data = append(data, buf[:]...)
			data = append(data, proofBytes...)
		}
	}

	binary.LittleEndian.PutUint32(buf[:], uint32(len(utxoSnapshot)))
	data = append(data, buf[:]...)
	for _, entry := range utxoSnapshot {
		data = append(data, serializeUtxoSnapshotEntry(entry)...)
	}

	extrinsic := make([]byte, 0, 1+4+len(data))
	extrinsic = append(extrinsic, 4) // tag=4
	binary.LittleEndian.PutUint32(buf[:], uint32(len(data)))
	extrinsic = append(extrinsic, buf[:]...)
	extrinsic = append(extrinsic, data...)
	return extrinsic, nil
}

// serializeUTXOMerkleProof serializes a UTXO Merkle proof to bytes.
// Format matches design doc specification for canonical serialization.
func serializeUTXOMerkleProof(proof UTXOMerkleProof) []byte {
	var buf4 [4]byte
	var buf8 [8]byte

	data := make([]byte, 0, 32+4+8+4+len(proof.ScriptPubKey)+4+1+8+4+len(proof.Siblings)*32)

	// Outpoint (36 bytes total)
	data = append(data, proof.Outpoint.Txid[:]...)              // 32 bytes
	binary.LittleEndian.PutUint32(buf4[:], proof.Outpoint.Vout) // 4 bytes
	data = append(data, buf4[:]...)

	// Value (8 bytes)
	binary.LittleEndian.PutUint64(buf8[:], proof.Value)
	data = append(data, buf8[:]...)

	// ScriptPubKey (4 + variable bytes)
	binary.LittleEndian.PutUint32(buf4[:], uint32(len(proof.ScriptPubKey)))
	data = append(data, buf4[:]...)
	data = append(data, proof.ScriptPubKey...)

	// Height (4 bytes)
	binary.LittleEndian.PutUint32(buf4[:], proof.Height)
	data = append(data, buf4[:]...)

	// Coinbase flag (1 byte)
	if proof.IsCoinbase {
		data = append(data, 1)
	} else {
		data = append(data, 0)
	}

	// Tree position (8 bytes)
	binary.LittleEndian.PutUint64(buf8[:], proof.TreePosition)
	data = append(data, buf8[:]...)

	// Sibling count + siblings (4 + 32*n bytes)
	binary.LittleEndian.PutUint32(buf4[:], uint32(len(proof.Siblings)))
	data = append(data, buf4[:]...)
	for _, sibling := range proof.Siblings {
		data = append(data, sibling[:]...)
	}

	return data
}

func serializeUtxoSnapshotEntry(entry UtxoSnapshotEntry) []byte {
	var buf4 [4]byte
	var buf8 [8]byte

	data := make([]byte, 0, 32+4+8+4+len(entry.ScriptPubKey)+4+1)
	data = append(data, entry.Outpoint.Txid[:]...)
	binary.LittleEndian.PutUint32(buf4[:], entry.Outpoint.Vout)
	data = append(data, buf4[:]...)

	binary.LittleEndian.PutUint64(buf8[:], entry.Value)
	data = append(data, buf8[:]...)

	binary.LittleEndian.PutUint32(buf4[:], uint32(len(entry.ScriptPubKey)))
	data = append(data, buf4[:]...)
	data = append(data, entry.ScriptPubKey...)

	binary.LittleEndian.PutUint32(buf4[:], entry.Height)
	data = append(data, buf4[:]...)

	if entry.IsCoinbase {
		data = append(data, 1)
	} else {
		data = append(data, 0)
	}

	return data
}

func computeTransparentUtxoTransition(
	snapshot []UtxoSnapshotEntry,
	entries []transparentTxEntry,
	currentHeight uint32,
) ([32]byte, uint64, error) {
	tree := NewTransparentUtxoTree()
	for _, entry := range snapshot {
		tree.Insert(entry.Outpoint, UtxoData{
			Value:        entry.Value,
			ScriptPubKey: entry.ScriptPubKey,
			Height:       entry.Height,
			IsCoinbase:   entry.IsCoinbase,
		})
	}

	for _, entry := range entries {
		for _, input := range entry.parsed.Inputs {
			if input.IsCoinbase() {
				return [32]byte{}, 0, fmt.Errorf("coinbase input in mempool tx")
			}
			if err := tree.Remove(Outpoint{
				Txid: input.PrevOutHash,
				Vout: input.PrevOutIndex,
			}); err != nil {
				return [32]byte{}, 0, fmt.Errorf("utxo remove: %w", err)
			}
		}
		for vout, output := range entry.parsed.Outputs {
			tree.Insert(Outpoint{
				Txid: entry.parsed.TxID,
				Vout: uint32(vout),
			}, UtxoData{
				Value:        output.Value,
				ScriptPubKey: output.ScriptPubKey,
				Height:       currentHeight,
				IsCoinbase:   false,
			})
		}
	}

	root, err := tree.GetRoot()
	if err != nil {
		return [32]byte{}, 0, fmt.Errorf("utxo root: %w", err)
	}
	return root, uint64(tree.Size()), nil
}

func (r *OrchardRollup) buildTransparentTxDataExtrinsic(currentHeight uint32) ([]transparentTxEntry, []byte, [32]byte, [32]byte, uint64, [32]byte, uint64, error) {
	if r == nil || r.transparentTxStore == nil || r.transparentUtxoTree == nil {
		return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, nil
	}
	if r.transparentStore != nil {
		if err := r.syncTransparentUtxoTreeFromStore(); err != nil {
			return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("refresh transparent UTXO tree: %w", err)
		}
	}

	mempoolTxs := r.transparentTxStore.snapshotMempoolTransactions()
	if len(mempoolTxs) == 0 && r.transparentUtxoTree.Size() == 0 {
		return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, nil
	}

	entries := make([]transparentTxEntry, 0, len(mempoolTxs))
	for _, tx := range mempoolTxs {
		raw, err := hex.DecodeString(stripHexPrefix(tx.RawHex))
		if err != nil {
			return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("transparent tx hex decode: %w", err)
		}
		parsed, err := ParseZcashTxV5(raw)
		if err != nil {
			return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("transparent tx parse: %w", err)
		}
		entries = append(entries, transparentTxEntry{
			txid:        parsed.TxID,
			txidDisplay: parsed.TxIDDisplay,
			raw:         raw,
			parsed:      parsed,
		})
	}

	sort.Slice(entries, func(i, j int) bool {
		return bytes.Compare(entries[i].txid[:], entries[j].txid[:]) < 0
	})

	rawTxs := make([][]byte, 0, len(entries))
	utxoProofs := make([][]UTXOMerkleProof, 0, len(entries))
	leaves := make([][32]byte, 0, len(entries))

	for _, entry := range entries {
		rawTxs = append(rawTxs, entry.raw)
		leaves = append(leaves, entry.txid)

		proofs := make([]UTXOMerkleProof, len(entry.parsed.Inputs))
		for i, input := range entry.parsed.Inputs {
			if input.IsCoinbase() {
				return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("coinbase input in mempool tx")
			}

			proof, err := r.transparentUtxoTree.GetProof(Outpoint{
				Txid: input.PrevOutHash,
				Vout: input.PrevOutIndex,
			})
			if err != nil {
				return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("utxo proof: %w", err)
			}
			proofs[i] = *proof
		}
		utxoProofs = append(utxoProofs, proofs)
	}

	snapshot := r.transparentUtxoTree.Snapshot()
	extrinsic, err := SerializeTransparentTxData(rawTxs, utxoProofs, snapshot)
	if err != nil {
		return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, err
	}

	merkleRoot := buildMerkleRoot(leaves)
	utxoRoot, err := r.transparentUtxoTree.GetRoot()
	if err != nil {
		return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, fmt.Errorf("utxo root: %w", err)
	}

	postRoot, postSize, err := computeTransparentUtxoTransition(snapshot, entries, currentHeight)
	if err != nil {
		return nil, nil, [32]byte{}, [32]byte{}, 0, [32]byte{}, 0, err
	}

	return entries, extrinsic, merkleRoot, utxoRoot, uint64(r.transparentUtxoTree.Size()), postRoot, postSize, nil
}

func serializeStateRead(buf *[]byte, key string, value []byte, proof [][32]byte) error {
	var lenBuf [4]byte
	binary.LittleEndian.PutUint32(lenBuf[:], uint32(len(key)))
	*buf = append(*buf, lenBuf[:]...)
	*buf = append(*buf, []byte(key)...)

	binary.LittleEndian.PutUint32(lenBuf[:], uint32(len(value)))
	*buf = append(*buf, lenBuf[:]...)
	*buf = append(*buf, value...)

	binary.LittleEndian.PutUint32(lenBuf[:], uint32(len(proof)))
	*buf = append(*buf, lenBuf[:]...)
	for _, node := range proof {
		*buf = append(*buf, node[:]...)
	}
	return nil
}

// ConvertToJAMWorkPackageBundle converts the Rust-generated work package format
// to the JAM types.WorkPackageBundle format expected by the node
//
// Creates THREE extrinsics per work item (optional fourth for transparent data):
// 1. PreStateWitness - Merkle proofs for pre-state (commitment_root, nullifier absences)
// 2. PostStateWitness - Merkle proofs for post-state (new commitment_root, spent nullifiers)
// 3. BundleProof - Halo2 proof + public inputs + bundle_bytes
// 4. TransparentTxData - Raw transparent txs + UTXO proofs (tag=4, optional)
//
// CompactBlock is derived from bundle_bytes during refine, not submitted as separate extrinsic
func (wpf *WorkPackageFile) ConvertToJAMWorkPackageBundle(serviceID uint32, refineContext types.RefineContext, codeHash common.Hash) (*types.WorkPackageBundle, error) {
	// Build the extrinsics (CompactBlock derived from bundle_bytes)
	extrinsicBlobs := make([]types.ExtrinsicsBlobs, 1) // One work item
	workItemExtrinsics := make([][]byte, 0, 4)
	workItemExtrinsicHashes := make([]types.WorkItemExtrinsic, 0, 4)

	// Check if format with pre-serialized extrinsics (3 extrinsics)
	if len(wpf.PreStateWitnessExtrinsic) > 0 &&
		len(wpf.PostStateWitnessExtrinsic) > 0 &&
		len(wpf.BundleProofExtrinsic) > 0 {

		log.Info(log.Node, "Using format with 3 pre-serialized extrinsics (CompactBlock derived from bundle_bytes)")

		workItemExtrinsics = append(workItemExtrinsics, wpf.PreStateWitnessExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(wpf.PreStateWitnessExtrinsic),
			Len:  uint32(len(wpf.PreStateWitnessExtrinsic)),
		})

		workItemExtrinsics = append(workItemExtrinsics, wpf.PostStateWitnessExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(wpf.PostStateWitnessExtrinsic),
			Len:  uint32(len(wpf.PostStateWitnessExtrinsic)),
		})

		workItemExtrinsics = append(workItemExtrinsics, wpf.BundleProofExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(wpf.BundleProofExtrinsic),
			Len:  uint32(len(wpf.BundleProofExtrinsic)),
		})

		if len(wpf.TransparentTxDataExtrinsic) > 0 {
			workItemExtrinsics = append(workItemExtrinsics, wpf.TransparentTxDataExtrinsic)
			workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
				Hash: common.Blake2Hash(wpf.TransparentTxDataExtrinsic),
				Len:  uint32(len(wpf.TransparentTxDataExtrinsic)),
			})
		}

	} else {
		log.Warn(log.Node, "Using OLD format - Rust builder needs update to generate 3 extrinsics")
		log.Warn(log.Node, "Creating placeholder extrinsics - will fail in service verification")

		// OLD: Create placeholder extrinsics (these won't work for real verification)
		preWitnessExtrinsic := []byte{1, 4, 0, 0, 0, 0x00, 0x00, 0x00, 0x00}  // tag=1, len=4, dummy data
		postWitnessExtrinsic := []byte{2, 4, 0, 0, 0, 0x00, 0x00, 0x00, 0x00} // tag=2, len=4, dummy data
		bundleProofExtrinsic := []byte{3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} // tag=3, vk_id=0, inputs=0, proof=0, bundle_bytes=0

		workItemExtrinsics = append(workItemExtrinsics, preWitnessExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(preWitnessExtrinsic),
			Len:  uint32(len(preWitnessExtrinsic)),
		})

		workItemExtrinsics = append(workItemExtrinsics, postWitnessExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(postWitnessExtrinsic),
			Len:  uint32(len(postWitnessExtrinsic)),
		})

		workItemExtrinsics = append(workItemExtrinsics, bundleProofExtrinsic)
		workItemExtrinsicHashes = append(workItemExtrinsicHashes, types.WorkItemExtrinsic{
			Hash: common.Blake2Hash(bundleProofExtrinsic),
			Len:  uint32(len(bundleProofExtrinsic)),
		})
	}

	extrinsicBlobs[0] = workItemExtrinsics

	// Create work package with single work item
	// Use PreState if available (new format), otherwise use PreStateRoots (old format)
	var preStateRoots OrchardStateRoots
	if wpf.PreState != nil {
		preStateRoots = *wpf.PreState
		log.Info(log.Node, "Using PreState from new format")
	} else {
		preStateRoots = wpf.PreStateRoots
		log.Info(log.Node, "Using PreStateRoots from old format")
	}

	frontier := preStateRoots.CommitmentFrontier
	if len(frontier) == 0 && preStateRoots.CommitmentSize > 0 {
		log.Warn(log.Node, "Missing commitment frontier in work package payload",
			"commitment_size", preStateRoots.CommitmentSize)
	}

	const refineGasLimit uint64 = 5_000_000_000
	workPackage := types.WorkPackage{
		AuthCodeHost:          0,
		AuthorizationCodeHash: getBootstrapAuthCodeHash(),
		RefineContext:         refineContext,
		AuthorizationToken:    []byte{},
		ConfigurationBlob:     []byte{},
		WorkItems: []types.WorkItem{
			{
				Service:            serviceID,
				CodeHash:           codeHash,
				RefineGasLimit:     refineGasLimit,
				AccumulateGasLimit: 10_000_000, // 10MM gas for accumulate
				Payload:            buildOrchardPreStatePayload(preStateRoots, frontier, wpf.SpentCommitmentProofs),
				Extrinsics:         workItemExtrinsicHashes,
				ImportedSegments:   []types.ImportSegment{},
				ExportCount:        0,
			},
		},
	}

	// Create bundle
	bundle := &types.WorkPackageBundle{
		WorkPackage:       workPackage,
		ExtrinsicData:     extrinsicBlobs,
		ImportSegmentData: make([][][]byte, 1), // One work item
		Justification:     make([][][]common.Hash, 1),
	}

	return bundle, nil
}

// SubmitWorkPackage loads a work package from file and submits it to the JAM network
func (r *OrchardRollup) SubmitWorkPackage(ctx context.Context, workPackagePath string) (common.Hash, uint32, error) {
	log.Info(log.Node, "Loading work package", "path", workPackagePath)

	// Load work package from file
	wpFile, err := LoadWorkPackageFromFile(workPackagePath)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to load work package: %w", err)
	}

	log.Info(log.Node, "Loaded work package",
		"bundles", len(wpFile.UserBundles),
		"gas_limit", wpFile.Metadata.GasLimit,
		"pre_commitment_size", wpFile.PreStateRoots.CommitmentSize,
		"post_commitment_size", wpFile.PostStateRoots.CommitmentSize)

	// Get refine context from node
	if r.node == nil {
		return common.Hash{}, 0, fmt.Errorf("node not available for submission")
	}

	refineContext, err := r.node.GetRefineContext()
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to get refine context: %w", err)
	}

	preTransparentMerkleRoot := [32]byte{}
	if r.transparentTxStore != nil {
		root, err := r.transparentTxStore.GetMerkleRoot(refineContext.LookupAnchorSlot)
		if err != nil {
			log.Warn(log.Node, "Failed to read transparent pre-state merkle root",
				"height", refineContext.LookupAnchorSlot,
				"err", err)
		} else {
			preTransparentMerkleRoot = root
		}
	}

	transparentEntries, transparentExtrinsic, transparentMerkleRoot, transparentUtxoRoot, transparentUtxoSize, transparentPostRoot, transparentPostSize, err := r.buildTransparentTxDataExtrinsic(refineContext.LookupAnchorSlot)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to build transparent tx extrinsic: %w", err)
	}
	if len(transparentExtrinsic) > 0 {
		wpFile.TransparentTxDataExtrinsic = transparentExtrinsic
		if wpFile.PreState != nil {
			wpFile.PreState.TransparentMerkleRoot = preTransparentMerkleRoot
			wpFile.PreState.TransparentUtxoRoot = transparentUtxoRoot
			wpFile.PreState.TransparentUtxoSize = transparentUtxoSize
		} else {
			wpFile.PreStateRoots.TransparentMerkleRoot = preTransparentMerkleRoot
			wpFile.PreStateRoots.TransparentUtxoRoot = transparentUtxoRoot
			wpFile.PreStateRoots.TransparentUtxoSize = transparentUtxoSize
		}
		if wpFile.PostState != nil {
			wpFile.PostState.TransparentMerkleRoot = transparentMerkleRoot
			wpFile.PostState.TransparentUtxoRoot = transparentPostRoot
			wpFile.PostState.TransparentUtxoSize = transparentPostSize
		} else {
			wpFile.PostStateRoots.TransparentMerkleRoot = transparentMerkleRoot
			wpFile.PostStateRoots.TransparentUtxoRoot = transparentPostRoot
			wpFile.PostStateRoots.TransparentUtxoSize = transparentPostSize
		}
		if len(wpFile.PostStateWitnessExtrinsic) > 0 {
			postState := wpFile.PostState
			if postState == nil {
				postState = &wpFile.PostStateRoots
			}
			postStateWitness, err := SerializePostStateWitness(postState)
			if err != nil {
				return common.Hash{}, 0, fmt.Errorf("failed to update post-state witness: %w", err)
			}
			wpFile.PostStateWitnessExtrinsic = postStateWitness
		}
	}

	if len(wpFile.BundleProofExtrinsic) == 0 &&
		(wpFile.BundleType == OrchardBundleZSA || wpFile.BundleType == OrchardBundleSwap) {
		shouldEmit := len(wpFile.OrchardBundleBytes) > 0
		if wpFile.BundleType == OrchardBundleZSA && len(wpFile.IssueBundleBytes) > 0 {
			shouldEmit = true
		}
		if shouldEmit {
			wpFile.BundleProofExtrinsic = SerializeBundleProofV6(
				wpFile.BundleType,
				wpFile.OrchardBundleBytes,
				wpFile.IssueBundleBytes,
			)
		}
	}

	// Get service info to get code hash
	service, ok, err := r.node.GetStateDB().GetService(r.serviceID)
	if err != nil || !ok {
		log.Warn(log.Node, "Could not get service info, using empty code hash", "service_id", r.serviceID)
	}

	codeHash := common.Hash{}
	if service != nil {
		codeHash = service.CodeHash
	}

	// Convert to JAM bundle format
	bundle, err := wpFile.ConvertToJAMWorkPackageBundle(r.serviceID, refineContext, codeHash)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("failed to convert work package: %w", err)
	}

	// Validate bundle
	if err := bundle.Validate(); err != nil {
		return common.Hash{}, 0, fmt.Errorf("work package validation failed: %w", err)
	}

	log.Info(log.Node, "Submitting work package bundle to JAM network")

	stateRoot, timeslot, err := r.node.SubmitAndWaitForWorkPackageBundle(ctx, bundle)
	if err != nil {
		return common.Hash{}, 0, fmt.Errorf("work package submission failed: %w", err)
	}

	if len(transparentEntries) > 0 && r.transparentTxStore != nil {
		txids := make([]string, 0, len(transparentEntries))
		for _, entry := range transparentEntries {
			if entry.txidDisplay == "" {
				continue
			}
			txids = append(txids, entry.txidDisplay)
		}
		if len(txids) > 0 {
			if err := r.transparentTxStore.ConfirmTransactions(txids, timeslot, ""); err != nil {
				return common.Hash{}, 0, fmt.Errorf("confirm transparent transactions: %w", err)
			}
		}
	}

	log.Info(log.Node, "Work package submitted successfully",
		"state_root", stateRoot.Hex(),
		"timeslot", timeslot)

	return stateRoot, timeslot, nil
}
