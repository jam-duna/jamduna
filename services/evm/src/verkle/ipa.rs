//! IPA proof container, transcript, and verifier compatible with go-ipa.
//!
//! Layout (no length prefixes, fixed rounds inferred from size):
//!   L[0]...L[n-1] (compressed points, 32 bytes each)
//!   R[0]...R[n-1] (compressed points, 32 bytes each)
//!   A (Fr scalar, 32 bytes LE)

use alloc::vec;
use alloc::vec::Vec;
use ark_ff::{BigInteger, Field, PrimeField, Zero, One};
use sha2::{Digest, Sha256};

use super::curve::{BandersnatchPoint, VerkleError};
use super::field::Fr;
use super::srs::generate_srs_points;

/// Fixed IPA vector length (matches go-ipa / go-verkle).
pub const IPA_VECTOR_LENGTH: usize = 256;

/// Preimage hashes for cached SRS and barycentric weights (computed by genesis.go)
/// These are deterministic hashes of the precomputed cryptographic parameters stored
/// in the genesis block, enabling 620M gas savings per Verkle verification.
///
/// Generated by: statedb/genesis.go::initializeVerklePreimages()
/// - SRS: 256 Bandersnatch G1 points using seed "eth_verkle_oct_2021"
/// - Weights: Barycentric weights for 256-element domain
///
/// DO NOT MODIFY - these must match the genesis-generated preimages
const SRS_PREIMAGE_HASH: [u8; 32] = [
    0xd8, 0x5c, 0xf4, 0xd7, 0x3d, 0xec, 0x62, 0xc3, 0x9e, 0xa7, 0xee, 0xbf,
    0xf2, 0xa0, 0x7f, 0x2e, 0x28, 0xfd, 0xd1, 0xfe, 0x6b, 0xf8, 0xe0, 0x28,
    0x29, 0x0b, 0x5d, 0xec, 0xc3, 0x5c, 0xdb, 0x18,
];

const WEIGHTS_PREIMAGE_HASH: [u8; 32] = [
    0xeb, 0xfe, 0xc1, 0x98, 0xe9, 0xb7, 0x0e, 0xdf, 0x6f, 0x25, 0xc5, 0xe9,
    0xa4, 0x9d, 0x12, 0xd9, 0x4f, 0x81, 0x24, 0x25, 0xd0, 0x7d, 0xf8, 0xe6,
    0x38, 0x8a, 0x94, 0xdf, 0xbc, 0xbb, 0x13, 0x3d,
];


#[derive(Clone, Debug, PartialEq, Eq)]
pub struct IPAProof {
    pub l: Vec<BandersnatchPoint>,
    pub r: Vec<BandersnatchPoint>,
    pub a: Fr,
}

impl IPAProof {
    /// Serialize as l || r || a (no length prefixes).
    pub fn serialize(&self) -> Vec<u8> {
        let rounds = self.l.len();
        let mut out = Vec::with_capacity(rounds * 64 + 32);
        for p in &self.l {
            out.extend_from_slice(&p.to_bytes());
        }
        for p in &self.r {
            out.extend_from_slice(&p.to_bytes());
        }
        // Serialize a to fixed 32-byte little-endian (required for deserialize compatibility)
        let mut a_bytes = [0u8; 32];
        let a_le = self.a.into_bigint().to_bytes_le();
        a_bytes[..a_le.len()].copy_from_slice(&a_le);
        out.extend_from_slice(&a_bytes);
        out
    }

    /// Deserialize from the layout used in serialize().
    pub fn deserialize(bytes: &[u8]) -> Result<Self, VerkleError> {
        if bytes.len() < 32 {
            return Err(VerkleError::InvalidLength);
        }
        if (bytes.len() - 32) % 64 != 0 {
            return Err(VerkleError::InvalidLength);
        }

        let rounds = (bytes.len() - 32) / 64;
        let mut offset = 0;

        let mut l = Vec::with_capacity(rounds);
        for _ in 0..rounds {
            let mut buf = [0u8; 32];
            buf.copy_from_slice(&bytes[offset..offset + 32]);
            l.push(BandersnatchPoint::from_bytes(&buf)?);
            offset += 32;
        }

        let mut r = Vec::with_capacity(rounds);
        for _ in 0..rounds {
            let mut buf = [0u8; 32];
            buf.copy_from_slice(&bytes[offset..offset + 32]);
            r.push(BandersnatchPoint::from_bytes(&buf)?);
            offset += 32;
        }

        let mut a_bytes = [0u8; 32];
        a_bytes.copy_from_slice(&bytes[offset..offset + 32]);
        let a = Fr::from_le_bytes_mod_order(&a_bytes);

        Ok(IPAProof { l, r, a })
    }
}

// ==== Transcript (Fiat-Shamir) ====

/// Fiat-Shamir transcript matching go-ipa.
pub struct Transcript {
    state: Sha256,
    buffer: Vec<u8>,
}

impl Transcript {
    pub fn new(label: &[u8]) -> Self {
        let mut state = Sha256::new();
        state.update(label);
        Self {
            state,
            buffer: Vec::with_capacity(128),
        }
    }

    pub fn domain_sep(&mut self, label: &[u8]) {
        self.buffer.extend_from_slice(label);
    }

    pub fn append_scalar(&mut self, scalar: &Fr, label: &[u8]) {
        // Match go-ipa: transcript scalars are appended in little-endian form.
        let bytes = scalar.into_bigint().to_bytes_le();
        self.append_message(&bytes, label);
    }

    pub fn append_point(&mut self, point: &BandersnatchPoint, label: &[u8]) {
        let bytes = point.to_bytes();
        self.append_message(&bytes, label);
    }

    pub fn challenge_scalar(&mut self, label: &[u8]) -> Fr {
        self.domain_sep(label);

        self.state.update(&self.buffer);
        let hash: [u8; 32] = self.state.finalize_reset().into();
        self.buffer.clear();

        let challenge = Fr::from_le_bytes_mod_order(&hash);
        // Re-absorb the challenge to mirror go-ipa behavior
        self.append_scalar(&challenge, label);
        challenge
    }

    fn append_message(&mut self, message: &[u8], label: &[u8]) {
        self.buffer.extend_from_slice(label);
        self.buffer.extend_from_slice(message);
    }

    pub fn debug_buffer(&self) -> &[u8] {
        &self.buffer
    }
}

// ==== IPA verification config ====

#[derive(Clone)]
pub struct IPAConfig {
    pub srs: Vec<BandersnatchPoint>,
    pub q: BandersnatchPoint,
    precomputed: PrecomputedWeights,
    num_rounds: usize,
}

impl IPAConfig {
    /// Build config using cached preimages from genesis (620M gas savings!)
    /// Falls back to on-demand generation if preimages not found.
    pub fn new() -> Self {
        utils::functions::log_info("    ðŸ” IPA: new() called - attempting cached lookup first");

        // Try to load from cached preimages first
        match Self::try_from_cached_preimages() {
            Some(config) => {
                utils::functions::log_info("    ðŸ” IPA: Config loaded from genesis preimages (saved ~630M gas)");
                return config;
            }
            None => {
                utils::functions::log_info("    âš ï¸  IPA: Cached preimages not available, falling back to generation");
            }
        }

        // Fallback to on-demand generation
        utils::functions::log_info("    ðŸ” IPA: Building IPA config (generating SRS + weights)");
        utils::functions::log_info("    âš ï¸  IPA: Generating on-demand (630M gas cost) - preimages not found");

        let srs = generate_srs_points(IPA_VECTOR_LENGTH);
        utils::functions::log_info("    ðŸ” IPA: SRS generation complete");
        if !srs.is_empty() {
            let p0 = hex::encode(srs[0].to_bytes());
            let p1 = hex::encode(srs[1].to_bytes());
            utils::functions::log_info(&alloc::format!(
                "    ðŸ” IPA: SRS[0]={} SRS[1]={}",
                p0, p1
            ));
        }

        let precomputed = PrecomputedWeights::new();
        utils::functions::log_info("    ðŸ” IPA: Barycentric weights complete");

        let q = BandersnatchPoint::generator();
        let num_rounds = compute_num_rounds(IPA_VECTOR_LENGTH);

        utils::functions::log_info("    ðŸ” IPA: Config ready");
        Self {
            srs,
            q,
            precomputed,
            num_rounds,
        }
    }

    /// Try to load SRS and barycentric weights from genesis preimages
    /// Returns None if preimages not found or deserialization fails
    fn try_from_cached_preimages() -> Option<Self> {
        use utils::host_functions::historical_lookup;

        // Allocate buffers on heap (16MB heap allocated via sbrk in main)
        let mut srs_buffer = vec![0u8; 8192];
        let mut weights_buffer = vec![0u8; 33000];

        // Lookup SRS preimage
        let srs_len = unsafe {
            historical_lookup(
                0,
                SRS_PREIMAGE_HASH.as_ptr() as u64,
                srs_buffer.as_mut_ptr() as u64,
                0,
                srs_buffer.len() as u64,
            )
        };

        if srs_len == 0 {
            return None;
        }

        // Lookup weights preimage
        let weights_len = unsafe {
            historical_lookup(
                0,
                WEIGHTS_PREIMAGE_HASH.as_ptr() as u64,
                weights_buffer.as_mut_ptr() as u64,
                0,
                weights_buffer.len() as u64,
            )
        };

        if weights_len == 0 {
            return None;
        }

        if (srs_len as usize) > srs_buffer.len() || (weights_len as usize) > weights_buffer.len() {
            return None;
        }

        // Deserialize SRS
        let srs = deserialize_srs(&srs_buffer[..srs_len as usize])?;
        utils::functions::log_info("    âœ… SRS loaded from genesis (saved 264M gas)");

        // Deserialize barycentric weights; fall back to local generation if decode fails.
        let precomputed = match deserialize_barycentric_weights(&weights_buffer[..weights_len as usize]) {
            Some(barycentric_weights) => {
                utils::functions::log_info("    âœ… Weights loaded from genesis (saved 52M gas)");
                PrecomputedWeights { barycentric_weights }
            }
            None => {
                utils::functions::log_info("    âš ï¸  IPA: Weights preimage decode failed, generating locally");
                PrecomputedWeights::new()
            }
        };

        let q = BandersnatchPoint::generator();
        let num_rounds = compute_num_rounds(IPA_VECTOR_LENGTH);

        Some(Self {
            srs,
            q,
            precomputed,
            num_rounds,
        })
    }

    pub fn num_rounds(&self) -> usize {
        self.num_rounds
    }
}

/// Deserialize SRS from bytes (256 Ã— 32-byte compressed points)
fn deserialize_srs(bytes: &[u8]) -> Option<Vec<BandersnatchPoint>> {
    if bytes.len() != 256 * 32 {
        return None;
    }

    let mut srs = Vec::with_capacity(256);
    for i in 0..256 {
        let start = i * 32;
        let end = start + 32;
        let point_bytes: [u8; 32] = bytes[start..end].try_into().ok()?;
        let point = BandersnatchPoint::from_bytes(&point_bytes).ok()?;
        srs.push(point);
    }

    Some(srs)
}

/// Deserialize barycentric weights from bytes
/// Format from Go: [weights_count:4][weight_0:32][inv_weight_0:32][weight_1:32][inv_weight_1:32]...[inverted_count:4][inv_domain...]
/// Total: 4 + 512*32 + 4 + 510*32 = 32,712 bytes
fn deserialize_barycentric_weights(bytes: &[u8]) -> Option<[Fr; 256]> {
    if bytes.len() != 32712 {
        return None;
    }

    // Parse weights_count (first 4 bytes)
    let weights_count = u32::from_le_bytes([bytes[0], bytes[1], bytes[2], bytes[3]]);
    if weights_count != 512 {
        return None;
    }

    // Parse the first 256 barycentric weights (they're interleaved with inverses)
    // Format: [weight_0:32][inv_weight_0:32][weight_1:32][inv_weight_1:32]...
    // Each pair is 64 bytes, starting at offset 4
    let inverted_count_offset = 4 + (512 * 32);
    let inverted_count = u32::from_le_bytes([
        bytes[inverted_count_offset],
        bytes[inverted_count_offset + 1],
        bytes[inverted_count_offset + 2],
        bytes[inverted_count_offset + 3],
    ]);
    if inverted_count != 510 {
        return None;
    }

    let mut weights = [Fr::zero(); 256];
    for i in 0..256 {
        let start = 4 + (i * 64); // Skip count prefix, each pair is 64 bytes
        let end = start + 32;

        // Bounds check
        if end > bytes.len() {
            return None;
        }

        let mut bytes_array = [0u8; 32];
        bytes_array.copy_from_slice(&bytes[start..end]);

        // Go's fr.Element.Bytes() returns big-endian
        weights[i] = Fr::from_be_bytes_mod_order(&bytes_array);
    }

    Some(weights)
}

// ==== IPA verifier ====

const LABEL_C: &[u8] = b"C";
const LABEL_INPUT: &[u8] = b"input point";
const LABEL_OUTPUT: &[u8] = b"output point";
const LABEL_W: &[u8] = b"w";
const LABEL_L: &[u8] = b"L";
const LABEL_R: &[u8] = b"R";
const LABEL_X: &[u8] = b"x";
const LABEL_DOMAIN_SEP: &[u8] = b"ipa";

/// Verify IPA proof against commitment/evaluation (go-ipa compatible).
pub fn verify_ipa_proof(
    transcript: &mut Transcript,
    config: &IPAConfig,
    commitment: &BandersnatchPoint,
    proof: &IPAProof,
    eval_point: Fr,
    result: Fr,
) -> Result<bool, VerkleError> {
    // Match go-ipa: domain-separate inner IPA transcript
    transcript.domain_sep(LABEL_DOMAIN_SEP);

    if proof.l.len() != proof.r.len() {
        return Ok(false);
    }
    if proof.l.len() != config.num_rounds {
        return Ok(false);
    }

    let b = compute_b_vector(config, &eval_point);

    transcript.append_point(commitment, LABEL_C);
    transcript.append_scalar(&eval_point, LABEL_INPUT);
    transcript.append_scalar(&result, LABEL_OUTPUT);

    let w = transcript.challenge_scalar(LABEL_W);
    {
        use ark_ff::BigInteger;
        let w_bytes = w.into_bigint().to_bytes_le();
        utils::functions::log_info(&alloc::format!(
            "    ðŸ” IPA(inner): w = {}",
            hex::encode(&w_bytes)
        ));
    }

    let q = config.q.mul(&w);
    let qy = q.mul(&result);
    let mut acc_commitment = commitment.add(&qy);

    let challenges = generate_challenges(transcript, proof);
    for (i, ch) in challenges.iter().enumerate() {
        use ark_ff::BigInteger;
        let x_bytes = ch.into_bigint().to_bytes_le();
        utils::functions::log_info(&alloc::format!(
            "    ðŸ” IPA(inner): x[{}] = {}",
            i,
            hex::encode(&x_bytes)
        ));
    }
    let mut challenges_inv = challenges.clone();
    batch_invert(&mut challenges_inv);

    for (i, x) in challenges.iter().enumerate() {
        let l_i = proof.l[i];
        let r_i = proof.r[i];
        let x_inv = challenges_inv[i];

        // commitment + x*l + x^-1*r
        let scalars = [Fr::one(), *x, x_inv];
        let points = [acc_commitment, l_i, r_i];
        acc_commitment = BandersnatchPoint::msm(&points, &scalars);
    }

    // Folding scalars for SRS and b
    let folding_scalars = folding_scalars(&challenges_inv, config.num_rounds, config.srs.len());
    let g0 = BandersnatchPoint::msm(&config.srs, &folding_scalars);
    let b0 = inner_product(&b, &folding_scalars);

    let part1 = g0.mul(&proof.a);
    let scalar_ba = b0 * proof.a;
    let part2 = q.mul(&scalar_ba);
    let got = part1.add(&part2);

    utils::functions::log_info(&alloc::format!(
        "    ðŸ” IPA(inner): got={} expected={}",
        hex::encode(got.to_bytes()),
        hex::encode(acc_commitment.to_bytes())
    ));

    Ok(got.equivalent(&acc_commitment))
}

fn generate_challenges(transcript: &mut Transcript, proof: &IPAProof) -> Vec<Fr> {
    let mut out = Vec::with_capacity(proof.l.len());
    for i in 0..proof.l.len() {
        transcript.append_point(&proof.l[i], LABEL_L);
        transcript.append_point(&proof.r[i], LABEL_R);
        out.push(transcript.challenge_scalar(LABEL_X));
    }
    out
}

// Compute folding scalars for an index using challenge inverses (generic over num_rounds).
fn folding_scalars(challenges_inv: &[Fr], num_rounds: usize, len: usize) -> Vec<Fr> {
    let mut scalars = Vec::with_capacity(len);
    for i in 0..len {
        let mut acc = Fr::one();
        for (round, x_inv) in challenges_inv.iter().enumerate() {
            let bit_index = num_rounds - 1 - round;
            if ((i >> bit_index) & 1) == 1 {
                acc *= x_inv;
            }
        }
        scalars.push(acc);
    }
    scalars
}

fn inner_product(a: &[Fr], b: &[Fr]) -> Fr {
    assert_eq!(a.len(), b.len());
    let mut acc = Fr::zero();
    for (ai, bi) in a.iter().zip(b.iter()) {
        acc += *ai * bi;
    }
    acc
}

// ==== Barycentric helper (compute b vector) ====

#[derive(Clone)]
struct PrecomputedWeights {
    barycentric_weights: [Fr; IPA_VECTOR_LENGTH],
}

impl PrecomputedWeights {
    fn new() -> Self {
        let mut barycentric_weights = [Fr::zero(); IPA_VECTOR_LENGTH];
        for i in 0..IPA_VECTOR_LENGTH {
            barycentric_weights[i] = compute_barycentric_weight(i);
        }
        Self { barycentric_weights }
    }

    fn compute_coefficients(&self, point: &Fr) -> [Fr; IPA_VECTOR_LENGTH] {
        let mut lagrange = [Fr::zero(); IPA_VECTOR_LENGTH];
        let mut total_prod = Fr::one();

        for i in 0..IPA_VECTOR_LENGTH {
            let mut diff = *point;
            diff -= &Fr::from(i as u64);
            total_prod *= diff;

            let mut term = self.barycentric_weights[i];
            term *= diff;
            lagrange[i] = term;
        }

        batch_invert(&mut lagrange);
        for val in lagrange.iter_mut() {
            *val *= total_prod;
        }
        lagrange
    }
}

/// Compute barycentric weight wáµ¢ = âˆâ±¼â‰ áµ¢ (xáµ¢ - xâ±¼)
///
/// **NOTE**: This computes the raw product, not the inverse.
/// The inverse is taken later in compute_coefficients (line 294: batch_invert).
/// This matches the go-ipa implementation pattern.
fn compute_barycentric_weight(element: usize) -> Fr {
    let mut product = Fr::one();
    let element_fr = Fr::from(element as u64);
    for i in 0..IPA_VECTOR_LENGTH {
        if i == element {
            continue;
        }
        let i_fr = Fr::from(i as u64);
        let mut diff = element_fr;
        diff -= &i_fr;
        product *= diff;
    }
    product
}

fn compute_b_vector(config: &IPAConfig, eval_point: &Fr) -> [Fr; IPA_VECTOR_LENGTH] {
    if let Some(index) = eval_point_index(eval_point) {
        let mut b = [Fr::zero(); IPA_VECTOR_LENGTH];
        b[index] = Fr::one();
        b
    } else {
        config.precomputed.compute_coefficients(eval_point)
    }
}

fn eval_point_index(eval_point: &Fr) -> Option<usize> {
    let limbs = eval_point.into_bigint().0;
    if limbs[1] == 0 && limbs[2] == 0 && limbs[3] == 0 && limbs[0] <= 255 {
        Some(limbs[0] as usize)
    } else {
        None
    }
}

fn compute_num_rounds(vector_len: usize) -> usize {
    assert!(vector_len > 0 && vector_len.is_power_of_two());
    vector_len.trailing_zeros() as usize
}

/// Batch inversion using Montgomery's trick: O(n) field inversions instead of O(n) individual inversions.
///
/// **Algorithm**:
/// 1. Compute prefix products: prod[i] = v[0] Â· v[1] Â· ... Â· v[i-1]
/// 2. Invert final product once
/// 3. Backpropagate to compute individual inverses
///
/// Used in multiproof evaluation aggregation.
pub fn batch_invert(values: &mut [Fr]) {
    let len = values.len();
    let mut prod = vec![Fr::zero(); len];
    let mut acc = Fr::one();
    for (i, v) in values.iter().enumerate() {
        prod[i] = acc;
        acc *= v;
    }
    let mut acc_inv = acc.inverse().expect("non-zero inputs in batch_invert");
    for (i, v) in values.iter_mut().enumerate().rev() {
        let tmp = *v;
        *v = acc_inv * prod[i];
        acc_inv *= tmp;
    }
}
