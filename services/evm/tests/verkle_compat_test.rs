// Verkle Tree Compatibility Tests
//
// These tests verify byte-for-byte compatibility with go-verkle v0.2.2 and go-ipa.
//
// Test vectors generated by: ../../test_vectors/generate_verkle_vectors.go
//
// IMPORTANT: These tests will pass once the verkle implementation is complete.
// DO NOT use external rust-verkle crate - implement from scratch using VERKLE_RUST_SPEC.md
//
// Implementation location: services/evm/src/verkle/
// Required types: BandersnatchPoint, Fq, Fr, IPAProof
//
// NOTE: This test file requires std (uses std::vec::Vec in test code).

#![cfg(test)]

use hex_literal::hex;
use ark_ff::One;

use evm_service::verkle::{BandersnatchPoint, Fr, IPAProof, generate_srs_points, hash_point_to_bytes};

// Test vector: Generator point compression
//
// The Banderwagon generator point must compress to this exact value.
// This verifies:
// 1. Correct field arithmetic
// 2. Correct lexicographic comparison
// 3. Correct X-negation when Y is lex-smallest
// 4. Correct little-endian serialization
const GENERATOR_COMPRESSED: [u8; 32] =
    hex!("4a2c7486fd924882bf02c6908de395122843e3e05264d7991e18e7985dad51e9");

// Test vectors: SRS points (first 10 of 256)
//
// Generated by go-ipa using seed "eth_verkle_oct_2021"
// Algorithm:
//   1. hash = SHA256(seed || counter) where counter is big-endian u64
//   2. x = Fq::from_bytes(hash)  (reduce modulo q)
//   3. x_bytes = x.to_bytes()
//   4. point = BandersnatchPoint::from_bytes(x_bytes)  (with subgroup check)
//   5. if error, increment counter and retry
const SRS_VECTORS: [[u8; 32]; 10] = [
    hex!("01587ad1336675eb912550ec2a28eb8923b824b490dd2ba82e48f14590a298a0"), // Point 0
    hex!("6c6e607df0723edfff382fa914bfc38136f3300ab2e06fb97007b559fd323b82"), // Point 1
    hex!("326be3bebfd97ed9d0d4ca1b8bc47e036a24b129f1488110b71c2cae1463db8f"), // Point 2
    hex!("6bd241cc12dc9b2c0ad6fc85e016605c49c1a92939c7faeea0a555d2a1c3ddf8"), // Point 3
    hex!("00d4bb940478cca48a5b822533d2b3215857ae7c6643c5954c96a0084ebffb2c"), // Point 4
    hex!("1c817b76e1c869c4a74f9ce5b8bc04dc810dae7a61ee05616a29eca128e60d3b"), // Point 5
    hex!("03ef64cbed1a63b043942bd0b114537227a116ffadd92a47749460b8facc7af9"), // Point 6
    hex!("1436bda962957699c4d084acd6964db917c46b6c9a42465f9f656c58def17e84"), // Point 7
    hex!("02fccde8e9b11a8d34bc1cddb50aca2d9158d8d3a8ced807020f934931ac6095"), // Point 8
    hex!("45097b0216b48412d811c2c0e7c5f58aba24abdda30b6aa54eae160e10943df0"), // Point 9
];

// Test vector: hash_to_bytes(generator)
//
// Algorithm: LE_bytes(X / Y mod q)
// Source: go-verkle/ipa.go:HashPointToBytes and banderwagon/element.go:MapToScalarField
// Generated by: test_vectors/generate_verkle_vectors.go
const GENERATOR_HASH: [u8; 32] =
    hex!("d1e7de2aaea9603d5bc6c208d319596376556ecd8336671ba7670c2139772d14");

#[test]
fn test_generator_compression() {
    let generator = BandersnatchPoint::generator();
    let compressed = generator.to_bytes();

    assert_eq!(
        compressed,
        GENERATOR_COMPRESSED,
        "Generator compression mismatch.\n\
         Expected: {}\n\
         Got:      {}",
        hex::encode(GENERATOR_COMPRESSED),
        hex::encode(compressed)
    );
}

#[test]
fn test_generator_roundtrip() {
    let generator = BandersnatchPoint::generator();
    let compressed = generator.to_bytes();
    let decompressed = BandersnatchPoint::from_bytes(&compressed)
        .expect("Failed to decompress generator");

    // Points must be equivalent in quotient group (may be (X,Y) or (-X,-Y))
    assert!(
        generator.equivalent(&decompressed),
        "Generator round-trip failed"
    );
}

#[test]
fn test_srs_generation_first_10() {
    let srs = generate_srs_points(10);

    for (i, expected) in SRS_VECTORS.iter().enumerate() {
        let actual = srs[i].to_bytes();
        assert_eq!(
            actual,
            *expected,
            "SRS point {} mismatch.\n\
             Expected: {}\n\
             Got:      {}",
            i,
            hex::encode(expected),
            hex::encode(actual)
        );
    }
}

#[test]
fn test_srs_generation_full_256() {
    let srs = generate_srs_points(256);

    assert_eq!(srs.len(), 256, "SRS must have exactly 256 points");

    // All points must be non-identity
    for (i, point) in srs.iter().enumerate() {
        assert!(
            !point.is_identity(),
            "SRS point {} is identity",
            i
        );
    }

    // First 10 must match test vectors
    for (i, expected) in SRS_VECTORS.iter().enumerate() {
        assert_eq!(
            srs[i].to_bytes(),
            *expected,
            "SRS point {} mismatch in full generation",
            i
        );
    }
}

#[test]
fn test_hash_to_bytes_generator() {
    let generator = BandersnatchPoint::generator();
    let hash = hash_point_to_bytes(&generator);

    assert_eq!(
        hash,
        GENERATOR_HASH,
        "hash_to_bytes(generator) mismatch.\n\
         Expected: {}\n\
         Got:      {}",
        hex::encode(GENERATOR_HASH),
        hex::encode(hash)
    );
}

#[test]
fn test_hash_to_bytes_deterministic() {
    let generator = BandersnatchPoint::generator();
    let hash1 = hash_point_to_bytes(&generator);
    let hash2 = hash_point_to_bytes(&generator);

    assert_eq!(hash1, hash2, "hash_to_bytes must be deterministic");
}

#[test]
fn test_hash_to_bytes_non_zero() {
    let generator = BandersnatchPoint::generator();
    let hash = hash_point_to_bytes(&generator);

    assert_ne!(hash, [0u8; 32], "hash_to_bytes must not return all zeros");
}

#[test]
#[should_panic(expected = "identity not allowed")]
fn test_hash_identity_panics() {
    let identity = BandersnatchPoint::identity();
    let hash = hash_point_to_bytes(&identity);
    assert_eq!(
        hash,
        [0u8; 32],
        "hash_to_bytes(identity) should map to zero (go-ipa behavior)"
    );
}

#[test]
fn test_ipa_proof_serialization() {
    // Create sample proof with 8 rounds (for VectorLength=256)
    let proof = IPAProof {
        l: vec![BandersnatchPoint::generator(); 8],
        r: vec![BandersnatchPoint::generator(); 8],
        a: Fr::one(),
    };

    // Serialize
    let bytes = proof.serialize();
    assert_eq!(bytes.len(), 544, "IPA proof must be 544 bytes (8*32 + 8*32 + 32)");

    // Deserialize
    let decoded = IPAProof::deserialize(&bytes)
        .expect("Failed to deserialize IPA proof");

    assert_eq!(decoded.l.len(), 8);
    assert_eq!(decoded.r.len(), 8);
}

// Test that compression/decompression preserves point equivalence
#[test]
fn test_compression_preserves_equivalence() {
    // Generate some test points
    let srs = generate_srs_points(5);

    for (i, point) in srs.iter().enumerate() {
        let compressed = point.to_bytes();
        let decompressed = BandersnatchPoint::from_bytes(&compressed)
            .expect(&format!("Failed to decompress point {}", i));

        assert!(
            point.equivalent(&decompressed),
            "Point {} not equivalent after round-trip",
            i
        );
    }
}

// Test that invalid compressed points are rejected
#[test]
fn test_invalid_compression_rejected() {
    // All zeros decode to the identity in go-ipa; accept and check equivalence
    let zero_bytes = [0u8; 32];
    let zero_point = BandersnatchPoint::from_bytes(&zero_bytes)
        .expect("all-zero compressed point should decode to identity");
    assert!(
        zero_point.equivalent(&BandersnatchPoint::identity()),
        "all-zero compressed point should be the identity"
    );

    // All ones (unlikely to be on curve)
    let invalid2 = [0xffu8; 32];
    assert!(BandersnatchPoint::from_bytes(&invalid2).is_err());

    // Random garbage
    let invalid3 = [0x42u8; 32];
    let _ = BandersnatchPoint::from_bytes(&invalid3);
    // May succeed if happens to be on curve, but most random values should fail
}
