#![allow(dead_code)]

/// End-to-end work package validation test
///
/// This test reads a work package JSON file generated by the Rust orchard-builder
/// and validates serialization/deserialization plus pre/post state witnesses:
///
/// 1. Parse JSON work package file
/// 2. Serialize extrinsics (bundle bytes + nullifier proofs) in JAM format
/// 3. Deserialize extrinsics back
/// 4. Verify round-trip consistency
/// 5. Verify pre-state witnesses (nullifier absence + optional spent commitments)
/// 6. Verify post-state witnesses (new commitments + new nullifiers)
/// 7. Verify Orchard proof + signatures when built with `--features orchard`

use std::fs;
use std::path::PathBuf;
use orchard_service::crypto::merkle_root_from_path;
use orchard_service::state::{OrchardExtrinsic, MerkleProof};
use orchard_service::errors::{OrchardError, Result};
use blake2::Blake2bVar;
use blake2::digest::{Update, VariableOutput};
use std::time::Instant;
#[cfg(all(feature = "orchard", feature = "std"))]
use orchard_service::bundle_codec::decode_bundle;
#[cfg(all(feature = "orchard", feature = "std"))]
use orchard::bundle::BatchValidator;
#[cfg(all(feature = "orchard", feature = "std"))]
use rand::rngs::OsRng;

/// JSON structure matching the Rust orchard-builder output
#[derive(Debug)]
struct WorkPackageFile {
    pre_state_roots: StateRoots,
    post_state_roots: StateRoots,
    pre_state_witnesses: PreStateWitnesses,
    post_state_witnesses: PostStateWitnesses,
    user_bundles: Vec<UserBundle>,
    metadata: Metadata,
}

#[derive(Debug, serde::Deserialize)]
struct WorkPackageFileRaw {
    #[serde(default)]
    pre_state_roots: Option<StateRoots>,
    #[serde(default)]
    post_state_roots: Option<StateRoots>,
    #[serde(default)]
    pre_state_witnesses: Option<PreStateWitnesses>,
    #[serde(default)]
    post_state_witnesses: Option<PostStateWitnesses>,
    #[serde(default)]
    user_bundles: Vec<UserBundle>,
    #[serde(default)]
    metadata: Option<Metadata>,

    // Current builder format fields.
    #[serde(default)]
    pre_state: Option<StateRoots>,
    #[serde(default)]
    post_state: Option<StateRoots>,
    #[serde(default)]
    witnesses: Option<PreStateWitnesses>,
    #[serde(default)]
    spent_commitment_proofs: Vec<SpentCommitmentProofJson>,
    #[serde(default)]
    bundle_bytes: Option<serde_bytes::ByteBuf>,
    #[serde(default)]
    gas_limit: Option<u64>,
}

#[derive(Debug, serde::Deserialize)]
struct StateRoots {
    commitment_root: [u8; 32],
    commitment_size: u64,
    nullifier_root: [u8; 32],
    #[serde(default)]
    nullifier_size: Option<u64>,
}

#[derive(Debug, serde::Deserialize, Default)]
struct PreStateWitnesses {
    #[serde(default)]
    spent_note_commitment_proofs: Vec<MerkleProofJson>,
    #[serde(default)]
    nullifier_absence_proofs: Vec<MerkleProofJson>,
}

#[derive(Debug, serde::Deserialize, Clone)]
struct MerkleProofJson {
    leaf: [u8; 32],
    siblings: Vec<[u8; 32]>,
    root: [u8; 32],
    position: u64,
}

#[derive(Debug, serde::Deserialize, Default)]
struct PostStateWitnesses {
    #[serde(default)]
    new_commitment_proofs: Vec<MerkleProofJson>,
    #[serde(default)]
    new_nullifier_proofs: Vec<MerkleProofJson>,
}

#[derive(Debug, serde::Deserialize, Clone)]
struct SpentCommitmentProofJson {
    nullifier: [u8; 32],
    commitment: [u8; 32],
    tree_position: u64,
    branch_siblings: Vec<[u8; 32]>,
}

#[derive(Debug, serde::Deserialize)]
struct UserBundle {
    actions: Vec<OrchardAction>,
    bundle_bytes: Vec<u8>,
}

#[derive(Debug, serde::Deserialize, Clone)]
struct OrchardAction {
    commitment: [u8; 32],
    nullifier: [u8; 32],
    #[serde(default)]
    nullifier_absence_index: Option<u64>,
    #[serde(default)]
    spent_commitment_index: Option<u64>,
}

#[derive(Debug, serde::Deserialize, Default)]
struct Metadata {
    gas_limit: u64,
}

impl From<&MerkleProofJson> for MerkleProof {
    fn from(proof: &MerkleProofJson) -> Self {
        MerkleProof {
            leaf: proof.leaf,
            path: proof.siblings.clone(),
            root: proof.root,
        }
    }
}

/// Load work package from JSON file
fn load_work_package(path: &str) -> Result<WorkPackageFile> {
    let json_data = fs::read_to_string(path)
        .map_err(|e| OrchardError::ParseError(format!("Failed to read file: {}", e)))?;

    let mut raw: WorkPackageFileRaw = serde_json::from_str(&json_data)
        .map_err(|e| OrchardError::ParseError(format!("Failed to parse JSON: {}", e)))?;

    let pre_state_roots = raw.pre_state_roots.take()
        .or(raw.pre_state.take())
        .ok_or_else(|| OrchardError::ParseError("Missing pre_state_roots/pre_state".into()))?;
    let post_state_roots = raw.post_state_roots.take()
        .or(raw.post_state.take())
        .ok_or_else(|| OrchardError::ParseError("Missing post_state_roots/post_state".into()))?;

    let mut pre_state_witnesses = raw.pre_state_witnesses.take()
        .or(raw.witnesses.take())
        .unwrap_or_default();
    if pre_state_witnesses.spent_note_commitment_proofs.is_empty()
        && !raw.spent_commitment_proofs.is_empty()
    {
        for proof in raw.spent_commitment_proofs.into_iter() {
            pre_state_witnesses
                .spent_note_commitment_proofs
                .push(convert_spent_commitment_proof(&proof)?);
        }
    }

    let post_state_witnesses = raw.post_state_witnesses.unwrap_or_default();

    let mut user_bundles = raw.user_bundles;
    if user_bundles.is_empty() {
        if let Some(bundle_bytes) = raw.bundle_bytes.take() {
            user_bundles.push(UserBundle {
                actions: Vec::new(),
                bundle_bytes: bundle_bytes.into_vec(),
            });
        }
    }

    let metadata = raw.metadata.unwrap_or_else(|| Metadata {
        gas_limit: raw.gas_limit.unwrap_or(0),
    });

    Ok(WorkPackageFile {
        pre_state_roots,
        post_state_roots,
        pre_state_witnesses,
        post_state_witnesses,
        user_bundles,
        metadata,
    })
}

fn convert_spent_commitment_proof(proof: &SpentCommitmentProofJson) -> Result<MerkleProofJson> {
    let path_indices = path_indices_from_position(proof.tree_position, proof.branch_siblings.len());
    let root = merkle_root_from_path(&proof.commitment, &path_indices, &proof.branch_siblings)?;
    Ok(MerkleProofJson {
        leaf: proof.commitment,
        siblings: proof.branch_siblings.clone(),
        root,
        position: proof.tree_position,
    })
}

fn log_timing(label: &str, start: Instant) {
    let elapsed = start.elapsed();
    println!("‚è± {}: {} ms", label, elapsed.as_millis());
}

#[cfg(all(feature = "orchard", feature = "std"))]
fn load_vk_from_disk() -> Option<orchard::circuit::VerifyingKey> {
    use std::fs::File;
    use std::io::BufReader;
    use pasta_curves::vesta::Affine as VestaAffine;
    use halo2_proofs::poly::commitment::Params;

    let keys_dir = std::env::var("ORCHARD_KEYS_DIR").ok()
        .map(std::path::PathBuf::from)
        .unwrap_or_else(|| {
            std::path::PathBuf::from(env!("CARGO_MANIFEST_DIR"))
                .join("../../keys/orchard")
        });
    let params_path = keys_dir.join("orchard.params");
    let vk_path = keys_dir.join("orchard.vk");

    let params_file = File::open(params_path).ok()?;
    let params = Params::<VestaAffine>::read(&mut BufReader::new(params_file)).ok()?;
    let vk_file = File::open(vk_path).ok()?;
    orchard::circuit::VerifyingKey::read(params, BufReader::new(vk_file)).ok()
}

#[cfg(all(feature = "orchard", feature = "std"))]
fn cached_vk() -> &'static orchard::circuit::VerifyingKey {
    use std::sync::OnceLock;

    static VK: OnceLock<orchard::circuit::VerifyingKey> = OnceLock::new();
    VK.get_or_init(|| {
        load_vk_from_disk()
            .unwrap_or_else(orchard::circuit::VerifyingKey::build)
    })
}

/// Serialize bundle and proofs into Orchard extrinsic format
fn serialize_orchard_extrinsic(
    bundle_bytes: &[u8],
    nullifier_proofs: &[MerkleProofJson],
) -> Vec<u8> {
    const TAG_BUNDLE_SUBMIT: u8 = 0;

    let mut out = Vec::new();

    // Tag byte
    out.push(TAG_BUNDLE_SUBMIT);

    // Bundle length (4-byte LE)
    let bundle_len = bundle_bytes.len() as u32;
    out.extend_from_slice(&bundle_len.to_le_bytes());

    // Bundle bytes
    out.extend_from_slice(bundle_bytes);

    // Number of proofs (4-byte LE)
    let num_proofs = nullifier_proofs.len() as u32;
    out.extend_from_slice(&num_proofs.to_le_bytes());

    // Serialize each proof
    for proof in nullifier_proofs {
        // Leaf (32 bytes)
        out.extend_from_slice(&proof.leaf);

        // Path length (4-byte LE)
        let path_len = proof.siblings.len() as u32;
        out.extend_from_slice(&path_len.to_le_bytes());

        // Path nodes
        for node in &proof.siblings {
            out.extend_from_slice(node);
        }

        // Root (32 bytes)
        out.extend_from_slice(&proof.root);
    }

    out
}

/// Verify nullifier absence proof structure (not cryptographic verification)
fn check_nullifier_absence_proof_structure(
    proofs: &[MerkleProofJson],
    expected_root: &[u8; 32],
) -> Result<()> {
    for (i, proof) in proofs.iter().enumerate() {
        // Check root matches expected
        if &proof.root != expected_root {
            return Err(OrchardError::ParseError(
                format!("Proof {} root mismatch: expected {:?}, got {:?}",
                    i, &expected_root[..8], &proof.root[..8])
            ));
        }

        // Check path is non-empty (reasonable tree depth)
        if proof.siblings.is_empty() {
            return Err(OrchardError::ParseError(
                format!("Proof {} has empty path", i)
            ));
        }
    }

    println!("‚úÖ All {} nullifier absence proof structures validated", proofs.len());
    Ok(())
}

/// Test extrinsic serialization/deserialization round-trip
fn test_extrinsic_roundtrip(
    bundle_bytes: &[u8],
    nullifier_proofs: &[MerkleProofJson],
) -> Result<()> {
    println!("üîÑ Testing extrinsic serialization round-trip...");

    // Serialize
    let extrinsic_bytes = serialize_orchard_extrinsic(bundle_bytes, nullifier_proofs);
    println!("  ‚îú‚îÄ Serialized extrinsic: {} bytes", extrinsic_bytes.len());
    println!("  ‚îÇ  ‚îú‚îÄ Bundle: {} bytes", bundle_bytes.len());
    println!("  ‚îÇ  ‚îî‚îÄ Proofs: {}", nullifier_proofs.len());

    // Deserialize
    let extrinsic = OrchardExtrinsic::deserialize(&extrinsic_bytes)
        .map_err(|e| OrchardError::ParseError(format!("Deserialize failed: {:?}", e)))?;

    match extrinsic {
        OrchardExtrinsic::BundleSubmit {
            bundle_bytes: deserialized_bundle,
            nullifier_absence_proofs: deserialized_proofs,
        } => {
            // Verify bundle bytes match
            if deserialized_bundle != bundle_bytes {
                return Err(OrchardError::ParseError(
                    "Bundle bytes mismatch after round-trip".into()
                ));
            }

            // Verify proof count matches
            if deserialized_proofs.len() != nullifier_proofs.len() {
                return Err(OrchardError::ParseError(
                    format!("Proof count mismatch: {} vs {}",
                        deserialized_proofs.len(), nullifier_proofs.len())
                ));
            }

            // Verify each proof matches
            for (i, (orig, deser)) in nullifier_proofs.iter().zip(deserialized_proofs.iter()).enumerate() {
                if orig.leaf != deser.leaf {
                    return Err(OrchardError::ParseError(format!("Proof {} leaf mismatch", i)));
                }
                if orig.root != deser.root {
                    return Err(OrchardError::ParseError(format!("Proof {} root mismatch", i)));
                }
                if orig.siblings.len() != deser.path.len() {
                    return Err(OrchardError::ParseError(format!("Proof {} path length mismatch", i)));
                }
                for (j, (o, d)) in orig.siblings.iter().zip(deser.path.iter()).enumerate() {
                    if o != d {
                        return Err(OrchardError::ParseError(
                            format!("Proof {} path node {} mismatch", i, j)
                        ));
                    }
                }
            }

            println!("  ‚îî‚îÄ ‚úÖ Round-trip successful - all fields match");
            Ok(())
        }
        other => Err(OrchardError::ParseError(format!(
            "Unexpected extrinsic variant: {:?}",
            other
        ))),
    }
}

fn blake2b_256(input: &[u8]) -> [u8; 32] {
    let mut out = [0u8; 32];
    let mut hasher = Blake2bVar::new(32)
        .expect("blake2b output length should be valid");
    hasher.update(input);
    hasher.finalize_variable(&mut out)
        .expect("blake2b finalize should not fail");
    out
}

fn sparse_hash_leaf(value: &[u8; 32]) -> [u8; 32] {
    let mut input = [0u8; 33];
    input[0] = 0x00;
    input[1..].copy_from_slice(value);
    blake2b_256(&input)
}

fn sparse_hash_node(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    let mut input = [0u8; 65];
    input[0] = 0x01;
    input[1..33].copy_from_slice(left);
    input[33..].copy_from_slice(right);
    blake2b_256(&input)
}

fn sparse_empty_leaf() -> [u8; 32] {
    sparse_hash_leaf(&[0u8; 32])
}

fn sparse_position_for(value: [u8; 32], depth: usize) -> u64 {
    let mut prefix = [0u8; 8];
    prefix.copy_from_slice(&value[..8]);
    let mut position = u64::from_le_bytes(prefix);
    if depth < 64 {
        position &= (1u64 << depth) - 1;
    }
    position
}

fn compute_sparse_root(proof: &MerkleProofJson) -> [u8; 32] {
    let mut current = proof.leaf;
    let mut pos = proof.position;
    for sibling in &proof.siblings {
        let (left, right) = if pos & 1 == 0 {
            (current, *sibling)
        } else {
            (*sibling, current)
        };
        current = sparse_hash_node(&left, &right);
        pos >>= 1;
    }
    current
}

fn path_indices_from_position(position: u64, depth: usize) -> Vec<bool> {
    let mut indices = Vec::with_capacity(depth);
    for level in 0..depth {
        indices.push(((position >> level) & 1) == 1);
    }
    indices
}

fn verify_commitment_proof(
    proof: &MerkleProofJson,
    expected_root: &[u8; 32],
) -> Result<()> {
    let path_indices = path_indices_from_position(proof.position, proof.siblings.len());
    let computed = merkle_root_from_path(&proof.leaf, &path_indices, &proof.siblings)?;
    if &computed != expected_root || &proof.root != expected_root {
        return Err(OrchardError::ParseError(
            "Commitment proof root mismatch".into(),
        ));
    }
    Ok(())
}

fn verify_sparse_proof(
    proof: &MerkleProofJson,
    expected_root: &[u8; 32],
) -> Result<()> {
    let computed = compute_sparse_root(proof);
    if &computed != expected_root || &proof.root != expected_root {
        return Err(OrchardError::ParseError(
            "Sparse proof root mismatch".into(),
        ));
    }
    Ok(())
}

/// Verify commitment tree state transition structure
fn check_commitment_tree_structure(wp: &WorkPackageFile) -> Result<()> {
    println!("üå≥ Checking commitment tree state transition structure...");

    let pre_nullifier_size = wp.pre_state_roots.nullifier_size.unwrap_or(0);
    let post_nullifier_size = wp.post_state_roots.nullifier_size.unwrap_or(0);

    println!("  ‚îú‚îÄ Pre-state:");
    println!("  ‚îÇ  ‚îú‚îÄ Commitment root: {:?}", &wp.pre_state_roots.commitment_root[..8]);
    println!("  ‚îÇ  ‚îú‚îÄ Commitment size: {}", wp.pre_state_roots.commitment_size);
    println!("  ‚îÇ  ‚îú‚îÄ Nullifier root: {:?}", &wp.pre_state_roots.nullifier_root[..8]);
    println!("  ‚îÇ  ‚îî‚îÄ Nullifier size: {}", pre_nullifier_size);

    println!("  ‚îî‚îÄ Post-state:");
    println!("     ‚îú‚îÄ Commitment root: {:?}", &wp.post_state_roots.commitment_root[..8]);
    println!("     ‚îú‚îÄ Commitment size: {} (+{})",
        wp.post_state_roots.commitment_size,
        wp.post_state_roots.commitment_size - wp.pre_state_roots.commitment_size);
    println!("     ‚îú‚îÄ Nullifier root: {:?}", &wp.post_state_roots.nullifier_root[..8]);
    println!("     ‚îî‚îÄ Nullifier size: {} (+{})",
        post_nullifier_size,
        post_nullifier_size - pre_nullifier_size
    );

    // Basic sanity checks
    if wp.post_state_roots.commitment_size < wp.pre_state_roots.commitment_size {
        return Err(OrchardError::ParseError(
            "Post-state commitment size cannot decrease".into()
        ));
    }

    if post_nullifier_size < pre_nullifier_size {
        return Err(OrchardError::ParseError(
            "Post-state nullifier size cannot decrease".into()
        ));
    }

    println!("‚úÖ State transition structure valid");
    Ok(())
}

fn collect_actions(bundles: &[UserBundle]) -> Vec<OrchardAction> {
    let mut actions = Vec::new();
    for bundle in bundles {
        actions.extend(bundle.actions.iter().cloned());
    }
    actions
}

#[test]
fn test_work_package_validation() {
    let overall_start = Instant::now();
    println!("\n{}", "=".repeat(80));
    println!("üß™ WORK PACKAGE VALIDATION TEST (Serialization & Structure)");
    println!("{}\n", "=".repeat(80));

    // Find work package file
    let work_package_path = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .join("../../work_packages/package_000.json");

    if !work_package_path.exists() {
        println!("‚ö†Ô∏è  Work package not found at {:?}", work_package_path);
        println!("   Generate it with:");
        println!("   cargo run --manifest-path builder/orchard/Cargo.toml --bin orchard-builder -- sequence --count 1");
        panic!("Work package file not found");
    }

    println!("üì¶ Loading work package: {:?}\n", work_package_path);

    // Load work package
    let load_start = Instant::now();
    let wp = load_work_package(work_package_path.to_str().unwrap())
        .expect("Failed to load work package");
    log_timing("Load work package", load_start);

    println!("üìä Work Package Summary:");
    println!("  ‚îú‚îÄ User bundles: {}", wp.user_bundles.len());
    println!("  ‚îú‚îÄ Gas limit: {}", wp.metadata.gas_limit);
    println!("  ‚îú‚îÄ Nullifier proofs: {}", wp.pre_state_witnesses.nullifier_absence_proofs.len());
    println!("  ‚îî‚îÄ Pre-state commitment size: {}\n", wp.pre_state_roots.commitment_size);

    let actions = collect_actions(&wp.user_bundles);
    let actions_available = !actions.is_empty();

    // Check overall state transition structure
    let state_start = Instant::now();
    check_commitment_tree_structure(&wp)
        .expect("Commitment tree structure check failed");
    log_timing("State transition structure", state_start);

    let orchard_enabled = cfg!(all(feature = "orchard", feature = "std"));
    if !orchard_enabled
        && (!wp.pre_state_witnesses.spent_note_commitment_proofs.is_empty()
            || !wp.post_state_witnesses.new_commitment_proofs.is_empty())
    {
        println!("‚ö† Commitment proof verification skipped (enable --features orchard)");
    }

    // Pre-state witness verification
    let pre_start = Instant::now();
    if orchard_enabled {
        for proof in &wp.pre_state_witnesses.spent_note_commitment_proofs {
            if proof.root != wp.pre_state_roots.commitment_root {
                panic!("Spent commitment proof root mismatch");
            }
            verify_commitment_proof(proof, &wp.pre_state_roots.commitment_root)
                .expect("Spent commitment proof invalid");
        }
    } else if !wp.pre_state_witnesses.spent_note_commitment_proofs.is_empty() {
        println!("‚ö† Spent commitment proofs skipped (enable --features orchard)");
    }

    if actions_available
        && wp.pre_state_witnesses.nullifier_absence_proofs.len() != actions.len()
    {
        panic!("Nullifier absence proof count mismatch");
    }

    if actions_available {
        for (idx, action) in actions.iter().enumerate() {
            let proof_index = action
                .nullifier_absence_index
                .map(|v| v as usize)
                .unwrap_or(idx);
            let proof = wp.pre_state_witnesses
                .nullifier_absence_proofs
                .get(proof_index)
                .unwrap_or_else(|| panic!("Missing nullifier absence proof {}", proof_index));

            let expected_position = sparse_position_for(action.nullifier, proof.siblings.len());
            if proof.position != expected_position {
                panic!("Nullifier absence proof position mismatch");
            }
            if proof.leaf != sparse_empty_leaf() {
                panic!("Nullifier absence proof leaf mismatch");
            }
            verify_sparse_proof(proof, &wp.pre_state_roots.nullifier_root)
                .expect("Nullifier absence proof invalid");
        }
    } else if !wp.pre_state_witnesses.nullifier_absence_proofs.is_empty() {
        println!("‚ö† No actions in work package; validating nullifier absence proofs without action binding");
        for proof in &wp.pre_state_witnesses.nullifier_absence_proofs {
            if proof.leaf != sparse_empty_leaf() {
                panic!("Nullifier absence proof leaf mismatch");
            }
            verify_sparse_proof(proof, &wp.pre_state_roots.nullifier_root)
                .expect("Nullifier absence proof invalid");
        }
        _ => {
            return Err(OrchardError::ParseError(
                "Unexpected extrinsic variant".into(),
            ));
        }
    }
    log_timing("Pre-state witness verification", pre_start);

    // Post-state witness verification
    let post_start = Instant::now();
    let has_post_proofs = !wp.post_state_witnesses.new_commitment_proofs.is_empty()
        || !wp.post_state_witnesses.new_nullifier_proofs.is_empty();
    if !has_post_proofs {
        println!("‚ö† Post-state witness proofs not provided; skipping post-state proof checks");
    } else if actions_available {
        if wp.post_state_witnesses.new_commitment_proofs.len() != actions.len() {
            panic!("New commitment proof count mismatch");
        }
        if wp.post_state_witnesses.new_nullifier_proofs.len() != actions.len() {
            panic!("New nullifier proof count mismatch");
        }

        for (idx, action) in actions.iter().enumerate() {
            let commitment_proof = &wp.post_state_witnesses.new_commitment_proofs[idx];
            let expected_position = wp.pre_state_roots.commitment_size + idx as u64;
            if commitment_proof.position != expected_position {
                panic!("Commitment proof position mismatch");
            }
            if commitment_proof.leaf != action.commitment {
                panic!("Commitment proof leaf mismatch");
            }
            if orchard_enabled {
                verify_commitment_proof(commitment_proof, &wp.post_state_roots.commitment_root)
                    .expect("Commitment proof invalid");
            }

            let nullifier_proof = &wp.post_state_witnesses.new_nullifier_proofs[idx];
            let expected_position = sparse_position_for(action.nullifier, nullifier_proof.siblings.len());
            if nullifier_proof.position != expected_position {
                panic!("New nullifier proof position mismatch");
            }
            if nullifier_proof.leaf != sparse_hash_leaf(&action.nullifier) {
                panic!("New nullifier proof leaf mismatch");
            }
            verify_sparse_proof(nullifier_proof, &wp.post_state_roots.nullifier_root)
                .expect("New nullifier proof invalid");
        }
    } else {
        println!("‚ö† No actions in work package; validating post-state proofs without action binding");
        for commitment_proof in &wp.post_state_witnesses.new_commitment_proofs {
            if orchard_enabled {
                verify_commitment_proof(commitment_proof, &wp.post_state_roots.commitment_root)
                    .expect("Commitment proof invalid");
            }
        }
        for nullifier_proof in &wp.post_state_witnesses.new_nullifier_proofs {
            verify_sparse_proof(nullifier_proof, &wp.post_state_roots.nullifier_root)
                .expect("New nullifier proof invalid");
        }
    }
    log_timing("Post-state witness verification", post_start);

    #[cfg(all(feature = "orchard", feature = "std"))]
    let mut batch = BatchValidator::new();

    // Process each bundle
    for (i, bundle) in wp.user_bundles.iter().enumerate() {
        println!("\n{}", "‚îÄ".repeat(80));
        println!("üì¶ Bundle {} Validation", i);
        println!("{}\n", "‚îÄ".repeat(80));

        let bundle_bytes = &bundle.bundle_bytes;
        let nullifier_proofs = &wp.pre_state_witnesses.nullifier_absence_proofs;

        // Check bundle is non-empty
        if bundle_bytes.is_empty() {
            panic!("Bundle {} has empty bundle_bytes", i);
        }
        println!("‚úÖ Bundle bytes present: {} bytes", bundle_bytes.len());

        // Step 1: Test extrinsic serialization round-trip
        let roundtrip_start = Instant::now();
        test_extrinsic_roundtrip(bundle_bytes, nullifier_proofs)
            .expect("Extrinsic round-trip failed");
        log_timing("Extrinsic round-trip", roundtrip_start);

        // Step 2: Check nullifier absence proof structure
        let structure_start = Instant::now();
        check_nullifier_absence_proof_structure(nullifier_proofs, &wp.pre_state_roots.nullifier_root)
            .expect("Nullifier absence proof structure check failed");
        log_timing("Nullifier proof structure", structure_start);

        // Step 3: Add bundle to batch verifier (requires --features orchard)
        if orchard_enabled {
            #[cfg(all(feature = "orchard", feature = "std"))]
            {
                let decoded = decode_bundle(bundle_bytes)
                    .expect("Failed to decode bundle for batch verification");
                let bundle = orchard_service::bundle_codec::to_orchard_bundle(&decoded)
                    .expect("Failed to convert bundle for batch verification");
                let sighash: [u8; 32] = bundle.commitment().into();
                batch.add_bundle(&bundle, sighash);
            }
        }
    }

    if orchard_enabled {
        let proof_start = Instant::now();
        #[cfg(all(feature = "orchard", feature = "std"))]
        {
            if batch.validate(cached_vk(), OsRng) {
                println!("‚úÖ Orchard batch proofs + signatures verified");
            } else {
                panic!("Orchard batch proof verification failed");
            }
        }
        log_timing("Orchard batch proof verification", proof_start);
    } else {
        println!("‚ö† Orchard proof verification skipped (enable --features orchard)");
    }

    println!("\n{}", "=".repeat(80));
    println!("‚úÖ ALL VALIDATIONS PASSED");
    println!("   - Extrinsic serialization/deserialization works correctly");
    println!("   - Pre/post state witnesses validated");
    println!("   - Bundle bytes are properly formatted");
    println!("   - State transition structure is consistent");
    if cfg!(all(feature = "orchard", feature = "std")) {
        println!("   - Orchard batch proofs and signatures verified");
    } else {
        println!("   - Orchard proof verification skipped (enable --features orchard)");
    }
    log_timing("Total test time", overall_start);
    println!("{}\n", "=".repeat(80));
}

#[test]
fn test_individual_proof_verification() {
    println!("\nüîç Testing individual Merkle proof verification\n");

    // Create a simple proof for testing
    let leaf = [0u8; 32]; // Zero leaf (nullifier absent)
    let siblings = vec![
        [1u8; 32],
        [2u8; 32],
    ];

    // Compute expected root
    use orchard_service::state::hash_pair;
    let level1 = hash_pair(&leaf, &siblings[0]);
    let root = hash_pair(&level1, &siblings[1]);

    let proof = MerkleProof {
        leaf,
        path: siblings,
        root,
    };

    assert!(proof.verify(), "Proof verification should succeed");
    println!("‚úÖ Individual proof verification passed");
}

#[test]
fn test_extrinsic_deserialization_error_handling() {
    println!("\nüß™ Testing extrinsic deserialization error handling\n");

    // Test empty input
    let result = OrchardExtrinsic::deserialize(&[]);
    assert!(result.is_err(), "Should fail on empty input");
    println!("‚úÖ Empty input handled");

    // Test invalid tag
    let result = OrchardExtrinsic::deserialize(&[255]);
    assert!(result.is_err(), "Should fail on invalid tag");
    println!("‚úÖ Invalid tag handled");

    // Test truncated bundle
    let mut invalid = vec![0u8]; // TAG_BUNDLE_SUBMIT
    invalid.extend_from_slice(&100u32.to_le_bytes()); // bundle_len = 100
    invalid.extend_from_slice(&[0u8; 10]); // Only 10 bytes (truncated)

    let result = OrchardExtrinsic::deserialize(&invalid);
    assert!(result.is_err(), "Should fail on truncated bundle");
    println!("‚úÖ Truncated bundle handled");

    println!("\n‚úÖ All error handling tests passed");
}
