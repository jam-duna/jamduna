<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Conway's Game of Life - 9 Page Variant (Blake2b Hash Chain Init)</title>
  <style>
    body { margin: 0; }
    .container {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    #sidebar {
      margin-right: 20px;
      font-size: 24px;
      font-family: sans-serif;
    }
    canvas { border: 1px solid #ccc; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/js-sha3@0.8.0/build/sha3.min.js"></script>

</head>
<body>
  <div class="container">
    <div id="sidebar">
      <p>Steps: <span id="counter">0</span></p>
    </div>
    <!-- The canvas displays a 192x192 grid scaled by cellSize -->
    <canvas id="gameCanvas"></canvas>
  </div>
  <script>
    // Constants for page and grid dimensions.
    const PAGE_SIZE = 4096;  // Each page is 4,096 bytes.
    const PAGE_DIM = 64;     // Each page is 64×64 cells.
    const PAGES_PER_ROW = 3; // Pages arranged in a 3×3 ghost grid.
    const PAGES_PER_COL = 3;
    const TOTAL_ROWS = PAGE_DIM * PAGES_PER_COL; // 192 rows.
    const TOTAL_COLS = PAGE_DIM * PAGES_PER_ROW;  // 192 cols.
    const cellSize = 4; // Each cell is drawn as a 4×4 square.

    // Set up canvas.
    const canvas = document.getElementById("gameCanvas");
    canvas.width = TOTAL_COLS * cellSize;
    canvas.height = TOTAL_ROWS * cellSize;
    const ctx = canvas.getContext("2d");

    // Global variable to record the most recently poked cell's coordinates.
    let lastPoke = { row: -1, col: -1 };

    // Utility: Convert a Uint8Array to a hex string.
    function toHexString(byteArray) {
      return Array.from(byteArray, byte =>
        ('0' + byte.toString(16)).slice(-2)
      ).join('');
    }

    // The Grid class holds 9 pages (each is a Uint8Array of 4,096 bytes).
    class Grid {
      constructor() {
        this.pages = [];
        for (let i = 0; i < 9; i++) {
          this.pages.push(new Uint8Array(PAGE_SIZE));
        }
      }

	initHashChain() {
	    // Define total bytes and number of hashes.
	    const totalBytes = PAGE_SIZE * 9; // 36,864 bytes
	    const numHashes = totalBytes / 32; // 1,152 hashes
	    // Allocate the hash chain buffer.
	    let hashChainBytes = new Uint8Array(totalBytes);
	    
	    // Start with the empty string (as bytes).
      const encoder = new TextEncoder();
	    let current = encoder.encode("");
	    
	    for (let i = 0; i < numHashes; i++) {
		// Compute a 32-byte Keccak256 hash of the current input.
		 const hashBytes = keccak256.array(current);
		// Place these 32 bytes into our hash chain buffer at the proper offset.
		hashChainBytes.set(hashBytes, i * 32);
		// Update current to be the hash bytes for the next iteration.
		current = hashBytes;
	    }
	    
	    // Convert each byte in the hash chain into 0 or 1 based on its MSB.
	    // If the most significant bit is set (i.e. byte & 0x80 != 0), then set to 1; otherwise 0.
	    for (let i = 0; i < hashChainBytes.length; i++) {
		hashChainBytes[i] = (hashChainBytes[i] & 0x80) ? 1 : 0;
	    }
	    
	    // Distribute the 36,864-byte chain evenly among the 9 pages.
	    for (let i = 0; i < 9; i++) {
		const start = i * PAGE_SIZE;
		this.pages[i].set(hashChainBytes.slice(start, start + PAGE_SIZE));
	    }
	}
	
	// Compute one simulation step and return a new Grid.
	step() {
            // Create a 2D buffer with a one-cell ghost border.
        const rowsWithGhost = TOTAL_ROWS + 2;
        const colsWithGhost = TOTAL_COLS + 2;
        const inBuf = [];
        for (let i = 0; i < rowsWithGhost; i++) {
          inBuf.push(new Array(colsWithGhost).fill(0));
        }
        // Copy grid data (from all 9 pages) into inBuf (offset by 1).
        for (let page = 0; page < 9; page++) {
          const pageRow = Math.floor(page / PAGES_PER_ROW);
          const pageCol = page % PAGES_PER_ROW;
          for (let i = 0; i < PAGE_DIM; i++) {
            for (let j = 0; j < PAGE_DIM; j++) {
              const globalRow = pageRow * PAGE_DIM + i;
              const globalCol = pageCol * PAGE_DIM + j;
              inBuf[globalRow + 1][globalCol + 1] = this.pages[page][i * PAGE_DIM + j];
            }
          }
        }
        // Fill ghost borders by wrapping.
        for (let j = 1; j <= TOTAL_COLS; j++) {
          inBuf[0][j] = inBuf[TOTAL_ROWS][j];
          inBuf[TOTAL_ROWS + 1][j] = inBuf[1][j];
        }
        for (let i = 1; i <= TOTAL_ROWS; i++) {
          inBuf[i][0] = inBuf[i][TOTAL_COLS];
          inBuf[i][TOTAL_COLS + 1] = inBuf[i][1];
        }
        inBuf[0][0] = inBuf[TOTAL_ROWS][TOTAL_COLS];
        inBuf[0][TOTAL_COLS + 1] = inBuf[TOTAL_ROWS][1];
        inBuf[TOTAL_ROWS + 1][0] = inBuf[1][TOTAL_COLS];
        inBuf[TOTAL_ROWS + 1][TOTAL_COLS + 1] = inBuf[1][1];

        // Create an output buffer for the new state.
        const outBuf = [];
        for (let i = 0; i < TOTAL_ROWS; i++) {
          outBuf.push(new Array(TOTAL_COLS).fill(0));
        }
        // Compute the next generation using Conway's rules.
        for (let i = 1; i <= TOTAL_ROWS; i++) {
          for (let j = 1; j <= TOTAL_COLS; j++) {
            const liveNeighbors =
              inBuf[i - 1][j - 1] + inBuf[i - 1][j] + inBuf[i - 1][j + 1] +
              inBuf[i][j - 1] +                     inBuf[i][j + 1] +
              inBuf[i + 1][j - 1] + inBuf[i + 1][j] + inBuf[i + 1][j + 1];
            const current = inBuf[i][j];
            outBuf[i - 1][j - 1] = ((current === 1 && (liveNeighbors === 2 || liveNeighbors === 3))
                                   || (current === 0 && liveNeighbors === 3)) ? 1 : 0;
          }
        }
        // Pack the new state into 9 pages.
        const newPages = [];
        for (let p = 0; p < 9; p++) {
          newPages.push(new Uint8Array(PAGE_SIZE));
        }
        for (let page = 0; page < 9; page++) {
          const pageRow = Math.floor(page / PAGES_PER_ROW);
          const pageCol = page % PAGES_PER_ROW;
          for (let i = 0; i < PAGE_DIM; i++) {
            for (let j = 0; j < PAGE_DIM; j++) {
              const globalRow = pageRow * PAGE_DIM + i;
              const globalCol = pageCol * PAGE_DIM + j;
              newPages[page][i * PAGE_DIM + j] = outBuf[globalRow][globalCol];
            }
          }
        }
        const newGrid = new Grid();
        newGrid.pages = newPages;
        return newGrid;
      }
    }

    // Create and initialize the grid using our Blake2b hash chain.
    let grid = new Grid();
    grid.initHashChain();

    // Step counter.
    let steps = 0;
    const counterElement = document.getElementById("counter");

    // Draw the grid on the canvas.
    // The last poked cell is drawn in red; all other live cells are drawn in black.
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let page = 0; page < 9; page++) {
        const pageRow = Math.floor(page / PAGES_PER_ROW);
        const pageCol = page % PAGES_PER_ROW;
        for (let i = 0; i < PAGE_DIM; i++) {
          for (let j = 0; j < PAGE_DIM; j++) {
            const globalRow = pageRow * PAGE_DIM + i;
            const globalCol = pageCol * PAGE_DIM + j;
            let fillColor;
            if (globalRow === lastPoke.row && globalCol === lastPoke.col) {
              fillColor = "red";
            } else {
              fillColor = grid.pages[page][i * PAGE_DIM + j] === 1 ? "black" : "white";
            }
            ctx.fillStyle = fillColor;
            ctx.fillRect(globalCol * cellSize, globalRow * cellSize, cellSize, cellSize);
          }
        }
      }
    }

    // Auto-advance the simulation every 250ms.
    setInterval(() => {
      grid = grid.step();
      steps++;
      counterElement.textContent = steps;

      // Determine which cell to "poke" (set to 1) based on the step number.
      const pokeIndex = steps % (TOTAL_ROWS * TOTAL_COLS);
      const pokeRow = Math.floor(pokeIndex / TOTAL_COLS);
      const pokeCol = pokeIndex % TOTAL_COLS;
      const pageRow = Math.floor(pokeRow / PAGE_DIM);
      const pageCol = Math.floor(pokeCol / PAGE_DIM);
      const pageIndex = pageRow * PAGES_PER_ROW + pageCol;
      const localRow = pokeRow % PAGE_DIM;
      const localCol = pokeCol % PAGE_DIM;
      grid.pages[pageIndex][localRow * PAGE_DIM + localCol] = 1;
      lastPoke = { row: pokeRow, col: pokeCol };

      if (steps % 100 === 0) {
          grid.pages.forEach((page, index) => {
            const hashBytes = keccak256.array(page);
            const hashHex = toHexString(hashBytes);
            console.log(`Step ${steps} - Page ${index} Keccak256 hash: ${hashHex}`);
          });
        }

      drawGrid();
    }, 2);

    drawGrid();
  </script>
</body>
</html>
