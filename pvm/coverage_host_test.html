
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>pvm: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/colorfulnotion/jam/pvm/hostfunctions.go (69.5%)</option>
				
				<option value="file1">github.com/colorfulnotion/jam/pvm/mockenv.go (69.4%)</option>
				
				<option value="file2">github.com/colorfulnotion/jam/pvm/pvm.go (13.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package pvm

import (
        "encoding/binary"
        "fmt"
        "time"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/sp1"
        "github.com/colorfulnotion/jam/types"
)

// Appendix B - Host function
// Host function indexes
const (
        GAS               = 0
        LOOKUP            = 1
        READ              = 2
        WRITE             = 3
        INFO              = 4
        BLESS             = 5
        ASSIGN            = 6
        DESIGNATE         = 7
        CHECKPOINT        = 8
        NEW               = 9
        UPGRADE           = 10
        TRANSFER          = 11
        EJECT             = 12 // formerly Quit
        QUERY             = 13
        SOLICIT           = 14
        FORGET            = 15
        YIELD             = 16
        HISTORICAL_LOOKUP = 17
        IMPORT            = 18
        FETCH             = 203 // TODO: 18 (import =&gt; fetch)
        EXPORT            = 19
        MACHINE           = 20
        PEEK              = 21
        POKE              = 22
        ZERO              = 23
        VOID              = 24
        INVOKE            = 25
        EXPUNGE           = 26

        SP1VERIFY     = 64
        ED25519VERIFY = 65
        LOG           = 100
        FOR_TEST      = 105
)

const maxUint64 = ^uint64(0)

const (
        Debug_Service_Storage = false
)

const (
        g = 10
)

// Mapping of host function names to their error cases
var errorCases = map[string][]uint64{
        // B.6 General Functions
        "Gas":              {OK},
        "Lookup":           {OK, NONE, OOB},
        "Read":             {OK, OOB, NONE},
        "Write":            {OK, OOB, NONE, FULL},
        "Info":             {OK, OOB, NONE},
        "Sp1Groth16Verify": {OK, OOB, HUH},
        // B.7 Accumulate Functions
        "Bless":      {OK, OOB, WHO},
        "Assign":     {OK, OOB, CORE},
        "Designate":  {OK, OOB},
        "Checkpoint": {OK},
        "New":        {OK, OOB, CASH},
        "Upgrade":    {OK, OOB},
        "Transfer":   {OK, WHO, CASH, LOW, HIGH},
        "Quit":       {OK, OOB, WHO, LOW},
        "Solicit":    {OK, OOB, FULL, HUH},
        "Forget":     {OK, OOB, HUH},
        // B.8 Refine Functions
        "Historical_lookup": {OK, OOB},
        "Import":            {OK, OOB, NONE},
        "Export":            {OK, OOB, NONE},
        "Machine":           {OK, OOB},
        "Peek":              {OK, OOB, WHO},
        "Poke":              {OK, OOB, WHO},
        "Zero":              {OK, OOB, WHO},
        "Void":              {OK, OOB, WHO},
        "Invoke":            {OK, OOB, WHO, HOST, FAULT, OOB, PANIC},
        "Expunge":           {OK, OOB, WHO},
}

// Mapping of host function names to their indexes
var hostIndexMap = map[string]int{
        // B.6 General Functions
        "Gas":       GAS,
        "Lookup":    LOOKUP,
        "Read":      READ,
        "Write":     WRITE,
        "Info":      INFO,
        "Sp1Verify": SP1VERIFY,
        // B.7 Accumulate Functions
        "Bless":      BLESS,
        "Assign":     ASSIGN,
        "Designate":  DESIGNATE,
        "Checkpoint": CHECKPOINT,
        "New":        NEW,
        "Upgrade":    UPGRADE,
        "Transfer":   TRANSFER,
        "Eject":      EJECT,
        "Query":      QUERY,
        "Fetch":      FETCH,
        "Yield":      YIELD,
        "Solicit":    SOLICIT,
        "Forget":     FORGET,
        // B.8 Refine Functions
        "Historical_lookup": HISTORICAL_LOOKUP,
        "Import":            IMPORT,
        "Export":            EXPORT,
        "Machine":           MACHINE,
        "Peek":              PEEK,
        "Poke":              POKE,
        "Zero":              ZERO,
        "Void":              VOID,
        "Invoke":            INVOKE,
        "Expunge":           EXPUNGE,
        // Other
        "Log":      LOG,
        "For_test": FOR_TEST,
}

// Function to retrieve index and error cases
func GetHostFunctionDetails(name string) (int, []uint64) <span class="cov8" title="1">{
        index, exists := hostIndexMap[name]
        if !exists </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov8" title="1">errors, hasErrors := errorCases[name]
        if !hasErrors </span><span class="cov8" title="1">{
                errors = []uint64{} // No error cases defined
        }</span>
        <span class="cov8" title="1">return index, errors</span>
}

type RefineM struct {
        P []byte `json:"P"`
        U *RAM   `json:"U"`
        I uint64 `json:"I"`
}

// GP-0.5 B.5
type Refine_parameters struct {
        Gas                  uint64
        Ram                  *RAM
        Register             []uint32
        Machine              map[uint32]*RefineM
        Export_segment       [][]byte
        Import_segement      [][]byte
        Export_segment_index uint32
        service_index        uint32
        Delta                map[uint32]uint32
        C_t                  uint32
}

// InvokeHostCall handles host calls
// Returns true if the call results in a halt condition, otherwise false
func (vm *VM) InvokeHostCall(host_fn int) (bool, error) <span class="cov8" title="1">{
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("vm.host_fn=%v\n", vm.host_func_id) //Do you need operand here?
        }</span>

        <span class="cov8" title="1">if vm.Gas-g &lt; 0 </span><span class="cov8" title="1">{
                vm.ResultCode = OOG
                return true, fmt.Errorf("Out of gas\n")
        }</span> else<span class="cov8" title="1"> {
                vm.Gas = vm.Gas - g
        }</span>
        <span class="cov8" title="1">switch host_fn </span>{
        case GAS:<span class="cov8" title="1">
                vm.hostGas()
                return true, nil</span>

        case LOOKUP:<span class="cov8" title="1">
                vm.hostLookup()
                return true, nil</span>

        case READ:<span class="cov8" title="1">
                vm.hostRead()
                return true, nil</span>

        case WRITE:<span class="cov8" title="1">
                vm.hostWrite()
                return true, nil</span>

        case INFO:<span class="cov8" title="1">
                vm.hostInfo()
                return true, nil</span>

        case BLESS:<span class="cov0" title="0">
                vm.hostBless()
                return true, nil</span>

        case ASSIGN:<span class="cov0" title="0">
                vm.hostAssign()
                return true, nil</span>

        case DESIGNATE:<span class="cov0" title="0">
                vm.hostDesignate()
                return true, nil</span>

        case CHECKPOINT:<span class="cov0" title="0">
                vm.hostCheckpoint()
                return true, nil</span>

        case NEW:<span class="cov8" title="1">
                vm.hostNew()
                return true, nil</span>

        case UPGRADE:<span class="cov8" title="1">
                vm.hostUpgrade()
                return true, nil</span>

        case TRANSFER:<span class="cov8" title="1">
                omega_8, _ := vm.ReadRegister(8)
                omega_9, _ := vm.ReadRegister(9)
                vm.Gas = vm.Gas - int64(omega_8) - int64(omega_9)*(1&lt;&lt;32)
                vm.hostTransfer()
                return true, nil</span>

        case EJECT:<span class="cov8" title="1">
                vm.hostEject()
                return true, nil</span>

        case QUERY:<span class="cov8" title="1">
                vm.hostQuery()
                return true, nil</span>

        case SOLICIT:<span class="cov8" title="1">
                vm.hostSolicit()
                return true, nil</span>

        case FORGET:<span class="cov8" title="1">
                // t := vm.hostenv.GetTimeslot()
                vm.hostForget()
                return true, nil</span>

        case YIELD:<span class="cov8" title="1">
                vm.hostYield()
                return true, nil</span>

        // Refine functions
        case HISTORICAL_LOOKUP:<span class="cov8" title="1">
                vm.hostHistoricalLookup(0)
                return true, nil</span>

        case IMPORT:<span class="cov8" title="1">
                vm.hostImport()
                return true, nil</span>

        case EXPORT:<span class="cov8" title="1">
                vm.hostExport(0)
                return true, nil</span>

        case MACHINE:<span class="cov8" title="1">
                vm.hostMachine()
                return true, nil</span>

        case PEEK:<span class="cov8" title="1">
                vm.hostPeek()
                return true, nil</span>

        case POKE:<span class="cov8" title="1">
                vm.hostPoke()
                return true, nil</span>

        case ZERO:<span class="cov8" title="1">
                vm.hostZero()
                return true, nil</span>

        case VOID:<span class="cov8" title="1">
                vm.hostVoid()
                return true, nil</span>

        case INVOKE:<span class="cov8" title="1">
                vm.hostInvoke()
                return true, nil</span>

        case EXPUNGE:<span class="cov8" title="1">
                vm.hostExpunge()
                return true, nil</span>

        case LOG:<span class="cov0" title="0">
                vm.hostLog()
                return true, nil</span>

        case SP1VERIFY:<span class="cov0" title="0">
                vm.hostSP1Groth16Verify()
                return true, nil</span>

        default:<span class="cov0" title="0">
                vm.Gas = vm.Gas + g
                return false, fmt.Errorf("unknown host call: %d\n", host_fn)</span>
        }
}

// func min(x, y uint64) uint64 {
//         if x &lt; y {
//                 return x
//         }
//         return y
// }

// Information-on-Service
func (vm *VM) hostInfo() <span class="cov8" title="1">{
        omega_7, _ := vm.ReadRegister(7)

        t, errCode := vm.getXUDS(omega_7)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
                return
        }</span>
        <span class="cov8" title="1">bo, _ := vm.ReadRegister(8)

        e := []interface{}{t.CodeHash, t.Balance, t.ComputeThreshold(), t.GasLimitG, t.GasLimitM, t.ComputeNumStorageItems(), t.ComputeStorageSize()}
        m, err := types.Encode(e)
        if err != nil </span><span class="cov0" title="0">{
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
                return
        }</span>
        <span class="cov8" title="1">errcode := vm.Ram.WriteRAMBytes(uint32(bo), m[:])
        if errcode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

// Bless updates
func (vm *VM) hostBless() <span class="cov0" title="0">{
        m, _ := vm.ReadRegister(7)
        a, _ := vm.ReadRegister(8)
        v, _ := vm.ReadRegister(9)
        // Set (x'p)_m, (x'p)_a, (x'p)_v
        vm.X.U.PrivilegedState.Kai_m = uint32(m)
        vm.X.U.PrivilegedState.Kai_a = uint32(a)
        vm.X.U.PrivilegedState.Kai_v = uint32(v)
        vm.HostResultCode = OK
}</span>

// Assign Core x_c[i]
func (vm *VM) hostAssign() <span class="cov0" title="0">{
        core, _ := vm.ReadRegister(7)
        if core &gt;= numCores </span><span class="cov0" title="0">{
                vm.HostResultCode = CORE
                return
        }</span>
        <span class="cov0" title="0">o, _ := vm.ReadRegister(8)
        c, _ := vm.Ram.ReadRAMBytes(uint32(o), 32*types.MaxAuthorizationQueueItems)
        qi := make([]common.Hash, 32)
        for i := 0; i &lt; 32; i++ </span><span class="cov0" title="0">{
                qi[i] = common.BytesToHash(c[i:(i + 32)])
        }</span>
        <span class="cov0" title="0">copy(vm.X.U.QueueWorkReport[core][:], qi[:])
        vm.HostResultCode = OK</span>
}

// Designate validators
func (vm *VM) hostDesignate() <span class="cov0" title="0">{
        o, _ := vm.ReadRegister(7)
        v, errCode := vm.Ram.ReadRAMBytes(uint32(o), 176*V)
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">qi := make([]types.Validator, V)
        for i := 0; i &lt; types.TotalValidators; i++ </span><span class="cov0" title="0">{
                newv := types.Validator{}
                copy(newv.Bandersnatch[:], v[0:32])
                copy(newv.Ed25519[:], v[64:92])
                copy(newv.Bls[:], v[92:128])
                copy(newv.Metadata[:], v[128:])

                qi[i] = newv
        }</span>
        <span class="cov0" title="0">vm.X.U.UpcomingValidators = qi
        vm.HostResultCode = OK</span>
}

// Checkpoint gets Gas-remaining
func (vm *VM) hostCheckpoint() <span class="cov0" title="0">{
        vm.Y = vm.X.Clone()
        vm.WriteRegister(7, uint64(vm.Gas)) // CHECK
        vm.HostResultCode = OK
}</span>

func bump(i uint32) uint32 <span class="cov8" title="1">{
        const lowerLimit uint32 = 1 &lt;&lt; 8               // 2^8 = 256
        const upperLimit uint32 = (1 &lt;&lt; 32) - (1 &lt;&lt; 9) // 2^32 - 2^9 = 4294966784

        //(i - 256 + 42) =  (i - 241)??
        adjusted := int64(i) - int64(lowerLimit) + 42

        // need to make sure the result of the modulus operation is non-negative.
        // This is done by: ((adjusted % upperLimit) + upperLimit) % upperLimit.
        // This expression guarantees that if `adjusted` is negative, adding `upperLimit` first makes it positive.
        // Then, applying `% upperLimit` again ensures the result is within the range [0, upperLimit).
        // modResult := ((adjusted % int64(upperLimit)) + int64(upperLimit)) % int64(upperLimit)
        modResult := lowerLimit + uint32(adjusted)%upperLimit

        // Step 3: Return the result by adding `lowerLimit` back.
        // This aligns the final result with the desired range: [2^8, 2^32 - 2^9].
        // return lowerLimit + uint32(modResult)
        return uint32(modResult)
}</span>

func check(i uint32, u_d map[uint32]*types.ServiceAccount) uint32 <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                if _, ok := u_d[i]; !ok </span><span class="cov8" title="1">{
                        return i
                }</span>
                <span class="cov0" title="0">i = ((i - 256 + 1) % (4294967296 - 512)) + 256</span> // 2^32 - 2^9 + 2^8
        }
}

// New service
func (vm *VM) hostNew() <span class="cov8" title="1">{
        xContext := vm.X
        xs, _ := xContext.GetX_s()

        // put 'g' and 'm' together
        o, _ := vm.ReadRegister(7)
        c, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">l, _ := vm.ReadRegister(8)
        g, _ := vm.ReadRegister(9)
        m, _ := vm.ReadRegister(10)

        xi := xContext.I

        // simulate a with c, g, m
        a := &amp;types.ServiceAccount{
                ServiceIndex:    xi,
                Mutable:         true,
                Dirty:           true,
                CodeHash:        common.BytesToHash(c),
                GasLimitG:       uint64(g),
                GasLimitM:       uint64(m),
                NumStorageItems: 2*1 + 0,            //a_s = 2⋅∣al∣+∣as∣
                StorageSize:     uint64(81 + l + 0), //a_l =  ∑ 81+z per (h,z) + ∑ 32+s
                Storage:         make(map[common.Hash]types.StorageObject),
                Lookup:          make(map[common.Hash]types.LookupObject),
                Preimage:        make(map[common.Hash]types.PreimageObject),
        }
        a.Balance = a.ComputeThreshold()
        // fmt.Printf("Service %d hostNew %v =&gt; %d, code hash: %v\n", s, a.CodeHash, a.GetServiceIndex(), common.BytesToHash(c))

        if debug_host </span><span class="cov0" title="0">{
                fmt.Printf("Service %d hostNew %v =&gt; %d\n", xContext.S, a.CodeHash, a.GetServiceIndex())
        }</span>
        // Compute footprint &amp; threshold: a_l, a_s, a-t

        <span class="cov8" title="1">xs.DecBalance(a.Balance)
        if xs.Balance &gt;= xs.ComputeThreshold() </span><span class="cov8" title="1">{
                //xs has enough balance to fund the creation of a AND covering its own threshold
                // xi' &lt;- check(bump(xi))
                // vm.WriteRegister(7, xi)
                // xContext.I = vm.hostenv.Check(bump(xi)) // this is the next xi
                xContext.I = check(bump(xi), xContext.U.D)

                // I believe this is the same as solicit. where l∶{(c, l)↦[]} need to be set, which will later be provided by E_P
                a.WriteLookup(common.BytesToHash(c), uint32(l), []uint32{}) // *** CHECK

                // (x's)b &lt;- (xs)b - at
                // xContext.S = a.ServiceIndex()

                // Here we are adding the new service account to the map
                xContext.U.D[xi] = a

                vm.X = xContext
                vm.WriteRegister(7, uint64(xi))
                vm.HostResultCode = OK
        }</span> else<span class="cov8" title="1"> {
                if debug_host </span><span class="cov0" title="0">{
                        fmt.Println("Balance insufficient")
                }</span>
                <span class="cov8" title="1">xs.IncBalance(a.Balance)
                vm.WriteRegister(7, CASH)
                vm.HostResultCode = CASH</span> //balance insufficient
        }
}

// Upgrade service
func (vm *VM) hostUpgrade() <span class="cov8" title="1">{
        xContext := vm.X
        xs, _ := xContext.GetX_s()
        o, _ := vm.ReadRegister(7)
        g, _ := vm.ReadRegister(8)
        m, _ := vm.ReadRegister(9)

        c, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">xs.Dirty = true
        xs.CodeHash = common.BytesToHash(c)
        xs.GasLimitG = g
        xs.GasLimitM = m
        vm.WriteRegister(7, OK)
        // xContext.D[s] = xs // not sure if this is needed
        vm.HostResultCode = OK</span>
}

// Transfer host call
func (vm *VM) hostTransfer() <span class="cov8" title="1">{
        d, _ := vm.ReadRegister(7)
        a, _ := vm.ReadRegister(8)
        g, _ := vm.ReadRegister(9)
        o, _ := vm.ReadRegister(10)

        xs, _ := vm.X.GetX_s()

        D := vm.X.U.D

        var receiver *types.ServiceAccount
        var founded bool
        receiver, founded = D[uint32(d)]
        if !founded </span><span class="cov8" title="1">{
                receiver, founded, _ = vm.hostenv.GetService(uint32(d))
                if !founded </span><span class="cov8" title="1">{
                        vm.WriteRegister(7, WHO)
                        vm.HostResultCode = WHO
                        return
                }</span>
                <span class="cov0" title="0">vm.X.U.D[uint32(d)] = receiver</span>
        }

        <span class="cov8" title="1">m, errCode := vm.Ram.ReadRAMBytes(uint32(o), M)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">t := types.DeferredTransfer{Amount: a, GasLimit: g, SenderIndex: vm.X.S, ReceiverIndex: uint32(d)} // CHECK

        if g &lt; receiver.GasLimitM </span><span class="cov8" title="1">{
                vm.WriteRegister(7, LOW)
                vm.HostResultCode = LOW
                return
        }</span>

        <span class="cov8" title="1">xs.DecBalance(a)
        b := xs.Balance

        if b &lt; xs.ComputeThreshold() </span><span class="cov8" title="1">{
                xs.IncBalance(a)
                vm.WriteRegister(7, CASH)
                vm.HostResultCode = CASH
                return
        }</span>

        <span class="cov8" title="1">copy(t.Memo[:], m[:])
        vm.X.T = append(vm.X.T, t)
        vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

// Gas Service
func (vm *VM) hostGas() <span class="cov8" title="1">{
        vm.WriteRegister(7, uint64(vm.Gas))
        vm.HostResultCode = OK
}</span>

func (vm *VM) hostQuery() <span class="cov8" title="1">{
        o, _ := vm.ReadRegister(7)
        z, _ := vm.ReadRegister(8)
        h, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">a, _ := vm.X.GetX_s()
        ok, anchor_timeslot := a.ReadLookup(common.BytesToHash(h), uint32(z), vm.hostenv)
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, NONE)
                vm.WriteRegister(8, 0)
                vm.HostResultCode = NONE
                return
        }</span>
        <span class="cov8" title="1">switch len(anchor_timeslot) </span>{
        case 0:<span class="cov8" title="1">
                vm.WriteRegister(7, 0)
                vm.WriteRegister(8, 0)
                break</span>
        case 1:<span class="cov8" title="1">
                x := anchor_timeslot[0]
                vm.WriteRegister(7, 1+(1&lt;&lt;32)*uint64(x))
                vm.WriteRegister(8, 0)
                break</span>
        case 2:<span class="cov8" title="1">
                x := anchor_timeslot[0]
                y := anchor_timeslot[1]
                vm.WriteRegister(7, 2+(1&lt;&lt;32)*uint64(x))
                vm.WriteRegister(8, uint64(y))
                break</span>
        case 3:<span class="cov8" title="1">
                x := anchor_timeslot[0]
                y := anchor_timeslot[1]
                z := anchor_timeslot[2]
                vm.WriteRegister(7, 3+(1&lt;&lt;32)*uint64(x))
                vm.WriteRegister(8, uint64(y)+(1&lt;&lt;32)*uint64(z))
                break</span>
        }
        <span class="cov8" title="1">vm.HostResultCode = OK</span>
}
func (vm *VM) getWorkPackage() []byte <span class="cov0" title="0">{
        // TODO
        return []byte{}
}</span>

func (vm *VM) getAuthorizerOutput() []byte <span class="cov0" title="0">{
        // TODO
        return []byte{}
}</span>

func (vm *VM) getPayload() []byte <span class="cov0" title="0">{
        // TODO
        return []byte{}
}</span>

func (vm *VM) getNumberOfExtrinsics() []byte <span class="cov0" title="0">{
        // TODO
        numExtrinsics := uint32(1)
        return common.Uint32ToBytes(numExtrinsics)
}</span>

func (vm *VM) getNumberOfWorkItems() []byte <span class="cov0" title="0">{
        // TODO
        numWorkItems := uint32(1)
        return common.Uint32ToBytes(numWorkItems)
}</span>
func (vm *VM) getWorkPackageByWorkItemExtrinsic(workitemindex uint32, extrinsicindex uint32) (data []byte, ok bool) <span class="cov0" title="0">{
        return []byte{}, false
}</span>

func (vm *VM) getWorkPackageByWorkItemExtrinsicAll(workitemindex uint32) (data []byte, ok bool) <span class="cov0" title="0">{
        return []byte{}, false
}</span>

func (vm *VM) getWorkPackageByExtrinsicHash(h common.Hash) (data []byte, ok bool) <span class="cov0" title="0">{
        return []byte{}, false
}</span>

func (vm *VM) getWorkPackageImportSegment(workitemindex uint32, importindex uint32) (data []byte, ok bool) <span class="cov0" title="0">{
        return []byte{}, false
}</span>

func (vm *VM) getWorkPackageImportedSegmentAll(workitemindex uint32) (data []byte, ok bool) <span class="cov0" title="0">{
        return []byte{}, false
}</span>

// TODO: Fetch (0.5.5) https://github.com/gavofyork/graypaper/issues/186
/*
Reading is windowed, so both a length and offset is specified for the buffer. This allows streaming and avoids allocating more data into the PVM than necessary if only a small piece of the overall data is needed.

ω7 : The buffer pointer.
ω8 mod 2^32 : The maximum number of bytes of data to copy into the buffer.
⌊ω8 ÷ 2^32⌋: The offset into the input data to read from.
ω9 : The data type ID.

1: The authorizer output
2: Payload data; the work-item index is ω10
16: An extrinsic; the work-item index is ω10, the extrinsic index within the sequence specified by that work-item is ω11.
17: An extrinsic by index within the sequence specified by this work-item; the index is ω10
18: An extrinsic by hash; the data returned hashes to the 32 bytes found at ω10
32: An imported segment; the work-item index is ω10, the import index within the sequence specified by that work-item is ω11.
33: An imported segment by index within the sequence specified by this work-item; the index is ω10
3: number of extrinsics in WP
4: number of work items in WP
*/
func (vm *VM) hostFetch() <span class="cov0" title="0">{
        o, _ := vm.ReadRegister(7)
        len_offset, _ := vm.ReadRegister(8)
        l := len_offset &amp; 0xFFFFFFFF
        offset := (len_offset &gt;&gt; 32) &amp; 0xFFFFFFFF
        datatypeID, _ := vm.ReadRegister(9)
        switch datatypeID </span>{
        case 0:<span class="cov0" title="0"> // The (encoded) Work Package
                data := vm.getWorkPackage()
                odata := data[0:l]
                vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 1:<span class="cov0" title="0"> // The authorizer output
                data := vm.getAuthorizerOutput()
                odata := data[0:l]
                vm.Ram.WriteRAMBytes(uint32(o), odata[:])

                break</span>
        case 2:<span class="cov0" title="0"> // Payload data; the work-item index is ω10
                data := vm.getPayload()
                odata := data[0:l]
                vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 3:<span class="cov0" title="0"> // number of extrinsics
                data := vm.getNumberOfExtrinsics()
                odata := data[0:l]
                vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 4:<span class="cov0" title="0"> // number of work items
                data := vm.getNumberOfWorkItems()
                odata := data[0:l]
                vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 16:<span class="cov0" title="0"> // An extrinsic; the work-item index is ω10, the extrinsic index within the sequence specified by that work-item is ω11.
                workitemindex, _ := vm.ReadRegister(10)
                extrinsicindex, _ := vm.ReadRegister(11)
                data, ok := vm.getWorkPackageByWorkItemExtrinsic(uint32(workitemindex), uint32(extrinsicindex))
                if !ok </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, NONE)
                        vm.HostResultCode = NONE
                        return
                }</span>
                <span class="cov0" title="0">odata := data[offset:]
                if len(odata) &gt; int(l) </span><span class="cov0" title="0">{
                        odata = odata[0:l]
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 17:<span class="cov0" title="0"> // An extrinsic by index within the sequence specified by this work-item; the index is ω10
                workitemindex, _ := vm.ReadRegister(10)
                data, ok := vm.getWorkPackageByWorkItemExtrinsicAll(uint32(workitemindex))
                if !ok </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, NONE)
                        vm.HostResultCode = NONE
                        return
                }</span>
                <span class="cov0" title="0">odata := data[offset:]
                if len(odata) &gt; int(l) </span><span class="cov0" title="0">{
                        odata = odata[0:l]
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(o), odata[:])
                break</span>
        case 18:<span class="cov0" title="0"> // An extrinsic by hash; the data returned hashes to the 32 bytes found at ω10
                extrinsicHash := common.Hash{}
                data, ok := vm.getWorkPackageByExtrinsicHash(extrinsicHash)
                if !ok </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, NONE)
                        vm.HostResultCode = NONE
                        return
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(o), data[offset:])
                break</span>
        case 32:<span class="cov0" title="0"> // An imported segment; the work-item index is ω10, the import index within the sequence specified by that work-item is ω11.
                workitemindex, _ := vm.ReadRegister(10)
                importindex, _ := vm.ReadRegister(11)
                data, ok := vm.getWorkPackageImportSegment(uint32(workitemindex), uint32(importindex))
                if !ok </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, NONE)
                        vm.HostResultCode = NONE
                        return
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(o), data[offset:])
                break</span>
        case 33:<span class="cov0" title="0"> // An imported segment by index within the sequence specified by this work-item; the index is ω10
                workitemindex, _ := vm.ReadRegister(10)
                data, ok := vm.getWorkPackageImportedSegmentAll(uint32(workitemindex))
                if !ok </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, NONE)
                        vm.HostResultCode = NONE
                        return
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(o), data[offset:])
                break</span>
        }
        <span class="cov0" title="0">vm.HostResultCode = OK</span>
}

func (vm *VM) hostYield() <span class="cov8" title="1">{
        o, _ := vm.ReadRegister(7)
        h, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">y := common.BytesToHash(h)
        vm.X.Y = &amp;y
        vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostEject() <span class="cov8" title="1">{
        d, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        h, err := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if err != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">bold_d, ok := vm.X.U.D[uint32(d)]
        if d == uint64(vm.X.S) || !ok || bold_d.CodeHash != common.Hash(types.E_l(uint64(vm.X.S), 32)) </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>
        <span class="cov8" title="1">l := max(81, bold_d.ComputeStorageSize()) - 81

        ok, D_lookup := bold_d.ReadLookup(common.BytesToHash(h), uint32(l), vm.hostenv)
        if !ok || bold_d.ComputeNumStorageItems() != 2 </span><span class="cov8" title="1">{
                vm.WriteRegister(7, HUH)
                vm.HostResultCode = HUH
                return
        }</span>

        <span class="cov8" title="1">s, _ := vm.getXUDS(uint64(vm.X.S))
        s = s.Clone()
        s.Balance += bold_d.Balance

        if len(D_lookup) == 2 &amp;&amp; D_lookup[1] &lt; vm.Timeslot-uint32(D) </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OK)
                vm.HostResultCode = OK
                delete(vm.X.U.D, uint32(d))
                vm.X.U.D[vm.X.S] = s
                return
        }</span>

        <span class="cov0" title="0">vm.WriteRegister(7, HUH)
        vm.HostResultCode = HUH</span>
}
func (vm *VM) setGasRegister(gasBytes, registerBytes []byte) <span class="cov0" title="0">{

        // gas todo
        registers := make([]uint64, 13)
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                registers[i] = binary.LittleEndian.Uint64(registerBytes[i*8 : (i+1)*8])
        }</span>
        <span class="cov0" title="0">vm.register = registers</span>
}

// Invoke5
func (vm *VM) hostInvoke() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        gasBytes, errCodeGas := vm.Ram.ReadRAMBytes(uint32(o), 8)
        if errCodeGas != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">g := types.DecodeE_l(gasBytes)

        m_n_reg := make([]uint64, 13)
        for i := 1; i &lt; 14; i++ </span><span class="cov8" title="1">{
                reg_bytes, errCodeReg := vm.Ram.ReadRAMBytes(uint32(o)+8*uint32(i), 8)
                if errCodeReg != OK </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, OOB)
                        vm.HostResultCode = OOB
                        return
                }</span>
                <span class="cov8" title="1">m_n_reg[i-1] = types.DecodeE_l(reg_bytes)</span>
        }

        <span class="cov8" title="1">m_n, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>

        <span class="cov8" title="1">program := DecodeProgram_pure_pvm_blob(m_n.P)
        new_machine := &amp;VM{
                JSize:   program.JSize,
                Z:       program.Z,
                J:       program.J,
                code:    program.Code,
                bitmask: program.K[0],

                pc:       m_n.I,
                Gas:      int64(g),
                register: m_n_reg,
                Ram:      m_n.U,
        }

        new_machine.Execute(0)
        m_n.I = new_machine.pc
        m_n.U = new_machine.Ram
        vm.RefineM_map[uint32(n)] = m_n

        // Result after execution
        gasBytes = types.E_l(uint64(new_machine.Gas), 8)
        errCodeGas = vm.Ram.WriteRAMBytes(uint32(o), gasBytes)
        if errCodeGas != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt; 14; i++ </span><span class="cov8" title="1">{
                reg_bytes := types.E_l(new_machine.register[i-1], 8)
                errCode := vm.Ram.WriteRAMBytes(uint32(o)+8*uint32(i), reg_bytes)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, OOB)
                        vm.HostResultCode = OOB
                        return
                }</span>
        }

        <span class="cov8" title="1">if new_machine.ResultCode == HOST </span><span class="cov8" title="1">{
                vm.WriteRegister(7, HOST)
                vm.WriteRegister(8, uint64(new_machine.host_func_id))
                return
        }</span>

        <span class="cov8" title="1">if new_machine.ResultCode == FAULT </span><span class="cov8" title="1">{
                vm.WriteRegister(7, FAULT)
                vm.WriteRegister(8, uint64(new_machine.Fault_address))
                return
        }</span>

        <span class="cov8" title="1">if new_machine.ResultCode == OOG </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOG)
                return
        }</span>

        <span class="cov8" title="1">if new_machine.ResultCode == PANIC </span><span class="cov8" title="1">{
                vm.WriteRegister(7, PANIC)
                return
        }</span>

        <span class="cov8" title="1">if new_machine.ResultCode == HALT </span><span class="cov8" title="1">{
                vm.WriteRegister(7, HALT)
                return
        }</span>

}

// Lookup preimage
func (vm *VM) hostLookup() <span class="cov8" title="1">{
        omega_7, _ := vm.ReadRegister(7)

        var a *types.ServiceAccount
        if omega_7 == uint64(vm.Service_index) || omega_7 == maxUint64 </span><span class="cov8" title="1">{
                a = vm.ServiceAccount
        }</span> else<span class="cov8" title="1"> {
                a, _ = vm.getXUDS(omega_7)
        }</span>

        <span class="cov8" title="1">ho, _ := vm.ReadRegister(8)
        bo, _ := vm.ReadRegister(9)
        bz, _ := vm.ReadRegister(10)
        k_bytes, err_k := vm.Ram.ReadRAMBytes(uint32(ho), 32)
        if err_k != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">var account_blobhash common.Hash

        var v []byte
        var ok bool

        account_blobhash = common.Blake2Hash(k_bytes)
        ok, v = a.ReadPreimage(account_blobhash, vm.hostenv)
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
                return
        }</span>
        <span class="cov8" title="1">l := uint64(len(v))
        l = min(l, uint64(bz))

        err := vm.Ram.WriteRAMBytes(uint32(bo), v[:l])
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">if len(v) != 0 </span><span class="cov8" title="1">{
                vm.WriteRegister(7, l)
        }</span>
        <span class="cov8" title="1">vm.HostResultCode = OK</span>
}

// Key Idea: fetch potential mutated (with Mutable=true) ServiceAccount from the XContext Partial State (X.U.D),
// which may have been changed
func (vm *VM) getXUDS(serviceindex uint64) (a *types.ServiceAccount, errCode uint64) <span class="cov8" title="1">{
        var ok bool
        var err error
        s := uint32(serviceindex)
        if serviceindex == maxUint64 || uint32(serviceindex) == vm.X.S </span><span class="cov8" title="1">{
                return vm.X.U.D[s], OK
        }</span>
        <span class="cov8" title="1">a, ok = vm.X.U.D[s]
        if !ok </span><span class="cov8" title="1">{
                a, ok, err = vm.hostenv.GetService(s)
                if err != nil || !ok </span><span class="cov8" title="1">{
                        return nil, NONE
                }</span>
                <span class="cov0" title="0">vm.X.U.D[s] = a</span>
        }
        <span class="cov0" title="0">return a, OK</span>
}

// Read Storage
func (vm *VM) hostRead() <span class="cov8" title="1">{
        // Assume that all ram can be read and written
        omega_7, _ := vm.ReadRegister(7)

        var a *types.ServiceAccount
        if omega_7 == uint64(vm.Service_index) || omega_7 == maxUint64 </span><span class="cov8" title="1">{
                a = vm.ServiceAccount
        }</span> else<span class="cov8" title="1"> {
                a, _ = vm.getXUDS(omega_7)
        }</span>

        <span class="cov8" title="1">ko, _ := vm.ReadRegister(8)
        kz, _ := vm.ReadRegister(9)
        bo, _ := vm.ReadRegister(10)
        bz, _ := vm.ReadRegister(11)
        k, err_k := vm.Ram.ReadRAMBytes(uint32(ko), uint32(kz)) // this is the raw key.
        if err_k != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        // var account_storagehash common.Hash
        <span class="cov8" title="1">var val []byte
        _, val = a.ReadStorage(k, vm.hostenv)

        l := uint64(len(val))
        l = min(l, uint64(bz))
        if l != 0 </span><span class="cov8" title="1">{
                vm.Ram.WriteRAMBytes(uint32(bo), val[:l])
                vm.WriteRegister(7, l)
        }</span> else<span class="cov8" title="1"> {
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
        }</span>
}

// Write Storage
func (vm *VM) hostWrite() <span class="cov8" title="1">{
        var a *types.ServiceAccount

        a = vm.ServiceAccount
        if a == nil </span><span class="cov0" title="0">{
                a, _ = vm.getXUDS(uint64(vm.Service_index))
        }</span>

        <span class="cov8" title="1">ko, _ := vm.ReadRegister(7)
        kz, _ := vm.ReadRegister(8)
        vo, _ := vm.ReadRegister(9)
        vz, _ := vm.ReadRegister(10)
        k, err_k := vm.Ram.ReadRAMBytes(uint32(ko), uint32(kz))
        if err_k != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">var l uint64
        _, storage := a.ReadStorage(k, vm.hostenv)
        l = uint64(len(storage))

        if vz == 0 </span><span class="cov8" title="1">{
                a.WriteStorage(a.ServiceIndex, k, []byte{})
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
                return
        }</span>

        <span class="cov8" title="1">if a.ComputeThreshold() &lt;= a.Balance </span><span class="cov8" title="1">{
                // adjust S
                v := []byte{}
                err := uint64(0)
                if vz &gt; 0 </span><span class="cov8" title="1">{
                        v, err = vm.Ram.ReadRAMBytes(uint32(vo), uint32(vz))
                        if err != OK </span><span class="cov0" title="0">{
                                vm.WriteRegister(7, OOB)
                                vm.HostResultCode = OOB
                                return
                        }</span>
                }
                <span class="cov8" title="1">a.WriteStorage(a.ServiceIndex, k, v)

                vm.WriteRegister(7, l)
                vm.HostResultCode = OK</span>
        } else<span class="cov8" title="1"> {
                vm.WriteRegister(7, FULL)
                vm.HostResultCode = FULL
        }</span>
}

// Solicit preimage
func (vm *VM) hostSolicit() <span class="cov8" title="1">{
        xs, _ := vm.X.GetX_s()
        // Got l of X_s by setting s = 1, z = z(from RAM)
        o, _ := vm.ReadRegister(7)
        z, _ := vm.ReadRegister(8)                          // z: blob_len
        hBytes, err_h := vm.Ram.ReadRAMBytes(uint32(o), 32) // h: blobHash
        if err_h != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">account_lookuphash := common.BytesToHash(hBytes)

        ok, X_s_l := xs.ReadLookup(account_lookuphash, uint32(z), vm.hostenv)
        if !ok </span><span class="cov8" title="1">{
                // when preimagehash is not found, put it into solicit request - so we can ask other DAs
                xs.WriteLookup(account_lookuphash, uint32(z), []uint32{})
        }</span> else<span class="cov8" title="1"> if len(X_s_l) == 2 </span><span class="cov8" title="1">{ // [x, y]
                xs.WriteLookup(account_lookuphash, uint32(z), append(X_s_l, []uint32{vm.Timeslot}...))
        }</span> else<span class="cov8" title="1"> {
                vm.WriteRegister(7, HUH)
                vm.HostResultCode = HUH
                return
        }</span>
        <span class="cov8" title="1">if xs.Balance &lt; xs.ComputeThreshold() </span><span class="cov8" title="1">{
                xs.WriteLookup(account_lookuphash, uint32(z), X_s_l)
                vm.WriteRegister(7, FULL)
                vm.HostResultCode = FULL
                return
        }</span>
        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

// Forget preimage
func (vm *VM) hostForget() <span class="cov8" title="1">{
        x_s, _ := vm.X.GetX_s()
        o, _ := vm.ReadRegister(7)
        z, _ := vm.ReadRegister(8)
        hBytes, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">account_lookuphash := common.BytesToHash(hBytes)
        account_blobhash := common.Blake2Hash(hBytes)

        ok, X_s_l := x_s.ReadLookup(account_lookuphash, uint32(z), vm.hostenv)
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, HUH)
                vm.HostResultCode = HUH
                return
        }</span>

        <span class="cov8" title="1">if len(X_s_l) == 0 || (len(X_s_l) == 2) &amp;&amp; X_s_l[1] &lt; (vm.Timeslot-D) </span><span class="cov8" title="1">{
                x_s.WriteLookup(account_lookuphash, uint32(z), nil) // nil means delete the lookup
                x_s.WritePreimage(account_blobhash, []byte{})       // []byte{} means delete the preimage
                vm.WriteRegister(7, OK)
                vm.HostResultCode = OK
        }</span> else<span class="cov8" title="1"> if len(X_s_l) == 1 </span><span class="cov8" title="1">{
                x_s.WriteLookup(account_lookuphash, uint32(z), append(X_s_l, []uint32{vm.Timeslot}...))
                vm.WriteRegister(7, OK)
                vm.HostResultCode = OK
        }</span> else<span class="cov8" title="1"> if len(X_s_l) == 3 &amp;&amp; X_s_l[1] &lt; (vm.Timeslot-D) </span><span class="cov8" title="1">{
                X_s_l = []uint32{X_s_l[2], vm.Timeslot}
                x_s.WriteLookup(account_lookuphash, uint32(z), X_s_l)
                vm.WriteRegister(7, OK)
                vm.HostResultCode = OK
        }</span>
}

// HistoricalLookup determines whether the preimage of some hash h was available for lookup by some service account a at some timeslot t, and if so, provide its preimage
func (vm *VM) hostHistoricalLookup(t uint32) <span class="cov8" title="1">{
        var a = &amp;types.ServiceAccount{}
        delta := vm.Delta
        s := vm.Service_index
        omega_7, _ := vm.ReadRegister(7)
        ho, _ := vm.ReadRegister(8)
        bo, _ := vm.ReadRegister(9)
        bz, _ := vm.ReadRegister(10)

        if omega_7 == NONE </span><span class="cov8" title="1">{
                a = delta[s]
        }</span> else<span class="cov8" title="1"> {
                a = delta[uint32(omega_7)]
        }</span>

        <span class="cov8" title="1">hBytes, errCode := vm.Ram.ReadRAMBytes(uint32(ho), 32)
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        // h := common.Hash(hBytes) not sure whether this is needed
        <span class="cov8" title="1">v := vm.hostenv.HistoricalLookup(a, vm.Timeslot, common.BytesToHash(hBytes))
        vLength := uint64(len(v))
        if vLength == 0 </span><span class="cov8" title="1">{
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
                return
        }</span> else<span class="cov8" title="1"> {
                l := uint64(vLength)
                l = min(l, bz)
                vm.Ram.WriteRAMBytes(uint32(bo), v[:l])
                vm.WriteRegister(7, vLength)
        }</span>
}

// Import Segment
func (vm *VM) hostImport() <span class="cov8" title="1">{
        // import  - which copies  a specific i  (e.g. holding the bytes "9") into RAM from "ImportDA" to be "accumulated"
        omega_0, _ := vm.ReadRegister(7) // a0 = 7
        var v_Bytes []byte
        if omega_0 &lt; uint64(len(vm.Imports)) </span><span class="cov8" title="1">{
                v_Bytes = vm.Imports[omega_0][:]
        }</span> else<span class="cov8" title="1"> {
                v_Bytes = []byte{}
        }</span>
        <span class="cov8" title="1">o, _ := vm.ReadRegister(8) // a1 = 8
        l, _ := vm.ReadRegister(9) // a2 = 9
        if l &gt; (W_E * W_S) </span><span class="cov8" title="1">{
                l = W_E * W_S
        }</span>

        <span class="cov8" title="1">if len(v_Bytes) != 0 </span><span class="cov8" title="1">{
                errCode := vm.Ram.WriteRAMBytes(uint32(o), v_Bytes[:])
                if errCode != OK </span><span class="cov8" title="1">{
                        vm.WriteRegister(7, OOB)
                        vm.HostResultCode = OOB
                        return
                }</span>
                <span class="cov8" title="1">vm.WriteRegister(7, OK)
                vm.HostResultCode = OK</span>
        } else<span class="cov8" title="1"> {
                vm.WriteRegister(7, NONE)
                vm.HostResultCode = NONE
        }</span>
}

// Export segment host-call
func (vm *VM) hostExport(pi uint32) [][]byte <span class="cov8" title="1">{
        p, _ := vm.ReadRegister(7) // a0 = 7
        z, _ := vm.ReadRegister(8) // a1 = 8
        if z &gt; (W_E * W_S) </span><span class="cov8" title="1">{
                z = W_E * W_S
        }</span>

        <span class="cov8" title="1">e := vm.Exports

        x, errCode := vm.Ram.ReadRAMBytes(uint32(p), uint32(z))
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.Exports = e
                vm.HostResultCode = OOB
                return e
        }</span>

        /*  apply eq(187) zero-padding function:

        And P is the zero-padding function to take an octet array to some multiple of n in length:
        (187)         P n∈N 1∶ ∶{ Y → Y k⋅n
                        x ↦ x ⌢ [0, 0, ...] ((∣x∣+n−1) mod n)+1...n

        n := (W_E * W_S)
        length := n - ((len(x) + n - 1) % n) + 1
        zeroSequence := make([]byte, length)
        x = append(x, zeroSequence...)
        */
        <span class="cov8" title="1">x = common.PadToMultipleOfN(x, W_E*W_S)

        ς := vm.ExportSegmentIndex   // Assume ς (sigma, Represent segment offset), need to get ς properly
        if ς+uint32(len(e)) &gt;= W_X </span><span class="cov8" title="1">{ // W_X
                vm.WriteRegister(7, FULL)
                vm.Exports = e
                vm.HostResultCode = FULL
                return e
        }</span> else<span class="cov8" title="1"> {
                vm.WriteRegister(7, uint64(ς)+uint64(len(e)))
                e = append(e, x)
                vm.Exports = e
                // errCode = vm.hostenv.ExportSegment(x)
                vm.HostResultCode = OK
                return e
        }</span>
}

func (vm *VM) hostMachine() <span class="cov8" title="1">{
        po, _ := vm.ReadRegister(7)
        pz, _ := vm.ReadRegister(8)
        i, _ := vm.ReadRegister(9)
        p, errCode := vm.Ram.ReadRAMBytes(uint32(po), uint32(pz))
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">min_n := uint32(0)
        for n, _ := range vm.RefineM_map </span><span class="cov8" title="1">{
                if n == min_n </span><span class="cov8" title="1">{
                        min_n = n + 1
                }</span>
        }

        <span class="cov8" title="1">u := NewRAM()
        vm.RefineM_map[min_n] = &amp;RefineM{}

        vm.RefineM_map[min_n].P = p
        vm.RefineM_map[min_n].U = u
        vm.RefineM_map[min_n].I = i
        vm.WriteRegister(7, uint64(min_n))</span>
}

func (vm *VM) hostPeek() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        s, _ := vm.ReadRegister(9)
        z, _ := vm.ReadRegister(10)
        m_n, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>
        // read l bytes from m
        <span class="cov8" title="1">s_data, errCode := m_n.U.ReadRAMBytes(uint32(s), uint32(z))
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        // write l bytes to vm
        <span class="cov8" title="1">errCode = vm.Ram.WriteRAMBytes(uint32(o), s_data[:])
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostPoke() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        s, _ := vm.ReadRegister(8)
        o, _ := vm.ReadRegister(9)
        z, _ := vm.ReadRegister(10)
        m_n, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>
        // read data from original vm
        <span class="cov8" title="1">s_data, errCode := vm.Ram.ReadRAMBytes(uint32(s), uint32(z))
        if errCode != OK </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        // write data to m_n
        <span class="cov8" title="1">errCode = m_n.U.WriteRAMBytes(uint32(o), s_data[:])
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostExpunge() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        _, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.HostResultCode = WHO
                vm.WriteRegister(7, WHO)
                return
        }</span>

        <span class="cov8" title="1">delete(vm.RefineM_map, uint32(n))

        vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostVoid() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        p, _ := vm.ReadRegister(8)
        c, _ := vm.ReadRegister(9)

        m, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>
        <span class="cov8" title="1">if p+c &gt;= (1 &lt;&lt; 32) </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">for _, page := range m.U.Pages </span><span class="cov8" title="1">{
                if page.Access.Inaccessible </span><span class="cov8" title="1">{
                        vm.WriteRegister(7, OOB)
                        vm.HostResultCode = OOB
                        return
                }</span>
        }
        <span class="cov8" title="1">var err uint64
        var access_mode AccessMode

        // set page access to writable to write [0,0,0,....] to the page
        access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: false}
        err = m.U.SetPageAccess(uint32(p), uint32(c), access_mode)
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        // write [0,0,0,....] to the page
        <span class="cov8" title="1">err = m.U.WriteRAMBytes(uint32(p)*PageSize, make([]byte, 0))
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        // set page access to inaccessible
        <span class="cov8" title="1">access_mode = AccessMode{Inaccessible: true, Writable: false, Readable: false}
        err = m.U.SetPageAccess(uint32(p), uint32(c), access_mode)
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostZero() <span class="cov8" title="1">{
        n, _ := vm.ReadRegister(7)
        p, _ := vm.ReadRegister(8)
        c, _ := vm.ReadRegister(9)
        if p &lt; 16 || p+c &gt; (1&lt;&lt;32)/Z_P </span><span class="cov8" title="1">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov8" title="1">m, ok := vm.RefineM_map[uint32(n)]
        if !ok </span><span class="cov8" title="1">{
                vm.WriteRegister(7, WHO)
                vm.HostResultCode = WHO
                return
        }</span>
        <span class="cov8" title="1">var err uint64
        access_mode := AccessMode{Inaccessible: false, Writable: true, Readable: false}
        err = m.U.SetPageAccess(uint32(p), uint32(c), access_mode)
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">err = m.U.WriteRAMBytes(uint32(p)*PageSize, make([]byte, 0))
        if err != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov8" title="1">vm.WriteRegister(7, OK)
        vm.HostResultCode = OK</span>
}

func (vm *VM) hostSP1Groth16Verify() <span class="cov0" title="0">{
        proof, _ := vm.ReadRegister(7)
        proof_length, _ := vm.ReadRegister(8)
        verifierkey, _ := vm.ReadRegister(9)
        verifierkey_length, _ := vm.ReadRegister(10)
        public, _ := vm.ReadRegister(11)
        public_length, _ := vm.ReadRegister(12)

        proofBytes, errCode := vm.Ram.ReadRAMBytes(uint32(proof), uint32(proof_length))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">verifierBytes, errCode := vm.Ram.ReadRAMBytes(uint32(verifierkey), uint32(verifierkey_length))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">pubBytes, errCode := vm.Ram.ReadRAMBytes(uint32(public), uint32(public_length))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>

        <span class="cov0" title="0">verified := sp1.VerifyGroth16(proofBytes, string(verifierBytes), pubBytes)
        if verified </span><span class="cov0" title="0">{
                vm.HostResultCode = OK
        }</span>
        <span class="cov0" title="0">vm.HostResultCode = HUH</span>
}

func getLogLevelName(level uint64) string <span class="cov0" title="0">{
        switch level </span>{
        case 0:<span class="cov0" title="0">
                return "⛔️ FATAL"</span>
        case 1:<span class="cov0" title="0">
                return "⚠️ WARNING"</span>
        case 2:<span class="cov0" title="0">
                return "ℹ️ INFO"</span>
        case 3:<span class="cov0" title="0">
                return "💁 HELPFUL"</span>
        case 4:<span class="cov0" title="0">
                return "🪡 PEDANTIC"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// JIP-1 https://hackmd.io/@polkadot/jip1
func (vm *VM) hostLog() <span class="cov0" title="0">{

        level, _ := vm.ReadRegister(7)
        target, _ := vm.ReadRegister(8)
        targetlen, _ := vm.ReadRegister(9)
        message, _ := vm.ReadRegister(10)
        messagelen, _ := vm.ReadRegister(11)
        targetBytes, errCode := vm.Ram.ReadRAMBytes(uint32(target), uint32(targetlen))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">messageBytes, errCode := vm.Ram.ReadRAMBytes(uint32(message), uint32(messagelen))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">currentTime := time.Now().Format("2006-01-02 15:04:05")
        levelName := getLogLevelName(level) // Assume a function that maps level numbers to log level names.

        // &lt;YYYY-MM-DD hh-mm-ss&gt; &lt;LEVEL&gt;[@&lt;CORE&gt;]?[#&lt;SERVICE_ID&gt;]? [&lt;TARGET&gt;]? &lt;MESSAGE&gt;
        fmt.Printf("[%s] %s [TARGET: %s] %s\n", currentTime, levelName, string(targetBytes), string(messageBytes))
        vm.HostResultCode = OK</span>
}

func (vm *VM) PutGasAndRegistersToMemory(input_address uint32, gas uint64, regs []uint64) <span class="cov0" title="0">{
        gasBytes := make([]byte, 8)
        binary.LittleEndian.PutUint64(gasBytes, gas)
        errCode := vm.Ram.WriteRAMBytes(input_address, gasBytes)
        if errCode != OK </span><span class="cov0" title="0">{
                vm.HostResultCode = OOB
                return
        }</span>
        <span class="cov0" title="0">for i, reg := range regs </span><span class="cov0" title="0">{
                regBytes := make([]byte, 8)
                binary.LittleEndian.PutUint64(regBytes, reg)
                errCode = vm.Ram.WriteRAMBytes(input_address+8+uint32(i*8), regBytes)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.HostResultCode = OOB
                        return
                }</span>
        }
        <span class="cov0" title="0">vm.HostResultCode = OK</span>
}

func (vm *VM) GetGasAndRegistersFromMemory(input_address uint32) (gas uint64, regs []uint64, errCode uint64) <span class="cov0" title="0">{
        gasBytes, errCode := vm.Ram.ReadRAMBytes(input_address, 8)
        if errCode != OK </span><span class="cov0" title="0">{
                return 0, nil, errCode
        }</span>
        <span class="cov0" title="0">gas = binary.LittleEndian.Uint64(gasBytes)
        regs = make([]uint64, 13)
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                regBytes, errCode := vm.Ram.ReadRAMBytes(input_address+8+uint32(i*8), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        return 0, nil, errCode
                }</span>
                <span class="cov0" title="0">regs[i] = binary.LittleEndian.Uint64(regBytes)
                fmt.Printf("Register %d: %d\n", i, regs[i])</span>
        }
        <span class="cov0" title="0">return gas, regs, OK</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package pvm

import (
        "log"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/trie"
        "github.com/colorfulnotion/jam/types"
)

// MockHostEnv struct implements the HostEnv interface with mock responses
type MockHostEnv struct {
        db *storage.StateDBStorage
}

func NewMockHostEnvDB() *storage.StateDBStorage <span class="cov8" title="1">{
        test_db, _ := trie.InitLevelDB()
        return test_db
}</span>

func NewMockHostEnv() *MockHostEnv <span class="cov8" title="1">{
        test_db := NewMockHostEnvDB()
        return &amp;MockHostEnv{db: test_db}
}</span>

// func (mh *MockHostEnv) GetXContext() *types.XContext {
//         return new(types.XContext)
// }

// func (mh *MockHostEnv) SetXContext(x *types.XContext) {}

// func (mh *MockHostEnv) UpdateXContext(x *types.XContext) {}

func (mh *MockHostEnv) GetDB() *storage.StateDBStorage <span class="cov8" title="1">{
        return mh.db
}</span>

func (mh *MockHostEnv) GetService(c uint32) (*types.ServiceAccount, bool, error) <span class="cov8" title="1">{
        return nil, false, nil
}</span>

func (mh *MockHostEnv) ReadServiceStorage(s uint32, k []byte) (storage []byte, ok bool, err error) <span class="cov8" title="1">{
        db := mh.GetDB()
        _, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        // fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov8" title="1">storage, ok, err = tree.GetServiceStorage(s, k)
        if err != nil || !ok </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return nil, false, err</span>
}

func (mh *MockHostEnv) ReadServicePreimageBlob(s uint32, blob_hash common.Hash) (blob []byte, ok bool, err error) <span class="cov8" title="1">{
        db := mh.GetDB()
        _, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        // fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov8" title="1">blob, ok, err = tree.GetPreImageBlob(s, blob_hash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">return nil, false, err</span>
}

func (mh *MockHostEnv) ReadServicePreimageLookup(s uint32, blob_hash common.Hash, blob_length uint32) (time_slots []uint32, ok bool, err error) <span class="cov8" title="1">{
        db := mh.GetDB()
        _, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        // fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov8" title="1">time_slots, ok, err = tree.GetPreImageLookup(s, blob_hash, blob_length)
        if err != nil || !ok </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov0" title="0">return nil, false, err</span>
}

func (mh *MockHostEnv) HistoricalLookup(a *types.ServiceAccount, t uint32, blob_hash common.Hash) []byte <span class="cov8" title="1">{
        blob := a.Preimage[common.Blake2Hash(blob_hash.Bytes())].Preimage
        timeslots := a.Lookup[blob_hash].T
        if len(timeslots) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if len(timeslots) == 1 </span><span class="cov8" title="1">{
                if timeslots[0] &lt;= t </span><span class="cov8" title="1">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> if len(timeslots) == 2 </span><span class="cov0" title="0">{
                if timeslots[0] &lt;= t &amp;&amp; t &lt; timeslots[1] </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                if timeslots[0] &lt;= t &amp;&amp; t &lt; timeslots[1] || timeslots[2] &lt;= t </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}

func (mh *MockHostEnv) GetTimeslot() uint32 <span class="cov0" title="0">{
        return uint32(0)
}</span>

func (mh *MockHostEnv) WriteServicePreimageBlob(s uint32, blob []byte) {<span class="cov0" title="0">
        // TODO: elimnate the need for this by adjusting genesis.go
}</span>

func (mh *MockHostEnv) WriteServicePreimageLookup(s uint32, blob_hash common.Hash, blob_length uint32, time_slots []uint32) {<span class="cov0" title="0">
        // TODO: elimnate the need for this by adjusting genesis.go
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package pvm

import (
        "errors"
        "fmt"
        "math/big"
        "reflect"
        "strconv"

        "strings"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

const (
        debug_pvm  = false
        debug_host = false

        regSize  = 13
        numCores = types.TotalCores
        W_E      = types.W_E
        W_S      = types.W_S

        W_X = 1024
        M   = 128
        Bs  = 100
        V   = 1023
        D   = 28800
        Z_A = 2
        Z_P = (1 &lt;&lt; 12)
        Z_Q = (1 &lt;&lt; 16)
        Z_I = (1 &lt;&lt; 24)
        Z_Z = (1 &lt;&lt; 16)
)

const (
        PageSize     = 4096                    // Size of each page (2^12 bytes)
        AddressSpace = 4294967296              // Total addressable memory (2^32)
        TotalPages   = AddressSpace / PageSize // Total number of pages
)

// AccessMode represents the access permissions of a memory page
type AccessMode struct {
        Inaccessible bool `json:"inaccessible"` // Indicates if the page is inaccessible
        Writable     bool `json:"writable"`     // Indicates if the page is writable
        Readable     bool `json:"readable"`     // Indicates if the page is readable
}

// MemoryPage represents a single memory page
type Page struct {
        Value  []byte     `json:"data"`   // The data stored in the page
        Access AccessMode `json:"access"` // The access mode of the page
}

// RAM represents the entire memory system
type RAM struct {
        Pages map[uint32]*Page `json:"pages"` // The pages in the RAM
}

func NewRAM() *RAM <span class="cov8" title="1">{
        return &amp;RAM{
                Pages: make(map[uint32]*Page),
        }
}</span>

// Ensure data allocation for a page (lazy allocation)
func (p *Page) ensureData() <span class="cov8" title="1">{
        if p.Value == nil </span><span class="cov8" title="1">{
                p.Value = make([]byte, PageSize)
        }</span>
}

func (p *Page) zero() <span class="cov0" title="0">{
        p.Value = make([]byte, PageSize)
        p.Access = AccessMode{
                Inaccessible: false,
                Writable:     true,
                Readable:     true,
        }
}</span>

func (p *Page) void() <span class="cov0" title="0">{
        p.Value = make([]byte, PageSize)
        p.Access = AccessMode{
                Inaccessible: true,
                Writable:     false,
                Readable:     false,
        }
}</span>

// Get or allocate a specific page
func (ram *RAM) getOrAllocatePage(pageIndex uint32) (*Page, error) <span class="cov8" title="1">{
        if pageIndex &gt;= TotalPages </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("page index %d out of bounds (max %d)", pageIndex, TotalPages-1)
        }</span>

        // Check if the page already exists
        <span class="cov8" title="1">if page, exists := ram.Pages[pageIndex]; exists </span><span class="cov8" title="1">{
                return page, nil
        }</span>

        // Allocate a new page dynamically
        <span class="cov8" title="1">newPage := &amp;Page{
                Access: AccessMode{
                        Inaccessible: true, // Default to inaccessible
                        Writable:     false,
                        Readable:     false,
                },
        }
        ram.Pages[pageIndex] = newPage
        return newPage, nil</span>
}

// Set the access mode for a specific page
func (ram *RAM) SetPageAccess(pageIndex uint32, Numpages uint32, mode AccessMode) uint64 <span class="cov8" title="1">{
        for i := pageIndex; i &lt; pageIndex+Numpages; i++ </span><span class="cov8" title="1">{
                page, err := ram.getOrAllocatePage(i)
                if err != nil </span><span class="cov0" title="0">{
                        return OOB
                }</span>
                <span class="cov8" title="1">page.Access = mode</span>
        }
        <span class="cov8" title="1">return OK</span>
}

// WriteRAMBytes writes data to a specific address in RAM
func (ram *RAM) WriteRAMBytes(address uint32, data []byte) uint64 <span class="cov8" title="1">{
        offset := address % PageSize
        remaining := uint32(len(data))

        for remaining &gt; 0 </span><span class="cov8" title="1">{
                currentPage := address / PageSize
                pageOffset := offset
                page, err := ram.getOrAllocatePage(currentPage)
                if err != nil </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Fail to get or allocate page %d to access address %d\n", currentPage, address)
                        }</span>
                        <span class="cov0" title="0">return OOB</span>
                }

                // Check if the page is writable
                <span class="cov8" title="1">if !page.Access.Writable </span><span class="cov8" title="1">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Page %d is not writable, addess is %d\n", currentPage, address)
                        }</span>
                        <span class="cov8" title="1">return uint64(address)</span>
                }

                // Ensure data allocation before writing
                <span class="cov8" title="1">page.ensureData()

                // Calculate how much data can be written to the current page
                bytesToWrite := PageSize - pageOffset
                if bytesToWrite &gt; remaining </span><span class="cov8" title="1">{
                        bytesToWrite = remaining
                }</span>
                <span class="cov8" title="1">copy(page.Value[pageOffset:pageOffset+bytesToWrite], data[:bytesToWrite])

                // Update the address, data slice, and remaining bytes
                address += bytesToWrite
                data = data[bytesToWrite:]
                remaining -= bytesToWrite
                offset = 0</span> // Offset is only used for the first page
        }
        <span class="cov8" title="1">return OK</span>
}

// ReadRAMBytes reads data from a specific address in RAM
func (ram *RAM) ReadRAMBytes(address uint32, length uint32) ([]byte, uint64) <span class="cov8" title="1">{
        result := make([]byte, 0, length)
        offset := address % PageSize
        remaining := length

        for remaining &gt; 0 </span><span class="cov8" title="1">{
                currentPage := address / PageSize
                pageOffset := offset

                // Ensure the page exists and is readable
                page, err := ram.getOrAllocatePage(currentPage)
                if err != nil </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Fail to get or allocate page %d to access address %d\n", currentPage, address)
                        }</span>
                        <span class="cov0" title="0">return nil, OOB</span>
                }
                <span class="cov8" title="1">if page.Access.Inaccessible </span><span class="cov8" title="1">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Page %d is not readable, addess is %d, length is %d\n", currentPage, address, length)
                        }</span>
                        <span class="cov8" title="1">return nil, uint64(address)</span>
                }

                // Calculate how much data can be read from the current page
                <span class="cov8" title="1">bytesToRead := PageSize - pageOffset
                if bytesToRead &gt; remaining </span><span class="cov8" title="1">{
                        bytesToRead = remaining
                }</span>

                // Check against the actual slice length to avoid out-of-range errors
                <span class="cov8" title="1">pageSize := uint32(len(page.Value))
                endPos := pageOffset + bytesToRead

                if endPos &lt;= pageSize </span><span class="cov8" title="1">{
                        // Entire slice is within valid range
                        result = append(result, page.Value[pageOffset:endPos]...)
                }</span> else<span class="cov0" title="0"> {
                        // Part or all of the required range goes out of bounds
                        if pageOffset &gt;= pageSize </span><span class="cov0" title="0">{
                                // Completely out of range: fill everything with zero
                                result = append(result, make([]byte, bytesToRead)...)
                        }</span> else<span class="cov0" title="0"> {
                                // Part of the data is valid, the rest should be zero
                                validLen := pageSize - pageOffset
                                result = append(result, page.Value[pageOffset:pageOffset+validLen]...)
                                result = append(result, make([]byte, bytesToRead-validLen)...)
                        }</span>
                }

                // Update the address and remaining bytes
                <span class="cov8" title="1">address += bytesToRead
                remaining -= bytesToRead
                offset = 0</span> // Offset is only used for the first page
        }
        <span class="cov8" title="1">return result, OK</span>
}

// DebugStatus provides a snapshot of the RAM's state
func (ram *RAM) DebugStatus() <span class="cov0" title="0">{
        fmt.Println("RAM Status:")
        for pageIndex, page := range ram.Pages </span><span class="cov0" title="0">{
                fmt.Printf("Page %d: Inaccessible=%v, Writable=%v, Readable=%v, Data Allocated=%v\n",
                        pageIndex, page.Access.Inaccessible, page.Access.Writable, page.Access.Readable, page.Value != nil)
        }</span>
}

type VM struct {
        JSize          uint64
        Z              uint8
        J              []uint32
        code           []byte
        bitmask        string // K in GP
        pc             uint64 // Program counter
        ResultCode     uint8
        HostResultCode uint64
        Fault_address  uint32
        terminated     bool
        hostCall       bool // ̵h in GP
        host_func_id   int  // h in GP
        // ram                 map[uint32][4096]byte
        Ram      *RAM
        register []uint64
        Gas      int64
        hostenv  types.HostEnv

        VMs map[uint32]*VM

        // Work Package Inputs
        Extrinsics [][]byte
        payload    []byte
        Imports    [][]byte

        // Invocation funtions entry point
        EntryPoint uint32

        // Malicious Setting
        IsMalicious bool

        // standard program initialization parameters
        o_size uint32
        w_size uint32
        z      uint32
        s      uint32
        o_byte []byte
        w_byte []byte

        // Refine argument
        RefineM_map        map[uint32]*RefineM
        Exports            [][]byte
        ExportSegmentIndex uint32

        // Accumulate argument
        X        *types.XContext
        Y        types.XContext
        Timeslot uint32

        // Gereral argument
        ServiceAccount *types.ServiceAccount
        Service_index  uint32
        Delta          map[uint32]*types.ServiceAccount
}

type Forgets struct {
}

type Solicit struct {
        BlobHash common.Hash
        Length   uint32
}

type Program struct {
        JSize uint64
        Z     uint8 // 1 byte
        CSize uint64
        J     []uint32
        Code  []byte
        //K     []byte
        K []string
}

// Appendix A - Instuctions

// A.5.1. Instructions without Arguments.
const (
        TRAP        = 0
        FALLTHROUGH = 1
)

// A.5.2. Instructions with Arguments of One Immediate.
const (
        ECALLI = 10 // 0x0a
)

// A.5.3. Instructions with Arguments of One Register and One Extended Width Immediate.
const (
        LOAD_IMM_64 = 20 // 0x14
)

// A.5.4. Instructions with Arguments of Two Immediates.
const (
        STORE_IMM_U8  = 30
        STORE_IMM_U16 = 31
        STORE_IMM_U32 = 32
        STORE_IMM_U64 = 33 // NEW, 32-bit twin = store_imm_u32
)

// A.5.5. Instructions with Arguments of One Offset.
const (
        JUMP = 40 // 0x28
)

// A.5.6. Instructions with Arguments of One Register &amp; Two Immediates.
const (
        JUMP_IND  = 50
        LOAD_IMM  = 51
        LOAD_U8   = 52
        LOAD_I8   = 53
        LOAD_U16  = 54
        LOAD_I16  = 55
        LOAD_U32  = 56
        LOAD_I32  = 57
        LOAD_U64  = 58
        STORE_U8  = 59
        STORE_U16 = 60
        STORE_U32 = 61
        STORE_U64 = 62
)

// A.5.7. Instructions with Arguments of One Register &amp; Two Immediates.
const (
        STORE_IMM_IND_U8  = 70 // 0x46
        STORE_IMM_IND_U16 = 71 // 0x47
        STORE_IMM_IND_U32 = 72 // 0x48
        STORE_IMM_IND_U64 = 73 // 0x49 NEW, 32-bit twin = store_imm_ind_u32
)

// A.5.8. Instructions with Arguments of One Register, One Immediate and One Offset.
const (
        LOAD_IMM_JUMP   = 80
        BRANCH_EQ_IMM   = 81 // 0x51
        BRANCH_NE_IMM   = 82
        BRANCH_LT_U_IMM = 83
        BRANCH_LE_U_IMM = 84
        BRANCH_GE_U_IMM = 85
        BRANCH_GT_U_IMM = 86
        BRANCH_LT_S_IMM = 87
        BRANCH_LE_S_IMM = 88
        BRANCH_GE_S_IMM = 89
        BRANCH_GT_S_IMM = 90
)

// A.5.9. Instructions with Arguments of Two Registers.
const (
        MOVE_REG              = 100
        SBRK                  = 101
        COUNT_SET_BITS_64     = 102
        COUNT_SET_BITS_32     = 103
        LEADING_ZERO_BITS_64  = 104
        LEADING_ZERO_BITS_32  = 105
        TRAILING_ZERO_BITS_64 = 106
        TRAILING_ZERO_BITS_32 = 107
        SIGN_EXTEND_8         = 108
        SIGN_EXTEND_16        = 109
        ZERO_EXTEND_16        = 110
        REVERSE_BYTES         = 111
)

// A.5.9. Instructions with Arguments of Two Registers &amp; One Immediate.
const (
        STORE_IND_U8      = 120
        STORE_IND_U16     = 121
        STORE_IND_U32     = 122
        STORE_IND_U64     = 123
        LOAD_IND_U8       = 124
        LOAD_IND_I8       = 125
        LOAD_IND_U16      = 126
        LOAD_IND_I16      = 127
        LOAD_IND_U32      = 128
        LOAD_IND_I32      = 129
        LOAD_IND_U64      = 130
        ADD_IMM_32        = 131
        AND_IMM           = 132
        XOR_IMM           = 133
        OR_IMM            = 134
        MUL_IMM_32        = 135
        MUL_IMM           = 135
        SET_LT_U_IMM      = 136
        SET_LT_S_IMM      = 137
        SHLO_L_IMM_32     = 138
        SHLO_R_IMM_32     = 139
        SHAR_R_IMM_32     = 140
        NEG_ADD_IMM_32    = 141
        SET_GT_U_IMM      = 142
        SET_GT_S_IMM      = 143
        SHLO_L_IMM_ALT_32 = 144
        SHLO_R_IMM_ALT_32 = 145
        SHAR_R_IMM_ALT_32 = 146
        CMOV_IZ_IMM       = 147
        CMOV_NZ_IMM       = 148
        ADD_IMM_64        = 149
        MUL_IMM_64        = 150
        SHLO_L_IMM_64     = 151
        SHLO_R_IMM_64     = 152
        SHAR_R_IMM_64     = 153
        NEG_ADD_IMM_64    = 154
        SHLO_L_IMM_ALT_64 = 155
        SHLO_R_IMM_ALT_64 = 156
        SHAR_R_IMM_ALT_64 = 157

        // GP-0.5.4 new instructions
        ROT_R_64_IMM     = 158
        ROT_R_64_IMM_ALT = 159
        ROT_R_32_IMM     = 160
        ROT_R_32_IMM_ALT = 161
)

// A.5.11. Instructions with Arguments of Two Registers &amp; One Offset.
const (
        BRANCH_EQ   = 170
        BRANCH_NE   = 171
        BRANCH_LT_U = 172
        BRANCH_LT_S = 173
        BRANCH_GE_U = 174
        BRANCH_GE_S = 175
)

// A.5.12. Instruction with Arguments of Two Registers and Two Immediates.
const (
        LOAD_IMM_JUMP_IND = 180
)

// A.5.13. Instructions with Arguments of Three Registers.
const (
        ADD_32        = 190
        SUB_32        = 191
        MUL_32        = 192
        DIV_U_32      = 193
        DIV_S_32      = 194
        REM_U_32      = 195
        REM_S_32      = 196
        SHLO_L_32     = 197
        SHLO_R_32     = 198
        SHAR_R_32     = 199
        ADD_64        = 200
        SUB_64        = 201
        MUL_64        = 202
        DIV_U_64      = 203
        DIV_S_64      = 204
        REM_U_64      = 205
        REM_S_64      = 206
        SHLO_L_64     = 207
        SHLO_R_64     = 208
        SHAR_R_64     = 209
        AND           = 210
        XOR           = 211
        OR            = 212
        MUL_UPPER_S_S = 213
        MUL_UPPER_U_U = 214
        MUL_UPPER_S_U = 215
        SET_LT_U      = 216
        SET_LT_S      = 217
        CMOV_IZ       = 218
        CMOV_NZ       = 219

        // GP-0.5.4 new instructions
        ROT_L_64 = 220
        ROT_L_32 = 221
        ROT_R_64 = 222
        ROT_R_32 = 223
        AND_INV  = 224
        OR_INV   = 225
        XNOR     = 226
        MAX      = 227
        MAX_U    = 228
        MIN      = 229
        MIN_U    = 230
)

// Termination Instructions
var T = map[int]struct{}{
        TRAP:            {},
        FALLTHROUGH:     {},
        JUMP:            {},
        JUMP_IND:        {},
        LOAD_IMM_JUMP:   {},
        BRANCH_EQ_IMM:   {},
        BRANCH_NE_IMM:   {},
        BRANCH_LT_U_IMM: {},
        BRANCH_LE_U_IMM: {},
        BRANCH_GE_U_IMM: {},
        BRANCH_GT_U_IMM: {},
        BRANCH_LT_S_IMM: {},
        BRANCH_LE_S_IMM: {},
        BRANCH_GE_S_IMM: {},
        BRANCH_GT_S_IMM: {},
        BRANCH_EQ:       {},
        BRANCH_NE:       {},
        BRANCH_LT_U:     {},
        BRANCH_LT_S:     {},
        BRANCH_GE_U:     {},
        BRANCH_GE_S:     {},
}

const (
        NONE = (1 &lt;&lt; 64) - 1  // 2^32 - 1
        WHAT = (1 &lt;&lt; 64) - 2  // 2^32 - 2
        OOB  = (1 &lt;&lt; 64) - 3  // 2^32 - 3
        WHO  = (1 &lt;&lt; 64) - 4  // 2^32 - 4
        FULL = (1 &lt;&lt; 64) - 5  // 2^32 - 5
        CORE = (1 &lt;&lt; 64) - 6  // 2^32 - 6
        CASH = (1 &lt;&lt; 64) - 7  // 2^32 - 7
        LOW  = (1 &lt;&lt; 64) - 8  // 2^32 - 8
        HIGH = (1 &lt;&lt; 64) - 9  // 2^32 - 9
        HUH  = (1 &lt;&lt; 64) - 10 // 2^32 - 10
        OK   = 0              // 0

        HALT  = 0 // regular halt ∎
        PANIC = 1 // panic ☇
        FAULT = 2 // out-of-gas ∞
        HOST  = 3 // host-call̵ h
        OOG   = 4 // page-fault F

// BAD = 1111
// S   = 2222
// BIG = 3333
)

func extractBytes(input []byte) ([]byte, []byte) <span class="cov8" title="1">{
        /*
                In GP_0.36 (272):
                If the input value of (272) is large, "l" will also increase and vice versa.
                "l" is than be used to encode first byte and the reaming "l" bytes.
                If the first byte is large, that means the number of the entire encoded bytes is large and vice versa.
                So the first byte can be used to determine the number of bytes to extract and the rule is as follows:
        */

        if len(input) == 0 </span><span class="cov0" title="0">{
                return nil, input
        }</span>

        <span class="cov8" title="1">firstByte := input[0]
        var numBytes int

        // Determine the number of bytes to extract based on the value of the 0th byte.
        switch </span>{
        case firstByte &gt;= 1 &amp;&amp; firstByte &lt; 128:<span class="cov8" title="1">
                numBytes = 1</span>
        case firstByte &gt;= 128 &amp;&amp; firstByte &lt; 192:<span class="cov0" title="0">
                numBytes = 2</span>
        case firstByte &gt;= 192 &amp;&amp; firstByte &lt; 224:<span class="cov0" title="0">
                numBytes = 3</span>
        case firstByte &gt;= 224 &amp;&amp; firstByte &lt; 240:<span class="cov0" title="0">
                numBytes = 4</span>
        case firstByte &gt;= 240 &amp;&amp; firstByte &lt; 248:<span class="cov0" title="0">
                numBytes = 5</span>
        case firstByte &gt;= 248 &amp;&amp; firstByte &lt; 252:<span class="cov0" title="0">
                numBytes = 6</span>
        case firstByte &gt;= 252 &amp;&amp; firstByte &lt; 254:<span class="cov0" title="0">
                numBytes = 7</span>
        case firstByte &gt;= 254:<span class="cov0" title="0">
                numBytes = 8</span>
        default:<span class="cov8" title="1">
                numBytes = 1</span>
        }

        // If the input length is insufficient to extract the specified number of bytes, return the original input.
        <span class="cov8" title="1">if len(input) &lt; numBytes </span><span class="cov0" title="0">{
                return input, nil
        }</span>

        // Extract the specified number of bytes and return the remaining bytes.
        <span class="cov8" title="1">extracted := input[:numBytes]
        remaining := input[numBytes:]

        return extracted, remaining</span>
}

func reverseString(s string) string <span class="cov8" title="1">{
        runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov8" title="1">return string(runes)</span>
}

func binaryStringToByte(binaryStr string) byte <span class="cov0" title="0">{
        var result byte
        for i, bit := range binaryStr </span><span class="cov0" title="0">{
                if bit == '1' </span><span class="cov0" title="0">{
                        result |= 1 &lt;&lt; (len(binaryStr) - 1 - i)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func EncodeProgram(p *Program) []byte <span class="cov0" title="0">{
        // Encode the program
        encoded := make([]byte, 0)

        encodedJSize := types.E(p.JSize)
        encoded = append(encoded, encodedJSize...)

        encodedZ := types.E_l(uint64(p.Z), 1)
        encoded = append(encoded, encodedZ...)

        encodedCSize := types.E(p.CSize)
        encoded = append(encoded, encodedCSize...)
        for _, j := range p.J </span><span class="cov0" title="0">{
                encodedj := types.E_l(uint64(j), uint32(p.Z))
                encoded = append(encoded, encodedj...)
        }</span>
        <span class="cov0" title="0">encoded = append(encoded, p.Code...)

        var k_bytes []byte
        for i := 0; i &lt; len(p.K[0]); i += 8 </span><span class="cov0" title="0">{
                end := i + 8
                if end &gt; len(p.K[0]) </span><span class="cov0" title="0">{
                        end = len(p.K[0])
                }</span>
                <span class="cov0" title="0">group := p.K[0][i:end]
                reversedGroup := reverseString(group)
                if len(reversedGroup) &lt; 8 </span><span class="cov0" title="0">{
                        reversedGroup = strings.Repeat("1", 8-len(reversedGroup)) + reversedGroup
                }</span>

                <span class="cov0" title="0">byteValue := binaryStringToByte(reversedGroup)
                k_bytes = append(k_bytes, byteValue)</span>
        }
        <span class="cov0" title="0">encoded = append(encoded, k_bytes...)
        encoded = append(encoded, []byte{0}...)
        return encoded</span>
}

func DecodeProgram(p []byte) (*Program, uint32, uint32, uint32, uint32, []byte, []byte) <span class="cov0" title="0">{
        // Check if the program include ascii byte code
        var pure_code []byte
        pure_code = p

        // extract standard program information
        o_size_byte := pure_code[:3]
        o_size := types.DecodeE_l(o_size_byte)
        w_size_byte := pure_code[3:6]
        w_size := types.DecodeE_l(w_size_byte)
        standard_z_byte := pure_code[6:8]
        standard_s_byte := pure_code[8:11]
        var o_byte []byte
        if 11+o_size &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                o_byte = make([]byte, o_size)
        }</span> else<span class="cov0" title="0"> {
                o_byte = pure_code[11 : 11+o_size]
        }</span>
        <span class="cov0" title="0">var w_byte []byte
        if 11+o_size+w_size &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                w_byte = make([]byte, w_size)
        }</span> else<span class="cov0" title="0"> {
                w_byte = pure_code[11+o_size : 11+o_size+w_size]
        }</span>
        <span class="cov0" title="0">var standard_c_size_byte []byte
        if 11+o_size+w_size+4 &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                standard_c_size_byte = pure_code[11+0+0 : 11+0+0+4]
                pure_code = pure_code[11+0+0+4:]
        }</span> else<span class="cov0" title="0"> {
                standard_c_size_byte = pure_code[11+o_size+w_size : 11+o_size+w_size+4]
                pure_code = pure_code[11+o_size+w_size+4:]
        }</span>

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("OSIZE=%d\n", o_size)
                fmt.Printf("WSIZE=%d\n", w_size)
                fmt.Printf("Z=%d\n", types.DecodeE_l(standard_z_byte))
                fmt.Printf("S=%d\n", types.DecodeE_l(standard_s_byte))
                fmt.Printf("O=%v\n", o_byte)
                fmt.Printf("W=%v\n", w_byte)
                fmt.Printf("Code and Jump Table size: %d\n", types.DecodeE_l(standard_c_size_byte))
        }</span>
        <span class="cov0" title="0">var j_size_byte, z_byte, c_size_byte []byte
        j_size_byte, pure_code = extractBytes(pure_code)
        z_byte, pure_code = extractBytes(pure_code)
        c_size_byte, pure_code = extractBytes(pure_code)
        j_size, _ := types.DecodeE(j_size_byte)
        z, _ := types.DecodeE(z_byte)
        c_size, _ := types.DecodeE(c_size_byte)
        j_byte := pure_code[:j_size*z]
        c_byte := pure_code[j_size*z : j_size*z+c_size]
        k_bytes := pure_code[j_size*z+c_size:]
        var kCombined string
        for _, b := range k_bytes </span><span class="cov0" title="0">{
                binaryStr := fmt.Sprintf("%08b", b)
                kCombined += reverseString(binaryStr)
        }</span>
        <span class="cov0" title="0">if len(kCombined) &gt; int(c_size) </span><span class="cov0" title="0">{
                kCombined = kCombined[:int(c_size)]
        }</span>
        // process j_array
        <span class="cov0" title="0">var j_array []uint32
        for i := uint64(0); i &lt; uint64(len(j_byte)); i += z </span><span class="cov0" title="0">{
                end := i + z
                if end &gt; uint64(len(j_byte)) </span><span class="cov0" title="0">{
                        end = uint64(len(j_byte))
                }</span>
                <span class="cov0" title="0">slice := j_byte[i:end]
                decodedValue := types.DecodeE_l(slice)
                j_array = append(j_array, uint32(decodedValue))</span>
        }

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("JSize=%d\n", j_size)
                fmt.Printf("Z=%d\n", z)
                fmt.Printf("CSize=%d\n", c_size)
                fmt.Println("Jump Table: ", j_array)
                fmt.Printf("Code: %x\n", c_byte)
                fmt.Printf("K(bitmask): %v\n", kCombined)
                fmt.Println("================================================================")
        }</span>
        <span class="cov0" title="0">program := &amp;Program{
                JSize: j_size,
                Z:     uint8(z),
                CSize: c_size,
                J:     j_array,
                Code:  c_byte,
                K:     []string{kCombined},
        }
        return program, uint32(o_size), uint32(w_size), uint32(types.DecodeE_l(standard_z_byte)), uint32(types.DecodeE_l(standard_s_byte)), o_byte, w_byte</span>

}

func DecodeProgram_pure_pvm_blob(p []byte) *Program <span class="cov8" title="1">{
        var pure_code []byte
        pure_code = p

        var j_size_byte, z_byte, c_size_byte []byte
        j_size_byte, pure_code = extractBytes(pure_code)
        z_byte, pure_code = extractBytes(pure_code)
        c_size_byte, pure_code = extractBytes(pure_code)
        j_size, _ := types.DecodeE(j_size_byte)
        z, _ := types.DecodeE(z_byte)
        c_size, _ := types.DecodeE(c_size_byte)
        j_byte := pure_code[:j_size*z]
        c_byte := pure_code[j_size*z : j_size*z+c_size]
        k_bytes := pure_code[j_size*z+c_size:]
        var kCombined string
        for _, b := range k_bytes </span><span class="cov8" title="1">{
                binaryStr := fmt.Sprintf("%08b", b)
                kCombined += reverseString(binaryStr)
        }</span>
        <span class="cov8" title="1">if len(kCombined) &gt; int(c_size) </span><span class="cov8" title="1">{
                kCombined = kCombined[:int(c_size)]
        }</span>
        // process j_array
        <span class="cov8" title="1">var j_array []uint32
        for i := uint64(0); i &lt; uint64(len(j_byte)); i += z </span><span class="cov0" title="0">{
                end := i + z
                if end &gt; uint64(len(j_byte)) </span><span class="cov0" title="0">{
                        end = uint64(len(j_byte))
                }</span>
                <span class="cov0" title="0">slice := j_byte[i:end]
                decodedValue := types.DecodeE_l(slice)
                j_array = append(j_array, uint32(decodedValue))</span>
        }

        <span class="cov8" title="1">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("JSize=%d\n", j_size)
                fmt.Printf("Z=%d\n", z)
                fmt.Printf("CSize=%d\n", c_size)
                fmt.Println("Jump Table: ", j_array)
                fmt.Printf("Code: %x\n", c_byte)
                fmt.Printf("K(bitmask): %v\n", kCombined)
                fmt.Println("================================================================")
        }</span>
        <span class="cov8" title="1">program := &amp;Program{
                JSize: j_size,
                Z:     uint8(z),
                CSize: c_size,
                J:     j_array,
                Code:  c_byte,
                K:     []string{kCombined},
        }
        return program</span>

}

func Floor(x int64) int64 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return x - 1
        }</span>
        <span class="cov0" title="0">return x</span>
}

func CelingDevide(a, b uint32) uint32 <span class="cov0" title="0">{
        return (a + b - 1) / b
}</span>

func P_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_P * CelingDevide(x, Z_P)
}</span>

func Q_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_Q * CelingDevide(x, Z_Q)
}</span>

func Z_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_Z * CelingDevide(x, Z_Z)
}</span>

func Standard_Program_Initialization(vm *VM, argument_data_a []byte) <span class="cov0" title="0">{
        // Standard Program Initialization
        // check condition for standard program GP-0.4.0 (261))
        if len(argument_data_a) == 0 </span><span class="cov0" title="0">{
                argument_data_a = []byte{0}
        }</span>
        <span class="cov0" title="0">condition := uint64(5*Z_Z+Q_func(vm.o_size)+Q_func(vm.w_size+vm.z*Z_P)+Q_func(vm.s)+Z_I) &lt;= uint64((1 &lt;&lt; 32))
        if condition </span><span class="cov0" title="0">{
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Standard Program Initialization...")
                }</span>
                // set up the initial values and access mode for the RAM
                <span class="cov0" title="0">var page_index, page_length uint32
                var access_mode AccessMode

                page_index = (Z_Z + vm.o_size) / PageSize
                page_length = CelingDevide((P_func(vm.o_size) - vm.o_size), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("1. Set Page Index %d and Page Length %d with Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = (2*Z_Z + Z_func(vm.o_size)) / PageSize
                page_length = CelingDevide(vm.w_size, PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("2. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(2*Z_Z+Z_func(vm.o_size), vm.w_byte)

                page_index = (2*Z_Z + Z_func(vm.o_size) + vm.w_size) / PageSize
                page_length = CelingDevide(P_func(vm.w_size)+vm.z*Z_P-vm.w_size, PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("3. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = ((1 &lt;&lt; 32) - 2*Z_Z - Z_I - P_func(vm.s)) / PageSize
                page_length = CelingDevide(P_func(vm.s), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("4. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = ((1 &lt;&lt; 32) - Z_Z - Z_I) / PageSize
                page_length = CelingDevide(uint32(len(argument_data_a)), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("5. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes((1&lt;&lt;32)-Z_Z-Z_I, argument_data_a)

                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)

                page_index = ((1 &lt;&lt; 32) - Z_Z - Z_I + uint32(len(argument_data_a))) / PageSize
                page_length = CelingDevide(P_func(uint32(len(argument_data_a)))-uint32(len(argument_data_a)), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("6. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                // set up the initial values for the registers
                <span class="cov0" title="0">vm.WriteRegister(0, (1&lt;&lt;32)-(1&lt;&lt;16))
                vm.WriteRegister(1, (1&lt;&lt;32)-2*Z_Z-Z_I)
                vm.WriteRegister(7, (1&lt;&lt;32)-Z_Z-Z_I)
                vm.WriteRegister(8, uint64(len(argument_data_a)))</span>
        } else<span class="cov0" title="0"> {
                panic("Standard Program Initialization Error\n")</span>
        }
}

// NewVM initializes a new VM with a given program
func NewVM(service_index uint32, code []byte, initialRegs []uint64, initialPC uint64, hostENV types.HostEnv, jam_ready_blob bool) *VM <span class="cov0" title="0">{
        if len(code) == 0 </span><span class="cov0" title="0">{
                panic("NO CODE\n")</span>
        }
        <span class="cov0" title="0">var p *Program
        var o_size, w_size, z, s uint32
        var o_byte, w_byte []byte

        if jam_ready_blob </span><span class="cov0" title="0">{
                p, o_size, w_size, z, s, o_byte, w_byte = DecodeProgram(code)
        }</span> else<span class="cov0" title="0"> {
                p = DecodeProgram_pure_pvm_blob(code)
                o_size = 0
                w_size = 0
                z = 0
                s = 0
                o_byte = []byte{}
                w_byte = []byte{}
        }</span>

        // TODO: William - initialize RAM "a" @ 0xFEFF0000 (2^32 - Z_Q - Z_I) based on entrypoint:
        //  Refine a = E(s, y, p, c, a, o, x bar ...) Eq 271
        //  Accumulate a = E(o) Eq 275
        //  IsAuthorized - E(p,c) Eq 268
        //  Transfer - E(t) Eq 282
        <span class="cov0" title="0">vm := &amp;VM{
                Gas:           int64(1 &lt;&lt; 62),
                JSize:         p.JSize,
                Z:             p.Z,
                J:             p.J,
                code:          p.Code,
                bitmask:       p.K[0], // pass in bitmask K
                register:      make([]uint64, regSize),
                pc:            initialPC,
                Ram:           NewRAM(),
                hostenv:       hostENV, //check if we need this
                Exports:       make([][]byte, 0),
                Service_index: service_index,
                o_size:        o_size,
                w_size:        w_size,
                z:             z,
                s:             s,
                o_byte:        o_byte,
                w_byte:        w_byte,
        }
        // for _, pg := range pages {
        //         vm.writeRAMBytes(pg.Address, pg.Contents)
        // }
        copy(vm.register, initialRegs)
        // Standard Program Initialization
        // Standard_Program_Initialization(vm, []byte{})
        return vm</span>
}

// NewVM with entrypoint and IsMalicious
// func NewVM_With_EntryPoint(service_index uint32, code []byte, initialRegs []uint32, initialPC uint32, pagemap []PageMap, pages []Page, hostENV types.HostEnv, Entrypoint uint32, IsMalicious bool) *VM {
//         if len(code) == 0 {
//                 panic("NO CODE\n")
//         }
//         fmt.Println("Code: ", code)
//         p := DecodeProgram(code)
//         fmt.Printf("Code: %v K(bitmask): %v\n", p.Code, p.K[0])
//         fmt.Println("================================================================")
//         vm := &amp;VM{
//                 JSize:         p.JSize,
//                 Z:             p.Z,
//                 J:             p.J,
//                 code:          p.Code,
//                 bitmask:       p.K[0], // pass in bitmask K
//                 register:      make([]uint32, regSize),
//                 pc:            initialPC,
//                 ram:           make(map[uint32][4096]byte),
//                 hostenv:       hostENV, //check if we need this
//                 Exports:       make([][]byte, 0),
//                 service_index: service_index,
//                 EntryPoint:    Entrypoint,
//                 IsMalicious:   IsMalicious,
//         }
//         // set vm.pc with entrypoint
//         vm.pc = Entrypoint
//         for _, pg := range pages {
//                 vm.writeRAMBytes(pg.Address, pg.Contents)
//         }
//         copy(vm.register, initialRegs)
//         return vm
// }

// func NewVMFromParseProgramTest(code []byte) {
//         p := DecodeProgram(code)
//         fmt.Printf("Code: %v K(bitmask): %v\n", p.Code, p.K[0])
//         fmt.Println("================================================================")
// }

func NewVMFromCode(serviceIndex uint32, code []byte, i uint64, hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        return NewVM(serviceIndex, code, []uint64{}, i, hostENV, true)
}</span>

// func NewVMFromCode_With_EntryPoint(serviceIndex uint32, code []byte, i uint32, hostENV types.HostEnv, Entrypoint uint32, IsMalicious bool) *VM {
//         return NewVM_With_EntryPoint(serviceIndex, code, []uint32{}, i, []PageMap{}, []Page{}, hostENV, Entrypoint, IsMalicious)
// }

func NewForceCreateVM(code []byte, bitmask string, hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        return &amp;VM{
                code:    code,
                bitmask: bitmask,
                hostenv: hostENV,
        }
}</span>

func NewVMFortest(hostENV types.HostEnv) *VM <span class="cov8" title="1">{
        return &amp;VM{
                register: make([]uint64, regSize),
                hostenv:  hostENV,
                Ram:      NewRAM(),
        }
}</span>

func (vm *VM) SetServiceIndex(index uint32) <span class="cov0" title="0">{
        vm.Service_index = index
}</span>

func (vm *VM) GetServiceIndex() uint32 <span class="cov0" title="0">{
        return vm.Service_index
}</span>

func (vm *VM) ExecuteRefine(s uint32, y []byte, workPackageHash common.Hash, codeHash common.Hash, authorizerCodeHash common.Hash, authorization []byte) (r types.Result, res uint64) <span class="cov0" title="0">{
        // TODO: William -- work with Sean on encode/decode of argument inputs here
        // Refine inputs: let a = E(s, y, p, c, a, o, ↕[↕x S x &lt;− x])
        a := common.Uint32ToBytes(s)                 // s - the service index
        a = append(a, y...)                          //  work payload, y,
        a = append(a, workPackageHash.Bytes()...)    // p - work package hash
        a = append(a, codeHash.Bytes()...)           //  c - the prediction of the hash of that service’s code c at the time of reporting,
        a = append(a, authorizerCodeHash.Bytes()...) //
        a = append(a, authorization...)              // authorization
        // a = append(a, common.ConcatenateByteSlices(extrinsicsBlobs)...)
        // vm.setArgumentInputs(a)

        Standard_Program_Initialization(vm, a) // eq 264/265
        vm.Execute(types.EntryPointRefine)
        return vm.getArgumentOutputs()
}</span>

func (vm *VM) ExecuteAccumulate(elements []types.AccumulateOperandElements, X *types.XContext) (r types.Result, res uint64) <span class="cov0" title="0">{
        var arguments []types.AccumulateOperandElements
        a, _ := types.Encode(elements)
        // need to figure out how the encoded elements are used in the PVM
        decoded, _, err := types.Decode(a, reflect.TypeOf(arguments))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">arguments, ok := decoded.([]types.AccumulateOperandElements)
        if !ok </span><span class="cov0" title="0">{
                panic("decoded data is not of type []types.AccumulateOperandElements")</span>
        }
        <span class="cov0" title="0">for _, argument := range arguments </span><span class="cov0" title="0">{ // here I can't understand, why you encode and decode the elements. should use encoded elements directly
                Standard_Program_Initialization(vm, argument.Results.Ok) // eq 264/265
                vm.X = X                                                 //⎩I(u, s), I(u, s)⎫⎭
                vm.Y = X.Clone()
                vm.Execute(types.EntryPointAccumulate) // F ∈ Ω⟨(X, X)⟩
        }</span>
        // fmt.Printf("vm.X.U.D: %v\n", vm.X.U.D)
        // where is the gas being used?
        // return vm.getArgumentOutputs()
        <span class="cov0" title="0">r.Err = vm.ResultCode
        r.Ok = []byte{}
        return r, 0</span>
}
func (vm *VM) ExecuteTransfer(arguments []byte, service_account *types.ServiceAccount) (r types.Result, res uint64) <span class="cov0" title="0">{
        // a = E(t)   take transfer memos t and encode them
        vm.ServiceAccount = service_account

        Standard_Program_Initialization(vm, arguments) // eq 264/265
        vm.Execute(types.EntryPointOnTransfer)
        // return vm.getArgumentOutputs()
        r.Err = vm.ResultCode
        r.Ok = []byte{}
        return r, 0
}</span>

// E(p, c)
func (vm *VM) ExecuteAuthorization(p types.WorkPackage, c uint32) (r types.Result, res uint64) <span class="cov0" title="0">{
        a := p.Bytes()
        a = append(a, common.Uint32ToBytes(c)...)
        // vm.setArgumentInputs(a)
        Standard_Program_Initialization(vm, a) // eq 264/265
        vm.Execute(types.EntryPointOnTransfer)
        return vm.getArgumentOutputs()
}</span>

// Execute runs the program until it terminates
func (vm *VM) Execute(entryPoint int) error <span class="cov8" title="1">{
        vm.terminated = false
        vm.pc = uint64(entryPoint)
        for !vm.terminated </span><span class="cov8" title="1">{
                if err := vm.step(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                // host call invocation
                <span class="cov8" title="1">if vm.hostCall </span><span class="cov8" title="1">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Println("Invocate Host Function: ", vm.host_func_id)
                        }</span>
                        <span class="cov8" title="1">vm.InvokeHostCall(vm.host_func_id)
                        vm.hostCall = false
                        vm.terminated = false</span>
                }
                <span class="cov8" title="1">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("-----------------------------------------------------------------------")
                }</span>
        }
        <span class="cov8" title="1">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Println("last pc: ", vm.pc)
        }</span>
        // if vm finished without error, set result code to OK
        <span class="cov8" title="1">if !vm.terminated </span><span class="cov0" title="0">{
                vm.ResultCode = types.RESULT_OK
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// set ups extrinsics and payload
func (vm *VM) SetExtrinsicsPayload(extrinsics [][]byte, payload []byte) error <span class="cov0" title="0">{
        vm.Extrinsics = extrinsics
        vm.payload = payload
        return nil
}</span>

// set up Imports
func (vm *VM) SetImports(imports [][]byte) error <span class="cov0" title="0">{
        vm.Imports = imports
        return nil
}</span>

// copy a into 2^32 - Z_Q - Z_I and initialize registers
func (vm *VM) setArgumentInputs(a []byte) error <span class="cov0" title="0">{
        vm.WriteRegister(0, 0)
        vm.WriteRegister(1, 0xFFFF0000) // 2^32 - 2^16
        vm.WriteRegister(2, 0xFEFE0000) // 2^32 - 2 * 2^16 - 2^24
        for r := 3; r &lt; 10; r++ </span><span class="cov0" title="0">{
                vm.WriteRegister(r, 0)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(10, 0xFEFF0000) // 2^32 - 2^16 - 2^24
        vm.WriteRegister(11, uint64(len(a)))
        for r := 12; r &lt; 16; r++ </span><span class="cov0" title="0">{
                vm.WriteRegister(r, 0)
        }</span>
        <span class="cov0" title="0">vm.Ram.WriteRAMBytes(0xFEFF0000, a)
        return nil</span>
}

func (vm *VM) getArgumentOutputs() (r types.Result, res uint64) <span class="cov0" title="0">{
        o, _ := vm.ReadRegister(10)
        l, _ := vm.ReadRegister(11)

        output, res := vm.Ram.ReadRAMBytes(uint32(o), uint32(l))
        r.Err = vm.ResultCode
        if r.Err == types.RESULT_OK </span><span class="cov0" title="0">{
                r.Ok = output
        }</span>
        <span class="cov0" title="0">return r, res</span>
}

// step performs a single step in the PVM
func (vm *VM) step() error <span class="cov8" title="1">{
        if vm.pc &gt;= uint64(len(vm.code)) </span><span class="cov8" title="1">{
                return errors.New("program counter out of bounds")
        }</span>

        <span class="cov8" title="1">instr := vm.code[vm.pc]
        opcode := instr
        len_operands := skip(vm.pc, vm.bitmask)
        x := vm.pc + 4
        if x &gt; uint64(len(vm.code)) </span><span class="cov8" title="1">{
                x = uint64(len(vm.code))
        }</span>
        <span class="cov8" title="1">operands := vm.code[vm.pc+1 : vm.pc+1+len_operands]
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("pc: %d opcode: %d - operands: %v, len(operands) = %d\n", vm.pc, opcode, operands, len_operands)
        }</span>
        <span class="cov8" title="1">switch instr </span>{
        case TRAP:<span class="cov8" title="1">
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("TERMINATED\n")
                }</span>
                <span class="cov8" title="1">if instr == TRAP </span><span class="cov8" title="1">{
                        vm.ResultCode = PANIC
                }</span> else<span class="cov0" title="0"> {
                        vm.ResultCode = types.RESULT_OK
                }</span>
                <span class="cov8" title="1">vm.terminated = true</span>
        case FALLTHROUGH:<span class="cov0" title="0">
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("FALLTHROUGH")
                }</span>
                <span class="cov0" title="0">vm.pc += 1</span>
        case JUMP:<span class="cov0" title="0">
                // handle no operand means 0
                originalOperands := make([]byte, len(operands))
                copy(originalOperands, operands)
                lx := min(4, len(originalOperands))
                if lx == 0 </span><span class="cov0" title="0">{
                        lx = 1
                        originalOperands = append(originalOperands, 0)
                }</span>
                <span class="cov0" title="0">vx := z_encode(types.DecodeE_l(originalOperands[0:lx]), uint32(lx))

                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Jump to: ", uint32(int64(vm.pc)+vx))
                }</span>
                <span class="cov0" title="0">vm.branch(uint64(int64(vm.pc)+vx), true)</span>
        case JUMP_IND:<span class="cov0" title="0">
                // handle no operand means 0
                originalOperands := make([]byte, len(operands))
                copy(originalOperands, operands)

                registerIndexA := min(12, int(originalOperands[0])%16)
                lx := min(4, max(0, len(originalOperands))-1)
                if lx == 0 </span><span class="cov0" title="0">{
                        lx = 1
                        originalOperands = append(originalOperands, 0)
                }</span>
                // vx := types.DecodeE_l(originalOperands[1 : 1+lx])
                <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

                valueA, _ := vm.ReadRegister(registerIndexA)
                j := valueA + vx
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Djump to: ", j)
                }</span>
                <span class="cov0" title="0">vm.djump(j % (1 &lt;&lt; 32))</span>
        case LOAD_IMM_JUMP:<span class="cov0" title="0">
                vm.loadImmJump(operands)</span>
        case LOAD_IMM_JUMP_IND:<span class="cov0" title="0">
                vm.loadImmJumpInd(operands)</span>
        case BRANCH_EQ, BRANCH_NE, BRANCH_LT_U, BRANCH_LT_S, BRANCH_GE_U, BRANCH_GE_S:<span class="cov0" title="0">
                vm.branchReg(opcode, operands)</span>
        case BRANCH_EQ_IMM, BRANCH_NE_IMM, BRANCH_LT_U_IMM, BRANCH_LT_S_IMM, BRANCH_LE_U_IMM, BRANCH_LE_S_IMM, BRANCH_GE_U_IMM, BRANCH_GE_S_IMM, BRANCH_GT_U_IMM, BRANCH_GT_S_IMM:<span class="cov0" title="0">
                vm.branchCond(opcode, operands)</span>
        case ECALLI:<span class="cov8" title="1">
                vm.HostResultCode = vm.ecalli(operands)
                vm.pc += 1 + len_operands</span>
                // if vm.HostResultCode != OK {
                //         vm.terminated = true
                // }
        case STORE_IMM_U8, STORE_IMM_U16, STORE_IMM_U32, STORE_IMM_U64:<span class="cov0" title="0">
                vm.storeImm(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case LOAD_IMM:<span class="cov0" title="0">
                vm.loadImm(operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case LOAD_U8, LOAD_U16, LOAD_U32, LOAD_U64, LOAD_I8, LOAD_I16, LOAD_I32:<span class="cov0" title="0">
                vm.load(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case STORE_U8, STORE_U16, STORE_U32:<span class="cov8" title="1">
                vm.store(opcode, operands)
                if !vm.terminated </span><span class="cov8" title="1">{
                        vm.pc += 1 + len_operands
                }</span>
        case STORE_IMM_IND_U8, STORE_IMM_IND_U16, STORE_IMM_IND_U32, STORE_IMM_IND_U64:<span class="cov0" title="0">
                vm.storeImmInd(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case STORE_IND_U8, STORE_IND_U16, STORE_IND_U32, STORE_IND_U64:<span class="cov0" title="0">
                vm.storeInd(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case LOAD_IND_U8, LOAD_IND_I8, LOAD_IND_U16, LOAD_IND_I16, LOAD_IND_U32, LOAD_IND_I32, LOAD_IND_U64:<span class="cov0" title="0">
                vm.loadInd(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
                // MUL_UPPER_S_S_IMM, MUL_UPPER_S_S_IMM
        case ADD_IMM_32, AND_IMM, XOR_IMM, OR_IMM, MUL_IMM, SET_LT_U_IMM, SET_LT_S_IMM:<span class="cov0" title="0">
                vm.aluImm(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case CMOV_IZ_IMM, CMOV_NZ_IMM:<span class="cov0" title="0">
                vm.cmovImm(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case SHLO_R_IMM_32, SHLO_L_IMM_32, SHAR_R_IMM_32, NEG_ADD_IMM_32, SET_GT_U_IMM, SET_GT_S_IMM, SHLO_R_IMM_ALT_32, SHLO_L_IMM_ALT_32, SHAR_R_IMM_ALT_32, SHAR_R_IMM_64, SHAR_R_IMM_ALT_64:<span class="cov0" title="0">
                vm.shiftImm(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case ADD_32, ADD_64, SUB_32, SUB_64, AND, XOR, OR, MUL_32, MUL_64, MUL_UPPER_S_S, MUL_UPPER_U_U, MUL_UPPER_S_U, DIV_U_32, DIV_U_64, DIV_S_32, DIV_S_64, REM_U_32, REM_U_64, REM_S_32, REM_S_64, CMOV_IZ, CMOV_NZ, SHLO_L_32, SHLO_L_64, SHLO_R_32, SHLO_R_64, SHAR_R_32, SHAR_R_64, SET_LT_U, SET_LT_S, ROT_L_64, ROT_L_32, ROT_R_64, ROT_R_32, AND_INV, OR_INV, XNOR, MAX, MAX_U, MIN, MIN_U:<span class="cov0" title="0">
                vm.aluReg(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case MOVE_REG:<span class="cov0" title="0">
                vm.moveReg(operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case SBRK:<span class="cov0" title="0">
                vm.sbrk(operands)
                break</span>
        // New opcodes
        case LOAD_IMM_64:<span class="cov0" title="0">
                vm.Instructions_with_Arguments_of_One_Register_and_One_Extended_Width_Immediate(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case ADD_IMM_64, SHLO_L_IMM_64, SHLO_R_IMM_64:<span class="cov0" title="0">
                vm.Instructions_with_Arguments_of_Two_Registers_and_One_Immediate(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        case COUNT_SET_BITS_64, COUNT_SET_BITS_32, LEADING_ZERO_BITS_64, LEADING_ZERO_BITS_32, TRAILING_ZERO_BITS_64, TRAILING_ZERO_BITS_32, SIGN_EXTEND_8, SIGN_EXTEND_16, ZERO_EXTEND_16, REVERSE_BYTES:<span class="cov0" title="0">
                vm.Instructions_with_Arguments_of_Two_Register(opcode, operands)
                if !vm.terminated </span><span class="cov0" title="0">{
                        vm.pc += 1 + len_operands
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("Unknown opcode: %d\n", opcode)
                        fmt.Printf("----\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        //vm.pc += 1 + uint32(skip(opcode))

        <span class="cov8" title="1">return nil</span>
}

func reverseBytes(b []byte) []byte <span class="cov0" title="0">{
        n := len(b)
        for i := 0; i &lt; n/2; i++ </span><span class="cov0" title="0">{
                b[i], b[n-1-i] = b[n-1-i], b[i]
        }</span>
        <span class="cov0" title="0">return b</span>
}

// skip calculates the skip distance based on the opcode
// func skip(opcode byte) uint32 {
//         switch opcode {
//         case JUMP, LOAD_IMM_JUMP, LOAD_IMM_JUMP_IND:
//                 return uint32(1)
//         case BRANCH_EQ, BRANCH_NE, BRANCH_GE_U, BRANCH_GE_S, BRANCH_LT_U, BRANCH_LT_S:
//                 return uint32(2)
//         case BRANCH_EQ_IMM, BRANCH_NE_IMM, BRANCH_LT_U_IMM, BRANCH_LT_S_IMM, BRANCH_LE_U_IMM, BRANCH_LE_S_IMM, BRANCH_GE_U_IMM, BRANCH_GE_S_IMM, BRANCH_GT_U_IMM, BRANCH_GT_S_IMM:
//                 return uint32(3)
//         default:
//                 return uint32(0)
//         }
// }

// skip function calculates the distance to the next instruction
func skip(pc uint64, bitmask string) uint64 <span class="cov8" title="1">{
        // Convert the bitmask string to a slice of bytes
        bitmaskBytes := []byte(bitmask)

        // Iterate through the bitmask starting from the given pc position
        var i uint64
        for i = pc + 1; i &lt; pc+25 &amp;&amp; i &lt; uint64(len(bitmaskBytes)); i++ </span><span class="cov8" title="1">{
                // Ensure we do not access out of bounds
                if bitmaskBytes[i] == '1' </span><span class="cov0" title="0">{
                        return i - pc - 1
                }</span>
        }
        // If no '1' is found within the next 24 positions, check the last index
        <span class="cov8" title="1">if i &lt; pc+25 </span><span class="cov8" title="1">{
                return i - pc - 1
        }</span>
        <span class="cov0" title="0">return uint64(24)</span>
}

func (vm *VM) get_varpi(opcodes []byte, bitmask string) map[int]struct{} <span class="cov0" title="0">{
        result := make(map[int]struct{})
        for i, opcode := range opcodes </span><span class="cov0" title="0">{
                if bitmask[i] == '1' </span><span class="cov0" title="0">{
                        if _, exists := T[int(opcode)]; exists </span><span class="cov0" title="0">{
                                result[int(opcode)] = struct{}{}
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

func (vm *VM) djump(a uint64) <span class="cov0" title="0">{
        if a == uint64((1&lt;&lt;32)-(1&lt;&lt;16)) </span><span class="cov0" title="0">{
                vm.terminated = true
                vm.ResultCode = HALT
        }</span> else<span class="cov0" title="0"> if a == 0 || a &gt; uint64(len(vm.J)*Z_A) || a%Z_A != 0 </span><span class="cov0" title="0">{
                vm.terminated = true
                vm.ResultCode = PANIC
                // panic("OOB")
        }</span> else<span class="cov0" title="0"> {
                vm.pc = uint64(vm.J[(a/Z_A)-1])
        }</span>
}

func (vm *VM) ReadRegister(index int) (uint64, uint64) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(vm.register) </span><span class="cov0" title="0">{
                return 0, OOB
        }</span>
        // fmt.Printf(" REGISTERS %v (index=%d =&gt; %d)\n", vm.register, index, vm.register[index])
        <span class="cov8" title="1">return vm.register[index], OK</span>
}

func (vm *VM) WriteRegister(index int, value uint64) uint64 <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(vm.register) </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov8" title="1">vm.register[index] = value
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("Register[%d] = %d\n", index, value)
        }</span>
        <span class="cov8" title="1">return OK</span>
}

func (vm *VM) ReadRegisters() []uint64 <span class="cov8" title="1">{
        return vm.register
}</span>

// Implement the dynamic jump logic
func (vm *VM) dynamicJump(operands []byte) uint64 <span class="cov0" title="0">{
        if len(operands) != 1 </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">a := int(operands[0])
        const ZA = 4

        if a == 0 || a &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">targetIndex := uint64(a/ZA - 1)
        if targetIndex &gt;= uint64(len(vm.code)) </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">vm.pc = targetIndex
        return OK</span>
}

// Implement ecall logic
func (vm *VM) ecalli(operands []byte) uint64 <span class="cov8" title="1">{
        // Implement ecalli logic here
        lx := uint32(types.DecodeE_l(operands))
        vm.hostCall = true
        vm.host_func_id = int(lx)
        vm.ResultCode = HOST
        return HOST
}</span>

// Implement storeImm logic
func (vm *VM) storeImm(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        lx := min(4, int(originalOperands[0])%8)
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly))

        switch opcode </span>{
        case STORE_IMM_U8:<span class="cov0" title="0">
                value := vy % (1 &lt;&lt; 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U8: %d %v\n", vx, []byte{byte(value)})
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), []byte{byte(value)})</span>
        case STORE_IMM_U16:<span class="cov0" title="0">
                value := types.E_l(uint64(vy%(1&lt;&lt;16)), 2)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        case STORE_IMM_U32:<span class="cov0" title="0">
                value := types.E_l(uint64(vy), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        case STORE_IMM_U64:<span class="cov0" title="0">
                // TODO: NEW - check this
                value := types.E_l(uint64(vy), 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U64: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        }

        <span class="cov0" title="0">return OOB</span>
}

// load_imm (opcode 4)
func (vm *VM) loadImm(operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vm.WriteRegister(registerIndexA, uint64(vx))</span>
}

// LOAD_U8, LOAD_U16, LOAD_U32, LOAD_U64, LOAD_I8, LOAD_I16, LOAD_I32
func (vm *VM) load(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case LOAD_U8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes((uint32(vx)), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U8: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, uint64(value[0]))</span>
        case LOAD_I8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes((uint32(vx)), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_I8: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, x_encode(uint64(value[0]), 1))</span>
        case LOAD_U16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, types.DecodeE_l(value))</span>
        case LOAD_I16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_I16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, x_encode(types.DecodeE_l(value), 2))</span>
        case LOAD_U32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, types.DecodeE_l(value))</span>
        case LOAD_I32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_I32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, x_encode(types.DecodeE_l(value), 4))</span>
        case LOAD_U64:<span class="cov0" title="0"> // TODO: NEW, check this
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U64: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, types.DecodeE_l(value))</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
}

// STORE_U8, STORE_U16, STORE_U32
func (vm *VM) store(opcode byte, operands []byte) <span class="cov8" title="1">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        valueA, _ := vm.ReadRegister(registerIndexA)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov8" title="1">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case STORE_U8:<span class="cov0" title="0">
                value := valueA % (1 &lt;&lt; 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_u8: %d %v\n", vx, []byte{byte(value)})
                }</span>
                <span class="cov0" title="0">errCode := vm.Ram.WriteRAMBytes(uint32(vx), []byte{byte(value)})
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_U16:<span class="cov0" title="0">
                value := types.E_l(uint64(valueA%(1&lt;&lt;16)), 2)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">errCode := vm.Ram.WriteRAMBytes(uint32(vx), value)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_U32:<span class="cov8" title="1">
                value := types.E_l(uint64(valueA), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov8" title="1">errCode := vm.Ram.WriteRAMBytes(uint32(vx), value)
                if errCode != OK </span><span class="cov8" title="1">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
}

// storeImmInd implements STORE_IMM_{U8, U16, U32}
func (vm *VM) storeImmInd(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0])/16)%8)
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, _ := vm.ReadRegister(registerIndexA)

        vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly))

        switch opcode </span>{
        case STORE_IMM_IND_U8:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U8: %d %v\n", valueA+vx, []byte{byte(vy % 8)})
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), []byte{byte(vy % 8)})
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IMM_IND_U16:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U16: %d %v\n", valueA+vx, types.E_l(uint64(vy%1&lt;&lt;16), 2))
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy%1&lt;&lt;16), 2))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IMM_IND_U32:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U32: %d %v\n", valueA+vx, types.E_l(uint64(vy), 4))
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy), 4))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IMM_IND_U64:<span class="cov0" title="0">
                errCode := vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy), 8))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
}

// Implement loadImmJump logic
func (vm *VM) loadImmJump(operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0]) / 16 % 8))
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := uint64(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly)))

        vm.WriteRegister(registerIndexA, uint64(vx))

        vm.branch(vy, true)</span>
}

// Implement loadImmJumpInd logic
func (vm *VM) loadImmJumpInd(operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, (int(originalOperands[1]) % 8))
        ly := min(4, max(0, len(originalOperands)-lx-2))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[2:2+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[2+lx:2+lx+ly]), uint32(ly))

        valueB, _ := vm.ReadRegister(registerIndexB)

        vm.WriteRegister(registerIndexA, uint64(vx))
        vm.djump((valueB + vy) % (1 &lt;&lt; 32))</span>
}

// move_reg (opcode 82)
func (vm *VM) moveReg(operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexD := min(12, int(originalOperands[0])%16)
        registerIndexA := min(12, int(originalOperands[0])/16)

        valueA, _ := vm.ReadRegister(registerIndexA)
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("MOVE_REG: %d %d\n", registerIndexA, registerIndexD)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(registerIndexD, valueA)</span>
}

func (vm *VM) sbrk(operands []byte) error <span class="cov0" title="0">{
        // TODO
        fmt.Printf("sbrk not implemented -- operands %v", operands)
        /*        srcIndex, destIndex := splitRegister(operands[0])

                amount := int(operands[0])
                newRAM := make([]byte, len(vm.ram)+amount)
                copy(newRAM, vm.ram)
                vm.ram = newRAM */
        return nil
}</span>

func (vm *VM) branch(vx uint64, condition bool) <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                vm.pc = vx
        }</span> else<span class="cov0" title="0"> {
                vm.ResultCode = PANIC
                vm.terminated = true
        }</span>
}

func (vm *VM) branchCond(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0]) / 16 % 8))
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := uint64(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly)))

        valueA, _ := vm.ReadRegister(registerIndexA)

        switch opcode </span>{
        case BRANCH_EQ_IMM:<span class="cov0" title="0">
                if valueA == uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_EQ_IMM: %d, valueA=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_NE_IMM:<span class="cov0" title="0">
                if valueA != uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_NE_IMM: %d, valueA!=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LT_U_IMM:<span class="cov0" title="0">
                if valueA &lt; uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LT_U_IMM: %d, valueA&lt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt; z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LT_S_IMM: %d, valueA&lt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LE_U_IMM:<span class="cov0" title="0">
                if valueA &lt;= uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LE_U_IMM: %d, valueA&lt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LE_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt;= z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LE_S_IMM: %d, valueA&lt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GE_U_IMM:<span class="cov0" title="0">
                if valueA &gt;= uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GE_U_IMM: %d, valueA&gt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GE_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt;= z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GE_S_IMM: %d, valueA&gt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GT_U_IMM:<span class="cov0" title="0">
                if valueA &gt; uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GT_U_IMM: %d, valueA&gt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt; z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GT_S_IMM: %d, valueA&gt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        }
}

func (vm *VM) storeInd(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, _ := vm.ReadRegister(registerIndexA)
        valueB, _ := vm.ReadRegister(registerIndexB)

        vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case STORE_IND_U8:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U8: %d %v\n", valueB+vx, []byte{byte(valueA % 8)})
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), []byte{byte(valueA % 8)})
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IND_U16:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U16: %d %v\n", valueB+vx, types.E_l(uint64(valueA%1&lt;&lt;16), 2))
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 2))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IND_U32:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U32: %d %v\n", valueB+vx, types.E_l(uint64(valueA), 4))
                // }
                errCode := vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 4))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        case STORE_IND_U64:<span class="cov0" title="0">
                errCode := vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 8))
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }

}

func (vm *VM) loadInd(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueB, _ := vm.ReadRegister(registerIndexB)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        switch opcode </span>{
        case LOAD_IND_U8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := uint64(value[0])
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U8: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := uint64(z_decode(z_encode(uint64(value[0]), 1), 8))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_I8: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U16: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := z_decode(z_encode(types.DecodeE_l(value), 2), 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_I16: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U32: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := z_decode(z_encode(types.DecodeE_l(value), 4), 8)
                vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U64:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.ResultCode = FAULT
                        vm.terminated = true
                        vm.Fault_address = uint32(errCode)
                        return
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                vm.WriteRegister(registerIndexA, result)</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
}

func splitRegister(operand byte) (int, int) <span class="cov0" title="0">{
        registerIndexA := int(operand &amp; 0xF)
        registerIndexB := int((operand &gt;&gt; 4) &amp; 0xF)
        return registerIndexA, registerIndexB
}</span>

// Implement ALU operations with immediate values
func (vm *VM) aluImm(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueB, _ := vm.ReadRegister(registerIndexB)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint64(x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))) // CHECK

        var result uint64
        switch opcode </span>{
        case ADD_IMM_32:<span class="cov0" title="0">
                result = uint64(valueB) + vx</span>
        case AND_IMM:<span class="cov0" title="0">
                result = valueB &amp; vx</span>
        case XOR_IMM:<span class="cov0" title="0">
                result = valueB ^ vx</span>
        case OR_IMM:<span class="cov0" title="0">
                result = valueB | vx</span>
        case MUL_IMM:<span class="cov0" title="0">
                result = valueB * vx</span>
        // case MUL_UPPER_S_S_IMM:
        //         result = uint32(z_decode((z_encode(valueB, 4) * z_encode(vx, 4)), 4))
        // case MUL_UPPER_U_U_IMM:
        //         result = valueB * vx
        case SET_LT_U_IMM:<span class="cov0" title="0">
                if uint32(valueB) &lt; uint32(vx) </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_LT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueB, 4) &lt; z_encode(vx, 4) </span><span class="cov0" title="0">{ // CHECK
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("aluImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
}

// Implement cmov_nz_imm, cmov_nz_imm
func (vm *VM) cmovImm(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueA, _ := vm.ReadRegister(registerIndexA)
        valueB, _ := vm.ReadRegister(registerIndexB)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint64(x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx)))

        var result uint64
        switch opcode </span>{
        case CMOV_IZ_IMM:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = vx
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        case CMOV_NZ_IMM:<span class="cov0" title="0">
                if valueB != 0 </span><span class="cov0" title="0">{
                        result = vx
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("cmovImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
}

// Implement shift operations with immediate values
func (vm *VM) shiftImm(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)

        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        valueB, _ := vm.ReadRegister(registerIndexB)

        var result uint64
        switch opcode </span>{
        case SHLO_R_IMM_32:<span class="cov0" title="0">
                result = x_encode(valueB%(1&lt;&lt;32)/(1&lt;&lt;(vx%32)), 4)</span>
        case SHLO_L_IMM_32:<span class="cov0" title="0">
                result = x_encode(valueB*(1&lt;&lt;(vx%32))%(1&lt;&lt;32), 4)</span>
        case SHAR_R_IMM_32:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueB%(1&lt;&lt;32), 4)/(1&lt;&lt;(vx%32))), 8)</span>
        case NEG_ADD_IMM_32:<span class="cov0" title="0">
                result = x_encode(uint64(vx)+uint64(1&lt;&lt;32)-uint64(valueB)%uint64(1&lt;&lt;32), 4)</span>
        case SET_GT_U_IMM:<span class="cov0" title="0">
                if valueB &gt; vx </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_GT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueB, 8) &gt; z_encode(vx, 8) </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SHLO_L_IMM_ALT_32:<span class="cov0" title="0">
                result = x_encode((vx*(1&lt;&lt;(valueB%32)))%(1&lt;&lt;32), 4)</span>
        case SHLO_R_IMM_ALT_32:<span class="cov0" title="0">
                result = x_encode((vx%(1&lt;&lt;32))/(1&lt;&lt;(valueB%32)), 4)</span>
        case SHAR_R_IMM_ALT_32:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(vx%(1&lt;&lt;32), 4)/(1&lt;&lt;(valueB%32))), 8)</span>
        case SHAR_R_IMM_64:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueB, 8)/(1&lt;&lt;(vx%64))), 8)</span>
        case SHAR_R_IMM_ALT_64:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(vx, 8)/(1&lt;&lt;(valueB%64))), 8)</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("shiftImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
}

// GP.0.5.2-A.7
func z_encode(a uint64, n uint32) int64 <span class="cov0" title="0">{
        modValue := new(big.Int).Lsh(big.NewInt(1), uint(8*n-1))
        bigA := new(big.Int).SetUint64(a)

        if bigA.Cmp(modValue) &lt; 0 </span><span class="cov0" title="0">{
                return bigA.Int64()
        }</span>

        <span class="cov0" title="0">fullMod := new(big.Int).Lsh(big.NewInt(1), uint(8*n))
        result := new(big.Int).Sub(bigA, fullMod)
        return result.Int64()</span>
}

// GP.0.5.2-A.8
func z_decode(a int64, n uint32) uint64 <span class="cov0" title="0">{
        mod := new(big.Int).Lsh(big.NewInt(1), uint(8*n))
        bigA := big.NewInt(a)

        result := new(big.Int).Add(mod, bigA)
        result.Mod(result, mod)

        return result.Uint64()
}</span>

// GP.0.5.4-A.9
func B_encode(n uint64) string <span class="cov0" title="0">{
        return strconv.FormatUint(n, 2)
}</span>

// GP.0.5.4-A.10
func B_decode(s string) uint64 <span class="cov0" title="0">{
        n, _ := strconv.ParseUint(s, 2, 64)
        return n
}</span>

// GP_.0.3.8(224)
func x_encode(x uint64, n uint32) uint64 <span class="cov8" title="1">{
        if n == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        // 1. Calculate 2^(8*n-1)
        <span class="cov8" title="1">modValue := new(big.Int).Lsh(big.NewInt(1), uint(8*n-1))

        // 2. Calculate 2^64 - 2^(8*n)
        two64 := new(big.Int).Lsh(big.NewInt(1), 64)
        two8n := new(big.Int).Lsh(big.NewInt(1), uint(8*n))
        factor := new(big.Int).Sub(two64, two8n)

        // 3. Calculate x / 2^(8*n-1)
        bigX := new(big.Int).SetUint64(x)
        quotient := new(big.Int).Div(bigX, modValue)

        // 4. Calculate x + quotient * factor
        temp := new(big.Int).Mul(quotient, factor)
        result := new(big.Int).Add(bigX, temp)

        // 5. Ensure the result can be returned as uint64
        return result.Uint64()</span>
}

// Implement branch logic for two registers and one offset
func (vm *VM) branchReg(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint64(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx)))

        valueA, _ := vm.ReadRegister(registerIndexA)
        valueB, _ := vm.ReadRegister(registerIndexB)

        switch opcode </span>{
        case BRANCH_EQ:<span class="cov0" title="0">
                if valueA == valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_NE:<span class="cov0" title="0">
                if valueA != valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LT_U:<span class="cov0" title="0">
                if valueA &lt; valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_LT_S:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt; z_encode(valueB, 4) </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GE_U:<span class="cov0" title="0">
                if valueA &gt;= valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        case BRANCH_GE_S:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt;= z_encode(valueB, 4) </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint64(1 + len(operands))
                }</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
}

// Implement ALU operations with register values
func (vm *VM) aluReg(opcode byte, operands []byte) <span class="cov0" title="0">{

        registerIndexA := min(12, int(operands[0])%16)
        registerIndexB := min(12, int(operands[0])/16)
        registerIndexD := min(12, int(operands[1]))

        valueA, _ := vm.ReadRegister(registerIndexA)
        valueB, _ := vm.ReadRegister(registerIndexB)

        var result uint64
        switch opcode </span>{
        case ADD_32, ADD_64:<span class="cov0" title="0">
                // condition on IsMalicious
                if vm.IsMalicious </span><span class="cov0" title="0">{
                        result = valueA * valueB
                }</span> else<span class="cov0" title="0"> {
                        result = valueA + valueB
                }</span>
        case SUB_32, SUB_64:<span class="cov0" title="0">
                result = valueA - valueB</span>
        case AND:<span class="cov0" title="0">
                result = valueA &amp; valueB</span>
        case XOR:<span class="cov0" title="0">
                result = valueA ^ valueB</span>
        case OR:<span class="cov0" title="0">
                result = valueA | valueB</span>
        case MUL_32, MUL_64:<span class="cov0" title="0">
                result = valueA * valueB</span>
        case MUL_UPPER_S_S:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueA, 8)*z_encode(valueB, 8)), 8)</span>
        case MUL_UPPER_U_U:<span class="cov0" title="0">
                result = valueA * valueB</span>
        case MUL_UPPER_S_U:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueA, 8)*int64(valueB)), 8)</span>
        case DIV_U_32:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = ^uint64(0)
                }</span> else<span class="cov0" title="0"> {
                        result = (valueA % (1 &lt;&lt; 32)) / (valueB % (1 &lt;&lt; 32))
                }</span>
        case DIV_U_64:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = ^uint64(0)
                }</span> else<span class="cov0" title="0"> {
                        result = valueA / valueB
                }</span>
        case DIV_S_32:<span class="cov0" title="0">
                S_valueA := z_encode(valueA%(1&lt;&lt;32), 4)
                S_valueB := z_encode(valueB%(1&lt;&lt;32), 4)
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = ^uint64(0)
                }</span> else<span class="cov0" title="0"> if S_valueA == -(1&lt;&lt;31) &amp;&amp; S_valueB == -1 </span><span class="cov0" title="0">{
                        result = uint64(S_valueA)
                }</span> else<span class="cov0" title="0"> {
                        result = z_decode(S_valueA/S_valueB, 8)
                }</span>

        case DIV_S_64:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = ^uint64(0)
                }</span> else<span class="cov0" title="0"> if z_encode(valueA, 8) == -(1&lt;&lt;63) &amp;&amp; z_encode(valueB, 8) == -1 </span><span class="cov0" title="0">{
                        result = uint64(valueA)
                }</span> else<span class="cov0" title="0"> {
                        result = z_decode(Floor(z_encode(valueA, 8)/z_encode(valueB, 8)), 8)
                }</span>

        case REM_U_32:<span class="cov0" title="0">
                if valueB%(1&lt;&lt;32) == 0 </span><span class="cov0" title="0">{
                        result = x_encode(valueA, 4)
                }</span> else<span class="cov0" title="0"> {
                        result = x_encode((valueA%(1&lt;&lt;32))%(valueB%(1&lt;&lt;32)), 4)
                }</span>
        case REM_U_64:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> {
                        result = valueA % valueB
                }</span>
        case REM_S_32:<span class="cov0" title="0">
                S_valueA := z_encode(valueA%(1&lt;&lt;32), 4)
                S_valueB := z_encode(valueB%(1&lt;&lt;32), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf(" REM_S %d %d \n", int32(valueA), int32(valueB))
                }</span>
                <span class="cov0" title="0">if S_valueB == 0 </span><span class="cov0" title="0">{
                        result = z_decode(S_valueA, 8)
                }</span> else<span class="cov0" title="0"> if S_valueA == -(1&lt;&lt;31) &amp;&amp; S_valueB == -1 </span><span class="cov0" title="0">{
                        result = 0
                }</span> else<span class="cov0" title="0"> {
                        result = z_decode(S_valueA%S_valueB, 8)
                }</span>
        case REM_S_64:<span class="cov0" title="0">
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf(" REM_S %d %d \n", int32(valueA), int32(valueB))
                }</span>
                <span class="cov0" title="0">if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> if z_encode(valueA, 8) == -(1&lt;&lt;63) &amp;&amp; z_encode(valueB, 8) == -1 </span><span class="cov0" title="0">{
                        result = 0
                }</span> else<span class="cov0" title="0"> {
                        result = z_decode(z_encode(valueA, 8)%z_encode(valueB, 8), 8)
                }</span>
        case CMOV_IZ:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case CMOV_NZ:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = 0
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        case SET_LT_U:<span class="cov0" title="0">
                if valueA &lt; valueB </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_LT_S:<span class="cov0" title="0">
                if int64(valueA) &lt; int64(valueB) </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>

        case SHLO_L_32:<span class="cov0" title="0">
                result = x_encode(valueA*(1&lt;&lt;(valueB%32))%(1&lt;&lt;32), 4)</span>
        case SHLO_L_64:<span class="cov0" title="0">
                result = valueA * (1 &lt;&lt; (valueB % 64))</span>
        case SHLO_R_32:<span class="cov0" title="0">
                result = x_encode((valueA%(1&lt;&lt;32))/(1&lt;&lt;(valueB%32)), 4)</span>
        case SHLO_R_64:<span class="cov0" title="0">
                result = valueA / (1 &lt;&lt; (valueB % 64))</span>
        case SHAR_R_32:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueA%(1&lt;&lt;32), 4)/(1&lt;&lt;(valueB%32))), 8)</span>
        case SHAR_R_64:<span class="cov0" title="0">
                result = z_decode(Floor(z_encode(valueA, 8)/(1&lt;&lt;(valueB%64))), 8)</span>
        case ROT_L_64:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)[:64]
                b_valueD := b_valueA[int(valueB%64):] + b_valueA[:int(valueB%64)]
                result = B_decode(b_valueD)</span>
        case ROT_L_32:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)[:32]
                b_valueD := b_valueA[int(valueA%32):] + b_valueA[:int(valueA%32)]
                result = x_encode(B_decode(b_valueD), 4)</span>
        case ROT_R_64:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)[:64]
                b_valueD := b_valueA[64-int(valueB%64):] + b_valueA[:64-int(valueB%64)]
                result = B_decode(b_valueD)</span>
        case ROT_R_32:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)[:32]
                b_valueD := b_valueA[32-int(valueA%32):] + b_valueA[:32-int(valueA%32)]
                result = x_encode(B_decode(b_valueD), 4)</span>
        case AND_INV:<span class="cov0" title="0">
                result = valueA &amp; (^valueB)</span>
        case OR_INV:<span class="cov0" title="0">
                result = valueA | (^valueB)</span>
        case XNOR:<span class="cov0" title="0">
                result = ^(valueA ^ valueB)</span>
        case MAX:<span class="cov0" title="0">
                result = uint64(max(z_encode(valueA, 8), z_encode(valueB, 8)))</span>
        case MAX_U:<span class="cov0" title="0">
                result = max(valueA, valueB)</span>
        case MIN:<span class="cov0" title="0">
                result = uint64(min(z_encode(valueA, 8), z_encode(valueB, 8)))</span>
        case MIN_U:<span class="cov0" title="0">
                result = min(valueA, valueB)</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("aluReg - rA[%d]=%d  regB[%d]=%d regD[%d]=%d\n", registerIndexA, valueA, registerIndexB, valueB, registerIndexD, result)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(registerIndexD, result)</span>
}

// VM Management: CreateVM, GetVM, ExpungeVM
func (vm *VM) CreateVM(serviceAcct uint32, code []byte, i uint64) uint32 <span class="cov0" title="0">{
        maxN := uint32(0)
        for n := range vm.VMs </span><span class="cov0" title="0">{
                if n &gt; maxN </span><span class="cov0" title="0">{
                        maxN = n
                }</span>
        }
        <span class="cov0" title="0">if vm.VMs == nil </span><span class="cov0" title="0">{
                vm.VMs = make(map[uint32]*VM)
        }</span>
        <span class="cov0" title="0">fmt.Printf("CreateVM: %d\n", maxN)
        vm.VMs[maxN+1] = NewVMFromCode(serviceAcct, code, i, vm.hostenv)
        return maxN + 1</span>
}

func (vm *VM) GetVM(n uint32) (*VM, bool) <span class="cov0" title="0">{
        vm, ok := vm.VMs[n]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return vm, true</span>
}

func (vm *VM) ExpungeVM(n uint32) bool <span class="cov0" title="0">{
        _, ok := vm.VMs[n]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">delete(vm.VMs, n)
        return true</span>
}

// shawn : add a pub function to get the register value
func (vm *VM) GetRegisterValue(registerIndex int) (uint64, uint64) <span class="cov0" title="0">{
        value, errCode := vm.ReadRegister(registerIndex)
        return value, errCode
}</span>

func (vm *VM) SetRegisterValue(registerIndex int, value uint64) uint64 <span class="cov0" title="0">{
        return vm.WriteRegister(registerIndex, value)
}</span>

func (vm *VM) HostCheat(input string) (errcode uint64) <span class="cov0" title="0">{
        if input == "machine" </span><span class="cov0" title="0">{
                vm.hostMachine()
        }</span> else<span class="cov0" title="0"> if input == "poke" </span><span class="cov0" title="0">{
                vm.hostPoke()
        }</span> else<span class="cov0" title="0"> if input == "peek" </span><span class="cov0" title="0">{
                vm.hostPeek()
        }</span> else<span class="cov0" title="0"> if input == "invoke" </span><span class="cov0" title="0">{
                vm.hostInvoke()
        }</span> else<span class="cov0" title="0"> if input == "expunge" </span><span class="cov0" title="0">{
                vm.hostExpunge()
        }</span> else<span class="cov0" title="0"> if input == "zero" </span><span class="cov0" title="0">{
                vm.hostZero()
        }</span>
        <span class="cov0" title="0">return errcode</span>
}

func (vm *VM) Instructions_with_Arguments_of_Two_Register(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexD := min(12, int(originalOperands[0])%16)
        registerIndexA := min(12, int(originalOperands[0])/16)

        valueA, _ := vm.ReadRegister(registerIndexA)

        var result uint64
        switch opcode </span>{
        case COUNT_SET_BITS_64:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)
                count := strings.Count(b_valueA, "1")
                result = uint64(count)</span>
        case COUNT_SET_BITS_32:<span class="cov0" title="0">
                b_valueA := B_encode(valueA % (1 &lt;&lt; 32))
                count := strings.Count(b_valueA, "1")
                result = uint64(count)</span>
        case LEADING_ZERO_BITS_64:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)
                count := strings.LastIndex(b_valueA, "0")
                if count == -1 || count &gt; 64 </span><span class="cov0" title="0">{
                        count = 64
                }</span>
                <span class="cov0" title="0">result = uint64(count)</span>
        case LEADING_ZERO_BITS_32:<span class="cov0" title="0">
                b_valueA := B_encode(valueA % (1 &lt;&lt; 32))
                count := strings.LastIndex(b_valueA, "0")
                if count == -1 || count &gt; 32 </span><span class="cov0" title="0">{
                        count = 32
                }</span>
                <span class="cov0" title="0">result = uint64(count)</span>
        case TRAILING_ZERO_BITS_64:<span class="cov0" title="0">
                b_valueA := B_encode(valueA)
                count := strings.Index(b_valueA, "1")
                if count == -1 || count &gt; 64 </span><span class="cov0" title="0">{
                        count = 64
                }</span>
                <span class="cov0" title="0">result = uint64(count)</span>
        case TRAILING_ZERO_BITS_32:<span class="cov0" title="0">
                b_valueA := B_encode(valueA % (1 &lt;&lt; 32))
                count := strings.Index(b_valueA, "1")
                if count == -1 || count &gt; 32 </span><span class="cov0" title="0">{
                        count = 32
                }</span>
                <span class="cov0" title="0">result = uint64(count)</span>
        case SIGN_EXTEND_8:<span class="cov0" title="0">
                result = z_decode(z_encode(valueA%(1&lt;&lt;8), 1), 8)</span>
        case SIGN_EXTEND_16:<span class="cov0" title="0">
                result = z_decode(z_encode(valueA%(1&lt;&lt;16), 2), 8)</span>
        case ZERO_EXTEND_16:<span class="cov0" title="0">
                result = valueA % (1 &lt;&lt; 16)</span>
        case REVERSE_BYTES:<span class="cov0" title="0">
                result = types.DecodeE_l(reverseBytes(types.E_l(valueA, 8)))</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }
        <span class="cov0" title="0">vm.WriteRegister(registerIndexD, result)</span>
}

func (vm *VM) Instructions_with_Arguments_of_One_Register_and_One_Extended_Width_Immediate(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := types.DecodeE_l(originalOperands[1 : 1+lx])
        vm.WriteRegister(registerIndexA, uint64(vx))</span>
}

func (vm *VM) Instructions_with_Arguments_of_Two_Registers_and_One_Immediate(opcode byte, operands []byte) <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, _ := vm.ReadRegister(registerIndexA)
        valueB, _ := vm.ReadRegister(registerIndexB)

        vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        var result uint64
        switch opcode </span>{
        case ADD_IMM_64:<span class="cov0" title="0">
                valueA = valueB + uint64(vx)
                result = valueA</span>

        case SHLO_L_IMM_64:<span class="cov0" title="0">
                valueA = x_encode(valueB*(1&lt;&lt;(vx%64)), 8)
                result = valueA</span>
        case SHLO_R_IMM_64:<span class="cov0" title="0">
                valueA = x_encode(valueB/(1&lt;&lt;(vx%64)), 8)
                result = valueA</span>
        default:<span class="cov0" title="0">
                vm.ResultCode = PANIC
                vm.terminated = true</span>
        }

        <span class="cov0" title="0">vm.WriteRegister(registerIndexA, result)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
