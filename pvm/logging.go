package pvm

import "fmt"

// Termination Instructions
var T = map[int]struct{}{
	TRAP:            {},
	FALLTHROUGH:     {},
	JUMP:            {},
	JUMP_IND:        {},
	LOAD_IMM_JUMP:   {},
	BRANCH_EQ_IMM:   {},
	BRANCH_NE_IMM:   {},
	BRANCH_LT_U_IMM: {},
	BRANCH_LE_U_IMM: {},
	BRANCH_GE_U_IMM: {},
	BRANCH_GT_U_IMM: {},
	BRANCH_LT_S_IMM: {},
	BRANCH_LE_S_IMM: {},
	BRANCH_GE_S_IMM: {},
	BRANCH_GT_S_IMM: {},
	BRANCH_EQ:       {},
	BRANCH_NE:       {},
	BRANCH_LT_U:     {},
	BRANCH_LT_S:     {},
	BRANCH_GE_U:     {},
	BRANCH_GE_S:     {},
}

func opcode_str(opcode byte) string {
	opcodeMap := map[byte]string{
		0:   "TRAP",
		1:   "FALLTHROUGH",
		10:  "ECALLI",
		20:  "LOAD_IMM_64",
		30:  "STORE_IMM_U8",
		31:  "STORE_IMM_U16",
		32:  "STORE_IMM_U32",
		33:  "STORE_IMM_U64",
		40:  "JUMP",
		50:  "JUMP_IND",
		51:  "LOAD_IMM",
		52:  "LOAD_U8",
		53:  "LOAD_I8",
		54:  "LOAD_U16",
		55:  "LOAD_I16",
		56:  "LOAD_U32",
		57:  "LOAD_I32",
		58:  "LOAD_U64",
		59:  "STORE_U8",
		60:  "STORE_U16",
		61:  "STORE_U32",
		62:  "STORE_U64",
		70:  "STORE_IMM_IND_U8",
		71:  "STORE_IMM_IND_U16",
		72:  "STORE_IMM_IND_U32",
		73:  "STORE_IMM_IND_U64",
		80:  "LOAD_IMM_JUMP",
		81:  "BRANCH_EQ_IMM",
		82:  "BRANCH_NE_IMM",
		83:  "BRANCH_LT_U_IMM",
		84:  "BRANCH_LE_U_IMM",
		85:  "BRANCH_GE_U_IMM",
		86:  "BRANCH_GT_U_IMM",
		87:  "BRANCH_LT_S_IMM",
		88:  "BRANCH_LE_S_IMM",
		89:  "BRANCH_GE_S_IMM",
		90:  "BRANCH_GT_S_IMM",
		100: "MOVE_REG",
		101: "SBRK",
		102: "COUNT_SET_BITS_64",
		103: "COUNT_SET_BITS_32",
		104: "LEADING_ZERO_BITS_64",
		105: "LEADING_ZERO_BITS_32",
		106: "TRAILING_ZERO_BITS_64",
		107: "TRAILING_ZERO_BITS_32",
		108: "SIGN_EXTEND_8",
		109: "SIGN_EXTEND_16",
		110: "ZERO_EXTEND_16",
		111: "REVERSE_BYTES",
		120: "STORE_IND_U8",
		121: "STORE_IND_U16",
		122: "STORE_IND_U32",
		123: "STORE_IND_U64",
		124: "LOAD_IND_U8",
		125: "LOAD_IND_I8",
		126: "LOAD_IND_U16",
		127: "LOAD_IND_I16",
		128: "LOAD_IND_U32",
		129: "LOAD_IND_I32",
		130: "LOAD_IND_U64",
		131: "ADD_IMM_32",
		132: "AND_IMM",
		133: "XOR_IMM",
		134: "OR_IMM",
		135: "MUL_IMM_32",
		136: "SET_LT_U_IMM",
		137: "SET_LT_S_IMM",
		138: "SHLO_L_IMM_32",
		139: "SHLO_R_IMM_32",
		140: "SHAR_R_IMM_32",
		141: "NEG_ADD_IMM_32",
		142: "SET_GT_U_IMM",
		143: "SET_GT_S_IMM",
		144: "SHLO_L_IMM_ALT_32",
		145: "SHLO_R_IMM_ALT_32",
		146: "SHAR_R_IMM_ALT_32",
		147: "CMOV_IZ_IMM",
		148: "CMOV_NZ_IMM",
		149: "ADD_IMM_64",
		150: "MUL_IMM_64",
		151: "SHLO_L_IMM_64",
		152: "SHLO_R_IMM_64",
		153: "SHAR_R_IMM_64",
		154: "NEG_ADD_IMM_64",
		155: "SHLO_L_IMM_ALT_64",
		156: "SHLO_R_IMM_ALT_64",
		157: "SHAR_R_IMM_ALT_64",
		158: "ROT_R_64_IMM",
		159: "ROT_R_64_IMM_ALT",
		160: "ROT_R_32_IMM",
		161: "ROT_R_32_IMM_ALT",
		170: "BRANCH_EQ",
		171: "BRANCH_NE",
		172: "BRANCH_LT_U",
		173: "BRANCH_LT_S",
		174: "BRANCH_GE_U",
		175: "BRANCH_GE_S",
		180: "LOAD_IMM_JUMP_IND",
		190: "ADD_32",
		191: "SUB_32",
		192: "MUL_32",
		193: "DIV_U_32",
		194: "DIV_S_32",
		195: "REM_U_32",
		196: "REM_S_32",
		197: "SHLO_L_32",
		198: "SHLO_R_32",
		199: "SHAR_R_32",
		200: "ADD_64",
		201: "SUB_64",
		202: "MUL_64",
		203: "DIV_U_64",
		204: "DIV_S_64",
		205: "REM_U_64",
		206: "REM_S_64",
		207: "SHLO_L_64",
		208: "SHLO_R_64",
		209: "SHAR_R_64",
		210: "AND",
		211: "XOR",
		212: "OR",
		213: "MUL_UPPER_S_S",
		214: "MUL_UPPER_U_U",
		215: "MUL_UPPER_S_U",
		216: "SET_LT_U",
		217: "SET_LT_S",
		218: "CMOV_IZ",
		219: "CMOV_NZ",
		220: "ROT_L_64",
		221: "ROT_L_32",
		222: "ROT_R_64",
		223: "ROT_R_32",
		224: "AND_INV",
		225: "OR_INV",
		226: "XNOR",
		227: "MAX",
		228: "MAX_U",
		229: "MIN",
		230: "MIN_U",
	}

	if name, exists := opcodeMap[opcode]; exists {
		return name
	}
	return fmt.Sprintf("OPCODE %d", opcode)
}

func (vm *VM) Str(logStr string) string {
	return fmt.Sprintf("%s_%s: %s", vm.ServiceMetadata, vm.Mode, logStr)
}
