
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bandersnatch: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/colorfulnotion/jam/bandersnatch/bandersnatch.go (67.0%)</option>
				
				<option value="file1">github.com/colorfulnotion/jam/bls/bls.go (71.7%)</option>
				
				<option value="file2">github.com/colorfulnotion/jam/common/ethereum_common.go (4.5%)</option>
				
				<option value="file3">github.com/colorfulnotion/jam/common/hash.go (12.1%)</option>
				
				<option value="file4">github.com/colorfulnotion/jam/common/key_constructor_tool.go (0.0%)</option>
				
				<option value="file5">github.com/colorfulnotion/jam/common/signing.go (76.2%)</option>
				
				<option value="file6">github.com/colorfulnotion/jam/common/tool.go (0.0%)</option>
				
				<option value="file7">github.com/colorfulnotion/jam/erasurecoding/erasurecoding.go (85.5%)</option>
				
				<option value="file8">github.com/colorfulnotion/jam/pvm/hostfunctions.go (0.0%)</option>
				
				<option value="file9">github.com/colorfulnotion/jam/pvm/mockenv.go (0.0%)</option>
				
				<option value="file10">github.com/colorfulnotion/jam/pvm/pvm.go (4.3%)</option>
				
				<option value="file11">github.com/colorfulnotion/jam/statedb/accumulate.go (16.0%)</option>
				
				<option value="file12">github.com/colorfulnotion/jam/statedb/assurances.go (51.9%)</option>
				
				<option value="file13">github.com/colorfulnotion/jam/statedb/audit.go (0.0%)</option>
				
				<option value="file14">github.com/colorfulnotion/jam/statedb/authorizations.go (0.0%)</option>
				
				<option value="file15">github.com/colorfulnotion/jam/statedb/block_draw.go (0.0%)</option>
				
				<option value="file16">github.com/colorfulnotion/jam/statedb/disputes.go (61.6%)</option>
				
				<option value="file17">github.com/colorfulnotion/jam/statedb/finalize.go (0.0%)</option>
				
				<option value="file18">github.com/colorfulnotion/jam/statedb/genesis.go (0.0%)</option>
				
				<option value="file19">github.com/colorfulnotion/jam/statedb/guarantees.go (56.9%)</option>
				
				<option value="file20">github.com/colorfulnotion/jam/statedb/history.go (32.0%)</option>
				
				<option value="file21">github.com/colorfulnotion/jam/statedb/rotation.go (41.0%)</option>
				
				<option value="file22">github.com/colorfulnotion/jam/statedb/safrole.go (17.1%)</option>
				
				<option value="file23">github.com/colorfulnotion/jam/statedb/shuffle.go (100.0%)</option>
				
				<option value="file24">github.com/colorfulnotion/jam/statedb/state.go (34.4%)</option>
				
				<option value="file25">github.com/colorfulnotion/jam/statedb/state_decode.go (36.9%)</option>
				
				<option value="file26">github.com/colorfulnotion/jam/statedb/state_encode.go (37.4%)</option>
				
				<option value="file27">github.com/colorfulnotion/jam/statedb/state_snapshot.go (9.5%)</option>
				
				<option value="file28">github.com/colorfulnotion/jam/statedb/statedb.go (1.2%)</option>
				
				<option value="file29">github.com/colorfulnotion/jam/statedb/statedb_hostenv.go (25.3%)</option>
				
				<option value="file30">github.com/colorfulnotion/jam/statedb/statetransition.go (0.0%)</option>
				
				<option value="file31">github.com/colorfulnotion/jam/statedb/transfer.go (0.0%)</option>
				
				<option value="file32">github.com/colorfulnotion/jam/trie/bpt.go (50.8%)</option>
				
				<option value="file33">github.com/colorfulnotion/jam/trie/cdt.go (80.9%)</option>
				
				<option value="file34">github.com/colorfulnotion/jam/trie/hash.go (81.6%)</option>
				
				<option value="file35">github.com/colorfulnotion/jam/trie/initial_bpt.go (84.6%)</option>
				
				<option value="file36">github.com/colorfulnotion/jam/trie/mmr.go (26.7%)</option>
				
				<option value="file37">github.com/colorfulnotion/jam/trie/mmr_stanley.go (0.0%)</option>
				
				<option value="file38">github.com/colorfulnotion/jam/trie/wbt.go (78.6%)</option>
				
				<option value="file39">github.com/colorfulnotion/jam/types/accumulatecontext.go (0.0%)</option>
				
				<option value="file40">github.com/colorfulnotion/jam/types/announcement.go (0.0%)</option>
				
				<option value="file41">github.com/colorfulnotion/jam/types/assurance.go (28.1%)</option>
				
				<option value="file42">github.com/colorfulnotion/jam/types/bandersnatch.go (0.0%)</option>
				
				<option value="file43">github.com/colorfulnotion/jam/types/block.go (13.7%)</option>
				
				<option value="file44">github.com/colorfulnotion/jam/types/blockannouncement.go (0.0%)</option>
				
				<option value="file45">github.com/colorfulnotion/jam/types/codec.go (51.8%)</option>
				
				<option value="file46">github.com/colorfulnotion/jam/types/commandconfig.go (0.0%)</option>
				
				<option value="file47">github.com/colorfulnotion/jam/types/dispute.go (22.1%)</option>
				
				<option value="file48">github.com/colorfulnotion/jam/types/ed25519.go (4.3%)</option>
				
				<option value="file49">github.com/colorfulnotion/jam/types/epochmark.go (75.0%)</option>
				
				<option value="file50">github.com/colorfulnotion/jam/types/extrinsic_pool.go (0.0%)</option>
				
				<option value="file51">github.com/colorfulnotion/jam/types/extrinsicdata.go (0.0%)</option>
				
				<option value="file52">github.com/colorfulnotion/jam/types/guarantee.go (16.4%)</option>
				
				<option value="file53">github.com/colorfulnotion/jam/types/guarantor_assignments.go (0.0%)</option>
				
				<option value="file54">github.com/colorfulnotion/jam/types/header.go (70.8%)</option>
				
				<option value="file55">github.com/colorfulnotion/jam/types/judgement.go (0.0%)</option>
				
				<option value="file56">github.com/colorfulnotion/jam/types/justification.go (0.0%)</option>
				
				<option value="file57">github.com/colorfulnotion/jam/types/peaks.go (0.0%)</option>
				
				<option value="file58">github.com/colorfulnotion/jam/types/preimageannouncement.go (0.0%)</option>
				
				<option value="file59">github.com/colorfulnotion/jam/types/preimagelookup.go (19.1%)</option>
				
				<option value="file60">github.com/colorfulnotion/jam/types/serviceaccount.go (0.0%)</option>
				
				<option value="file61">github.com/colorfulnotion/jam/types/statekv.go (0.0%)</option>
				
				<option value="file62">github.com/colorfulnotion/jam/types/ticket.go (17.0%)</option>
				
				<option value="file63">github.com/colorfulnotion/jam/types/ticketbody.go (90.5%)</option>
				
				<option value="file64">github.com/colorfulnotion/jam/types/transfermemo.go (0.0%)</option>
				
				<option value="file65">github.com/colorfulnotion/jam/types/types.go (43.5%)</option>
				
				<option value="file66">github.com/colorfulnotion/jam/types/validator.go (0.0%)</option>
				
				<option value="file67">github.com/colorfulnotion/jam/types/workitem.go (81.2%)</option>
				
				<option value="file68">github.com/colorfulnotion/jam/types/workpackage.go (39.1%)</option>
				
				<option value="file69">github.com/colorfulnotion/jam/types/workreport.go (34.0%)</option>
				
				<option value="file70">github.com/colorfulnotion/jam/types/workresult.go (57.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bandersnatch

/*
#cgo LDFLAGS: -Ltarget/release -lbandersnatch -ldl
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;bandersnatch.h&gt;
*/
import "C"
import (
        "bytes"
        //"crypto/ed25519"
        "encoding/hex"
        "errors"
        "fmt"
        "unsafe"
        //"github.com/colorfulnotion/jam/types"
)

type BanderSnatchSecret [PubkeyLen]byte
type BanderSnatchKey [SecretLen]byte
type BandersnatchVrfSignature [IETFSignatureLen]byte
type BandersnatchRingSignature [RingSignatureLen]byte

type Seed []byte

func (bk BanderSnatchKey) Bytes() []byte <span class="cov8" title="1">{
        return bk[:]
}</span>

func (bs BanderSnatchSecret) Bytes() []byte <span class="cov8" title="1">{
        return bs[:]
}</span>

func (bk BanderSnatchKey) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(bk.Bytes())
}</span>

func (bs BanderSnatchSecret) String() string <span class="cov8" title="1">{
        return hex.EncodeToString(bs.Bytes())
}</span>

func BytesToBanderSnatchSecret(b []byte) (bs BanderSnatchSecret, err error) <span class="cov0" title="0">{
        if len(b) != SecretLen </span><span class="cov0" title="0">{
                return BanderSnatchSecret{}, fmt.Errorf("invalid byte slice length: expected %d bytes, got %d", SecretLen, len(b))
        }</span>
        <span class="cov0" title="0">copy(bs[:], b)
        return bs, nil</span>
}

// InitBanderSnatchKey initializes the BanderSnatch keys using the provided seed.
func InitBanderSnatchKey(seed []byte) (key BanderSnatchKey, secret BanderSnatchSecret, err error) <span class="cov8" title="1">{
        // Check if the seed length is 32 bytes
        if len(seed) != SeedLen </span><span class="cov0" title="0">{
                return key, secret, fmt.Errorf("seed length must be %v bytes", SeedLen)
        }</span>

        // Retrieve the public key
        <span class="cov8" title="1">banderSnatch_pub, err := getBanderSnatchPublicKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return key, secret, fmt.Errorf("failed to get public key: %v", err)
        }</span>

        // Retrieve the private key
        <span class="cov8" title="1">banderSnatch_priv, err := getBanderSnatchPrivateKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return key, secret, fmt.Errorf("failed to get private key: %v", err)
        }</span>
        //fmt.Printf("!!!!BanderSnatch Pub Len=%v, Priv Len=%v\n", len(banderSnatch_pub), len(banderSnatch_priv))
        <span class="cov8" title="1">return banderSnatch_pub, banderSnatch_priv, nil</span>
}

func getBanderSnatchPublicKey(seed []byte) (BanderSnatchKey, error) <span class="cov8" title="1">{
        //pubKey := make([]byte, 32) // Adjust size as necessary
        pubKey := BanderSnatchKey{}
        C.get_public_key(
                (*C.uchar)(unsafe.Pointer(&amp;seed[0])),
                C.size_t(len(seed)),
                (*C.uchar)(unsafe.Pointer(&amp;pubKey[0])),
                C.size_t(len(pubKey)),
        )
        return pubKey, nil
}</span>

func getBanderSnatchPrivateKey(seed []byte) (BanderSnatchSecret, error) <span class="cov8" title="1">{
        //secret := make([]byte, 32) // Adjust size as necessary
        secret := BanderSnatchSecret{}
        C.get_private_key(
                (*C.uchar)(unsafe.Pointer(&amp;seed[0])),
                C.size_t(len(seed)),
                (*C.uchar)(unsafe.Pointer(&amp;secret[0])),
                C.size_t(len(secret)),
        )
        return secret, nil
}</span>

func InitRingSet(ringset []BanderSnatchKey) (ringsetBytes []byte) <span class="cov0" title="0">{
        // Flatten pubkeys into a single byte slice
        for _, pubkey := range ringset </span><span class="cov0" title="0">{
                ringsetBytes = append(ringsetBytes, pubkey[:]...)
        }</span>
        <span class="cov0" title="0">return ringsetBytes</span>
}

// Anonymous Ring VRF
// RingVRFSign is Used for tickets submission to sign ticket anonymously. Output and Ring Proof bundled together (as per section 2.2)
func RingVrfSign(privateKey BanderSnatchSecret, ringsetBytes, vrfInputData, auxData []byte /*, proverIdx int*/) ([]byte, []byte, error) <span class="cov8" title="1">{
        sig := make([]byte, RingSignatureLen) // 784 bytes
        vrfOutput := make([]byte, 32)

        auxDataL := C.size_t(len(auxData))
        auxDataF := auxData
        if len(auxData) == 0 </span><span class="cov0" title="0">{
                auxDataF = []byte{1}
                auxDataL = C.size_t(0)
        }</span>
        <span class="cov8" title="1">if len(ringsetBytes) == 0 </span><span class="cov0" title="0">{
                return []byte{}, []byte{}, fmt.Errorf("Not able to sign without ringset bytes")
        }</span>
        <span class="cov8" title="1">C.ring_vrf_sign(
                (*C.uchar)(unsafe.Pointer(&amp;privateKey[0])),
                C.size_t(len(privateKey)),
                (*C.uchar)(unsafe.Pointer(&amp;ringsetBytes[0])),
                C.size_t(len(ringsetBytes)),
                //C.size_t(proverIdx),
                (*C.uchar)(unsafe.Pointer(&amp;vrfInputData[0])),
                C.size_t(len(vrfInputData)),
                (*C.uchar)(unsafe.Pointer(&amp;auxDataF[0])),
                auxDataL,
                (*C.uchar)(unsafe.Pointer(&amp;sig[0])),
                C.size_t(len(sig)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                C.size_t(len(vrfOutput)),
                //C.size_t(proverIdx),
        )
        return sig, vrfOutput, nil</span>
}

// RingVRFVerify is Used for tickets verification, and returns vrfOutput on success
func RingVrfVerify(ringsetBytes, signature, vrfInputData, auxData []byte) ([]byte, error) <span class="cov8" title="1">{
        vrfOutput := make([]byte, VRFOutputLen)
        auxDataL := C.size_t(len(auxData))
        auxDataF := auxData
        if len(auxData) == 0 </span><span class="cov0" title="0">{
                auxDataF = []byte{1}
                auxDataL = C.size_t(0)
        }</span>
        <span class="cov8" title="1">if len(ringsetBytes) == 0 </span><span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("No ringsetBytes")
        }</span>
        <span class="cov8" title="1">result := C.ring_vrf_verify(
                (*C.uchar)(unsafe.Pointer(&amp;ringsetBytes[0])),
                C.size_t(len(ringsetBytes)),
                (*C.uchar)(unsafe.Pointer(&amp;signature[0])),
                C.size_t(len(signature)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfInputData[0])),
                C.size_t(len(vrfInputData)),
                (*C.uchar)(unsafe.Pointer(&amp;auxDataF[0])),
                auxDataL,
                (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                C.size_t(len(vrfOutput)),
        )
        if result != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("verification failed")
        }</span>
        <span class="cov8" title="1">return vrfOutput, nil</span>
}

// Non Anonymous IETF VRF
// IetfVrfSign is Used for ticket claiming during block production.
func IetfVrfSign(privateKey BanderSnatchSecret, vrfInputData, auxData []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        sig := make([]byte, IETFSignatureLen) // 96 bytes
        vrfOutput := make([]byte, 32)
        auxDataL := C.size_t(len(auxData))
        auxDataF := auxData
        if len(auxData) == 0 </span><span class="cov0" title="0">{
                auxDataF = []byte{1}
                auxDataL = C.size_t(0)
        }</span>
        <span class="cov8" title="1">C.ietf_vrf_sign(
                (*C.uchar)(unsafe.Pointer(&amp;privateKey[0])),
                C.size_t(len(privateKey)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfInputData[0])),
                C.size_t(len(vrfInputData)),
                (*C.uchar)(unsafe.Pointer(&amp;auxDataF[0])),
                auxDataL,
                //(*C.uchar)(unsafe.Pointer(&amp;auxData[0])),
                //C.size_t(len(auxData)),
                (*C.uchar)(unsafe.Pointer(&amp;sig[0])),
                C.size_t(len(sig)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                C.size_t(len(vrfOutput)),
        )
        return sig, vrfOutput, nil</span>
}

// IetfVrfVerifyAndGenerateVrfOutput is Used for ticket claim verification during block import
// returns vrfOutput on success
// NOTE: this external func should use PublicKey directly instead of index
func IetfVrfVerify(pubKey BanderSnatchKey, signature, vrfInputData, auxData []byte) ([]byte, error) <span class="cov8" title="1">{
        vrfOutput := make([]byte, VRFOutputLen)
        result := C.ietf_vrf_verify(
                (*C.uchar)(unsafe.Pointer(&amp;pubKey[0])),
                C.size_t(len(pubKey)),
                (*C.uchar)(unsafe.Pointer(&amp;signature[0])),
                C.size_t(len(signature)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfInputData[0])),
                C.size_t(len(vrfInputData)),
                (*C.uchar)(unsafe.Pointer(&amp;auxData[0])),
                C.size_t(len(auxData)),
                (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                C.size_t(len(vrfOutput)),
        )
        if result != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("verification failed")
        }</span>
        <span class="cov8" title="1">return vrfOutput, nil</span>
}

/*
since VRFSignedOutput(ringSig) and  VRFSignedOutput(ietfSig) yield same output_hash,
it should be possible to compute ticketID without goign through RingVRFSign
*/
// Return vrfOutput given PrivateKey, vrfInputData
func VRFOutput(privateKey BanderSnatchSecret, vrfInputData, auxData []byte) ([]byte, error) <span class="cov0" title="0">{
        vrfOutput := make([]byte, 32)
        _, vrfOutput, err := IetfVrfSign(privateKey, vrfInputData, auxData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Error Getting vrfOutput")
        }</span>
        <span class="cov0" title="0">return vrfOutput, nil</span>
}

// Return vrfOutput given valid signature -- inputs are different though so probably not necessary?
func VRFSignedOutput(signature []byte) ([]byte, error) <span class="cov8" title="1">{
        vrfOutput := make([]byte, 32)
        if len(signature) == RingSignatureLen </span><span class="cov8" title="1">{
                result := C.get_ring_vrf_output(
                        (*C.uchar)(unsafe.Pointer(&amp;signature[0])),
                        C.size_t(len(signature)),
                        (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                        C.size_t(len(vrfOutput)),
                )
                if result != 1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get Ring VRF output")
                }</span>
                <span class="cov8" title="1">return vrfOutput, nil</span>
        } else<span class="cov8" title="1"> if len(signature) == IETFSignatureLen </span><span class="cov8" title="1">{
                result := C.get_ietf_vrf_output(
                        (*C.uchar)(unsafe.Pointer(&amp;signature[0])),
                        C.size_t(len(signature)),
                        (*C.uchar)(unsafe.Pointer(&amp;vrfOutput[0])),
                        C.size_t(len(vrfOutput)),
                )
                if result != 1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to get IETF VRF output")
                }</span>
        } else<span class="cov0" title="0"> {
                return nil, errors.New("invalid signature length")
        }</span>
        <span class="cov8" title="1">return vrfOutput, nil</span>
}

func GetRingCommitment(ringsetBytes []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(ringsetBytes) == 0 </span><span class="cov0" title="0">{
                return []byte{}, fmt.Errorf("No ringset")
        }</span>
        <span class="cov8" title="1">emptyBytes := make([]byte, BlsLen)
        commitmentBytes := make([]byte, BlsLen)
        C.get_ring_commitment(
                (*C.uchar)(unsafe.Pointer(&amp;ringsetBytes[0])),
                C.size_t(len(ringsetBytes)),
                (*C.uchar)(unsafe.Pointer(&amp;commitmentBytes[0])),
                C.size_t(len(commitmentBytes)),
        )
        if bytes.Equal(emptyBytes, commitmentBytes) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to compute ring commitment")
        }</span>
        <span class="cov8" title="1">return commitmentBytes, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bls

/*
#cgo LDFLAGS: -L./target/release -lbls -ldl
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;bls.h&gt;
*/
import "C"
import (
        "errors"
        "unsafe"
)

type DoublePublicKey [DoubleKeyLen]byte

func (dpk *DoublePublicKey) Bytes() []byte <span class="cov8" title="1">{
        return dpk[:]
}</span>

type G1PublicKey [G1Len]byte
type G2PublicKey [G2Len]byte

func (g2 *G2PublicKey) Bytes() []byte <span class="cov8" title="1">{
        return g2[:]
}</span>

type SecretKey [SecretKeyLen]byte

func (sk *SecretKey) Bytes() []byte <span class="cov8" title="1">{
        return sk[:]
}</span>

type Signature [SigLen]byte

func (s *Signature) Bytes() []byte <span class="cov8" title="1">{
        return s[:]
}</span>

type Seed []byte

func GetSecretKey(seed []byte) (SecretKey, error) <span class="cov8" title="1">{
        // Retrieve the secret key
        secret := SecretKey{}
        if len(seed) == 0 </span><span class="cov0" title="0">{
                return secret, errors.New("BLS seed empty")
        }</span>
        <span class="cov8" title="1">C.get_secret_key(
                (*C.uchar)(unsafe.Pointer(&amp;seed[0])),
                (C.size_t)(len(seed)),
                (*C.uchar)(unsafe.Pointer(&amp;secret[0])),
                (C.size_t)(SecretKeyLen),
        )
        if len(secret.Bytes()) == 0 </span><span class="cov0" title="0">{
                return secret, errors.New("failed to retrieve secret key")
        }</span>
        <span class="cov8" title="1">return secret, nil</span>
}

func GetDoublePublicKey(seed []byte) (DoublePublicKey, error) <span class="cov8" title="1">{
        // Retrieve the double public key
        double := DoublePublicKey{}
        C.get_double_pubkey(
                (*C.uchar)(unsafe.Pointer(&amp;seed[0])),
                (C.size_t)(len(seed)),
                (*C.uchar)(unsafe.Pointer(&amp;double[0])),
                (C.size_t)(DoubleKeyLen),
        )
        if len(double.Bytes()) == 0 </span><span class="cov0" title="0">{
                return double, errors.New("failed to retrieve double public key")
        }</span>
        <span class="cov8" title="1">return double, nil</span>
}

func GetPublicKey_G2(seed []byte) (G2PublicKey, error) <span class="cov8" title="1">{
        // Retrieve the G2 public key
        g2 := G2PublicKey{}
        C.get_pubkey_g2(
                (*C.uchar)(unsafe.Pointer(&amp;seed[0])),
                (C.size_t)(len(seed)),
                (*C.uchar)(unsafe.Pointer(&amp;g2[0])),
                (C.size_t)(G2Len),
        )
        if len(g2.Bytes()) == 0 </span><span class="cov0" title="0">{
                return g2, errors.New("failed to retrieve G2 public key")
        }</span>
        <span class="cov8" title="1">return g2, nil</span>
}

func (secret *SecretKey) Sign(msg []byte) (Signature, error) <span class="cov8" title="1">{
        // Sign the message
        sig := Signature{}
        C.sign(
                (*C.uchar)(unsafe.Pointer(secret)),
                (C.size_t)(SecretKeyLen),
                (*C.uchar)(unsafe.Pointer(&amp;msg[0])),
                (C.size_t)(len(msg)),
                (*C.uchar)(unsafe.Pointer(&amp;sig[0])),
                (C.size_t)(SigLen),
        )
        if len(sig.Bytes()) == 0 </span><span class="cov0" title="0">{
                return sig, errors.New("failed to sign message")
        }</span>
        <span class="cov8" title="1">return sig, nil</span>
}

func (pub *G2PublicKey) Verify(msg []byte, sig Signature) bool <span class="cov8" title="1">{
        // Verify the message
        return C.verify(
                (*C.uchar)(unsafe.Pointer(pub)),
                (C.size_t)(G2Len),
                (*C.uchar)(unsafe.Pointer(&amp;msg[0])),
                (C.size_t)(len(msg)),
                (*C.uchar)(unsafe.Pointer(&amp;sig[0])),
                (C.size_t)(SigLen),
        ) == 1
}</span>

func AggregateSignatures(sigs []Signature, message []byte) (Signature, error) <span class="cov8" title="1">{
        // Aggregate the signatures
        aggSig := Signature{}
        signaturesbytes := make([]byte, 0)
        for _, sig := range sigs </span><span class="cov8" title="1">{
                signaturesbytes = append(signaturesbytes, sig.Bytes()...)
        }</span>
        <span class="cov8" title="1">if len(signaturesbytes) == 0 </span><span class="cov0" title="0">{
                return aggSig, errors.New("no signatures to aggregate")
        }</span>
        <span class="cov8" title="1">if len(signaturesbytes)%SigLen != 0 </span><span class="cov0" title="0">{
                return aggSig, errors.New("invalid signature length")
        }</span>
        <span class="cov8" title="1">C.aggregate_sign(
                (*C.uchar)(unsafe.Pointer(&amp;signaturesbytes[0])),
                (C.size_t)(len(signaturesbytes)),
                (*C.uchar)(unsafe.Pointer(&amp;message[0])),
                (C.size_t)(len(message)),
                (*C.uchar)(unsafe.Pointer(&amp;aggSig[0])),
                (C.size_t)(SigLen),
        )
        if len(aggSig.Bytes()) == 0 </span><span class="cov0" title="0">{
                return aggSig, errors.New("failed to aggregate signatures")
        }</span>
        <span class="cov8" title="1">return aggSig, nil</span>
}

func AggregateVerify(pubkeys []DoublePublicKey, agg_sig Signature, message []byte) bool <span class="cov8" title="1">{
        // Aggregate verify the message
        pubkeysbytes := make([]byte, 0)
        for _, pubkey := range pubkeys </span><span class="cov8" title="1">{
                pubkeysbytes = append(pubkeysbytes, pubkey.Bytes()...)
        }</span>
        <span class="cov8" title="1">result := C.aggregate_verify_by_signature(
                (*C.uchar)(unsafe.Pointer(&amp;pubkeysbytes[0])),
                (C.size_t)(len(pubkeysbytes)),
                (*C.uchar)(unsafe.Pointer(&amp;message[0])),
                (C.size_t)(len(message)),
                (*C.uchar)(unsafe.Pointer(&amp;agg_sig[0])),
                (C.size_t)(SigLen),
        )
        if result == C.int(1) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func InitBLSKey(seed []byte) (bls_pub DoublePublicKey, bls_priv SecretKey, err error) <span class="cov0" title="0">{
        bls_priv, err = GetSecretKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return bls_pub, bls_priv, err
        }</span>
        <span class="cov0" title="0">bls_pub, err = GetDoublePublicKey(seed)
        if err != nil </span><span class="cov0" title="0">{
                return bls_pub, bls_priv, err
        }</span>
        <span class="cov0" title="0">return bls_pub, bls_priv, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package common

import (
        "fmt"
        "reflect"

        ethereumCommon "github.com/ethereum/go-ethereum/common"
        //"github.com/ethereum/go-ethereum/common/hexutil"
        //"encoding/hex"
        "encoding/json"
)

// Hash is a custom type based on Ethereum's common.Hash
type Hash ethereumCommon.Hash

// Bytes returns the byte representation of the hash.
func (h Hash) Bytes() []byte <span class="cov8" title="1">{
        return ethereumCommon.Hash(h).Bytes()
}</span>

// String returns the string representation of the hash.
func (h Hash) String() string <span class="cov0" title="0">{
        return ethereumCommon.Hash(h).String()
}</span>

// Hex returns the hexadecimal string representation of the hash.
func (h Hash) Hex() string <span class="cov0" title="0">{
        return ethereumCommon.Hash(h).Hex()
}</span>

// BytesToHash converts a byte slice to a Hash.
func BytesToHash(b []byte) Hash <span class="cov8" title="1">{
        return Hash(ethereumCommon.BytesToHash(b))
}</span>

func Bytes2Hex(d []byte) string <span class="cov0" title="0">{
        return "0x" + ethereumCommon.Bytes2Hex(d)
}</span>

// Hex2Bytes converts a byte slice to a Hash.
func Hex2Bytes(b string) []byte <span class="cov0" title="0">{
        return ethereumCommon.FromHex(b)
}</span>

func Hex2BLS(b string) [144]byte <span class="cov0" title="0">{
        x := ethereumCommon.FromHex(b)
        var result [144]byte
        copy(result[:], x)
        return result
}</span>

func Hex2Metadata(b string) [128]byte <span class="cov0" title="0">{
        x := ethereumCommon.FromHex(b)
        var result [128]byte
        copy(result[:], x)
        return result
}</span>

func FromHex(b string) []byte <span class="cov0" title="0">{
        return ethereumCommon.FromHex(b)
}</span>

// HexToHash converts a hexadecimal string to a Hash.
func HexToHash(s string) Hash <span class="cov0" title="0">{
        return Hash(ethereumCommon.HexToHash(s))
}</span>

func Hex2Hash(s string) Hash <span class="cov0" title="0">{
        return HexToHash(s)
}</span>

// Skips "0x" and prints the next 8 characters
func Str(hash Hash) string <span class="cov0" title="0">{
        return fmt.Sprintf("%s..%s", hash.Hex()[2:6], hash.Hex()[60:64])
}</span>

// MarshalJSON custom marshaler to convert Hash to hex string.
func (h Hash) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(h.Hex())
}</span>

// UnmarshalJSON custom unmarshaler to handle hex strings for Hash.
func (h *Hash) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var hexStr string
        if err := json.Unmarshal(data, &amp;hexStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*h = HexToHash(hexStr)
        return nil</span>
}

func PrintHex(h interface{}) <span class="cov0" title="0">{
        v := reflect.ValueOf(h)
        if (v.Kind() == reflect.Slice || v.Kind() == reflect.Array) &amp;&amp; (v.Type().Elem().Kind() == reflect.Uint8) </span><span class="cov0" title="0">{
                fmt.Printf("0x")
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        fmt.Printf("%x", v.Index(i).Interface())
                }</span>
                <span class="cov0" title="0">fmt.Printf("\n")</span>
        } else<span class="cov0" title="0"> if v.Kind() == reflect.String </span><span class="cov0" title="0">{
                fmt.Printf("%s", v.Interface())
                fmt.Printf("\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Unsupported type")
        }</span>
}

func HexString(h interface{}) string <span class="cov0" title="0">{
        var result string
        v := reflect.ValueOf(h)
        if (v.Kind() == reflect.Slice || v.Kind() == reflect.Array) &amp;&amp; (v.Type().Elem().Kind() == reflect.Uint8) </span><span class="cov0" title="0">{
                result = "0x"
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        result += fmt.Sprintf("%02x", v.Index(i).Interface())
                }</span>
        } else<span class="cov0" title="0"> if v.Kind() == reflect.String </span><span class="cov0" title="0">{
                result = fmt.Sprintf("%s", v.Interface())
        }</span> else<span class="cov0" title="0"> {
                result = "Unsupported type"
        }</span>
        <span class="cov0" title="0">return result</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package common

import (
        "encoding/binary"

        "golang.org/x/crypto/blake2b"
        "golang.org/x/crypto/sha3"
)

// computeHash computes the BLAKE2b hash of the given data
func ComputeHash(data []byte) []byte <span class="cov0" title="0">{
        hash := blake2b.Sum256(data)
        return hash[:]
}</span>

func Uint32ToBytes(val uint32) []byte <span class="cov0" title="0">{
        bytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(bytes, val)
        return bytes
}</span>

func Uint16ToBytes(value uint16) []byte <span class="cov0" title="0">{
        bytes := make([]byte, 2)
        binary.LittleEndian.PutUint16(bytes, value)
        return bytes
}</span>

func BytesToUint32(data []byte) uint32 <span class="cov0" title="0">{
        if len(data) &lt; 4 </span><span class="cov0" title="0">{
                // Handle the error according to your application's needs
                panic("BytesToUint32: byte slice too short")</span>
        }
        <span class="cov0" title="0">return binary.LittleEndian.Uint32(data)</span>
}

func BytesToUint16(data []byte) uint16 <span class="cov0" title="0">{
        if len(data) &lt; 2 </span><span class="cov0" title="0">{
                // Handle the error according to your application's needs
                panic("BytesToUint16: byte slice too short")</span>
        }
        <span class="cov0" title="0">return binary.LittleEndian.Uint16(data)</span>
}

func Blake2Hash(data []byte) Hash <span class="cov0" title="0">{
        return BytesToHash(ComputeHash(data))
}</span>

func Keccak256(data []byte) Hash <span class="cov8" title="1">{
        hash := sha3.NewLegacyKeccak256()
        hash.Write(data)
        h := hash.Sum(nil)
        return BytesToHash(h)
}</span>

// Pad the input to the specified length
func PadToMultipleOfN(input []byte, n int) []byte <span class="cov0" title="0">{
        return padToMultipleOfN(input, n)
}</span>

func padToMultipleOfN(input []byte, n int) []byte <span class="cov0" title="0">{
        length := len(input)
        mod := (length+n-1)%n + 1

        // Calculate the padding
        padding := 0
        if mod != 0 </span><span class="cov0" title="0">{
                padding = n - mod
        }</span>

        // Fill the padding
        <span class="cov0" title="0">for i := 0; i &lt; padding; i++ </span><span class="cov0" title="0">{
                input = append(input, 0)
        }</span>
        <span class="cov0" title="0">return input</span>
}

// used for justification.. with $node as salt
func ComputeLeafHash_WBT_Blake2B(data []byte) Hash <span class="cov0" title="0">{
        h, _ := blake2b.New256(nil)
        h.Write([]byte("leaf"))
        h.Write(data)
        return Hash(h.Sum(nil))
}</span>

func IsNilHash(h Hash) bool <span class="cov0" title="0">{
        return h == Hash{}
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package common

import (
        "encoding/binary"
)

// (h,l) -&gt; E4(l)++H(h) for a_l
func Compute_preimageLookup_internal(blob_hash Hash, blob_len uint32) Hash <span class="cov0" title="0">{
        lBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(lBytes, blob_len)  // E4(l)
        h_blobHash := ComputeHash(blob_hash.Bytes())     // H(h) -- hash of blobHash
        al_internal_key := append(lBytes, h_blobHash...) // (E4(l) ⌢ H(h) -- this is 36 bytes. but only the first 32 bytes matters
        al_32 := al_internal_key[:32]
        return BytesToHash(al_32)
}</span>

// h -&gt; E4(2^32-2)++h1...h29 for a_p
func Compute_preimageBlob_internal(blob_hash Hash) Hash <span class="cov0" title="0">{
        //2^32 - 2 or fffffffe (BE)
        prefixBytes := make([]byte, 4)
        prefix := uint32(4294967294)
        binary.LittleEndian.PutUint32(prefixBytes, prefix)

        ap_internal_key := append(prefixBytes, blob_hash[1:29]...)
        ap_32 := ap_internal_key[:32]
        return BytesToHash(ap_32)
}</span>

// k -&gt; E4(2^32-1)++k0...k28 for a_s

func Compute_storageKey_internal(s uint32, k []byte) Hash <span class="cov0" title="0">{
        sBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(sBytes, s)     // E4(s)
        raw_key := ComputeHash(append(sBytes, k...)) // H(E4(s) ⌢ vk ⋅⋅⋅+k )
        return BytesToHash(raw_key)
}</span>

func Compute_storageKey_internal_byte(s uint32, k []byte) []byte <span class="cov0" title="0">{
        sBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(sBytes, s)     // E4(s)
        raw_key := ComputeHash(append(sBytes, k...)) // H(E4(s) ⌢ vk ⋅⋅⋅+k )
        return raw_key
}</span>

// EQ 290 - state-key constructor functions C
func ComputeC_i(i uint8) Hash <span class="cov0" title="0">{
        //i ∈ N_8 ↦ [i,0,0,...]
        stateKey := make([]byte, 32)
        stateKey[0] = byte(i)
        return BytesToHash(stateKey)
}</span>

func ComputeC_is(i uint8, s uint32) Hash <span class="cov0" title="0">{
        //(i,s ∈ N_S) ↦ [i,n0,n1,n2,n3,0,0,...] where n = E4(s)
        stateKey := make([]byte, 32)
        stateKey[0] = i
        byteSlice := make([]byte, 4)
        binary.LittleEndian.PutUint32(byteSlice, s)
        for i := 1; i &lt; 5; i++ </span><span class="cov0" title="0">{
                stateKey[i] = byteSlice[i-1]
        }</span>
        <span class="cov0" title="0">return BytesToHash(stateKey)</span>
}

func ComputeC_sh(s uint32, h0 Hash) Hash <span class="cov0" title="0">{
        //s: service_index
        //h: hash_component (assumed to be exact 32bytes)
        //(s,h) ↦ [n0,h0,n1,h1,n2,h2,n3,h3,h4,h5,...,h27] where n = E4(s)
        h := h0.Bytes()
        stateKey := make([]byte, 32)
        nBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(nBytes, s) // n = E4(s)

        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                stateKey[2*i] = nBytes[i]
                if i &lt; 32 </span><span class="cov0" title="0">{
                        stateKey[2*i+1] = h[i]
                }</span>
        }
        <span class="cov0" title="0">for i := 4; i &lt; 28; i++ </span><span class="cov0" title="0">{
                if i &lt; len(h) </span><span class="cov0" title="0">{
                        stateKey[i+4] = h[i]
                }</span>
        }
        <span class="cov0" title="0">return BytesToHash(stateKey)</span>
}

func ComputeC_sh_Byte(s uint32, h0 []byte) Hash <span class="cov0" title="0">{
        //s: service_index
        //h: hash_component (assumed to be exact 32bytes)
        //(s,h) ↦ [n0,h0,n1,h1,n2,h2,n3,h3,h4,h5,...,h27] where n = E4(s)
        h := make([]byte, 32)
        copy(h, h0)
        stateKey := make([]byte, 32)
        nBytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(nBytes, s) // n = E4(s)

        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                stateKey[2*i] = nBytes[i]
                if i &lt; 32 </span><span class="cov0" title="0">{
                        stateKey[2*i+1] = h[i]
                }</span>
        }
        <span class="cov0" title="0">for i := 4; i &lt; 28; i++ </span><span class="cov0" title="0">{
                if i &lt; len(h) </span><span class="cov0" title="0">{
                        stateKey[i+4] = h[i]
                }</span>
        }
        <span class="cov0" title="0">return BytesToHash(stateKey)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package common

import (
        "bytes"
        "crypto/ecdsa"
        "errors"
        "fmt"
        "github.com/ethereum/go-ethereum/crypto"
)

// EthSign signs the given authToken using the provided private key in hex format.
// It returns the message hash, the 65-byte signature, and any error encountered.
func EthSign(privateKeyHex string, authToken []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        // Convert the private key hex string to ECDSA private key
        privateKey, err := crypto.HexToECDSA(privateKeyHex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error converting private key: %v", err)
        }</span>

        // Ethereum message prefix
        <span class="cov8" title="1">message := append([]byte("\x19Ethereum Signed Message:\n32"), authToken...)

        messageHash := Keccak256(message).Bytes()

        // Sign the hash
        signature, err := crypto.Sign(messageHash, privateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("error signing the hash: %v", err)
        }</span>

        <span class="cov8" title="1">return messageHash, signature, nil</span>
}

// VerifyEthSignature verifies the Ethereum signature against the provided public key and message hash.
// Returns an error if the signature is invalid or does not match.
func VerifyEthSignature(publicKey *ecdsa.PublicKey, messageHash, signature []byte) error <span class="cov8" title="1">{
        // Recover the public key from the signature
        recoveredPubKey, err := crypto.SigToPub(messageHash, signature)
        if err != nil </span><span class="cov0" title="0">{
                return errors.New("error recovering public key from signature")
        }</span>

        // Compare the recovered public key with the provided public key
        <span class="cov8" title="1">sigPublicKeyBytes := crypto.FromECDSAPub(recoveredPubKey)
        publicKeyBytes := crypto.FromECDSAPub(publicKey)

        if !bytes.Equal(sigPublicKeyBytes, publicKeyBytes) </span><span class="cov0" title="0">{
                return errors.New("public key does not match")
        }</span>

        // Verify using crypto.VerifySignature
        <span class="cov8" title="1">signatureNoRecoverID := signature[:len(signature)-1] // remove recovery id
        valid := crypto.VerifySignature(publicKeyBytes, messageHash, signatureNoRecoverID)
        if !valid </span><span class="cov0" title="0">{
                return errors.New("signature verification failed")
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package common

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "os"
        "path/filepath"
        "reflect"
        "time"
)

// encodeUint64 encodes a uint64 value into a byte slice in LittleEndian order
func EncodeUint64(num uint64) []byte <span class="cov0" title="0">{
        buf := make([]byte, 8)
        binary.LittleEndian.PutUint64(buf, num)
        return buf
}</span>

// decodeUint64 decodes a byte slice into an int value in LittleEndian order
func DecodeUint64(data []byte) int <span class="cov0" title="0">{
        if len(data) != 8 </span><span class="cov0" title="0">{
                fmt.Println("Invalid byte slice length")
                return 0
        }</span>
        <span class="cov0" title="0">return int(binary.LittleEndian.Uint64(data))</span>
}

// This is FAKE
func ComputeCurrentJCETime() uint32 <span class="cov0" title="0">{
        currentTime := time.Now().Unix()
        return uint32(currentTime) // computeJCETime(currentTime)
}</span>

func ComputeRealCurrentJCETime(TimeUnitMode string) uint32 <span class="cov0" title="0">{
        currentTime := time.Now().Unix()
        if TimeUnitMode == "TimeStamp" </span><span class="cov0" title="0">{
                return uint32(ComputeJCETime(currentTime, false))
        }</span> else<span class="cov0" title="0"> {
                return uint32(ComputeJCETime(currentTime, true))
        }</span>
}

// here if I use types.SecondPerSlot, it will be a circular import
func ComputeTimeSlot(TimeUnitMode string) uint32 <span class="cov0" title="0">{
        currentTime := time.Now().Unix()
        JCE := uint32(ComputeJCETime(currentTime, true))
        timeslot := JCE / 6
        return timeslot
}</span>

func ComputeTimeUnit(TimeUnitMode string) uint32 <span class="cov0" title="0">{
        unit := ComputeTimeSlot(TimeUnitMode)
        if TimeUnitMode == "TimeStamp" </span><span class="cov0" title="0">{
                unit = ComputeRealCurrentJCETime(TimeUnitMode)
        }</span>
        <span class="cov0" title="0">return unit</span>
}

var JceStart = time.Date(2024, time.January, 1, 12, 0, 0, 0, time.UTC)

func AddJamStart(time time.Duration) <span class="cov0" title="0">{
        JceStart = JceStart.Add(time)
}</span>

// Jam Common Era: 1704110400 or Jan 01 2024 12:00:00 GMT+0000; See section 4.4
func ComputeJCETime(unixTimestamp int64, production bool) int64 <span class="cov0" title="0">{
        if production </span><span class="cov0" title="0">{
                // Define the start of the Jam Common Era

                // Convert the Unix timestamp to a Time object
                currentTime := time.Unix(unixTimestamp, 0).UTC()

                // Calculate the difference in seconds
                diff := currentTime.Sub(JceStart)
                return int64(diff.Seconds())
        }</span> else<span class="cov0" title="0"> {
                return unixTimestamp
        }</span>
}

func ComputeCurrenTS() uint32 <span class="cov0" title="0">{
        currentTime := time.Now().Unix()
        return uint32(currentTime)
}</span>

func CompareBytes(b1 []byte, b2 []byte) bool <span class="cov0" title="0">{
        return bytes.Equal(b1, b2)
}</span>

func CompareKeys(b1, b2 []byte) int <span class="cov0" title="0">{
        // Find the minimum length of the two slices
        minLen := len(b1)
        if len(b2) &lt; minLen </span><span class="cov0" title="0">{
                minLen = len(b2)
        }</span>

        // Compare byte by byte
        <span class="cov0" title="0">for i := 0; i &lt; minLen; i++ </span><span class="cov0" title="0">{
                if b1[i] &lt; b2[i] </span><span class="cov0" title="0">{
                        return -1 // b1 is smaller than b2
                }</span> else<span class="cov0" title="0"> if b1[i] &gt; b2[i] </span><span class="cov0" title="0">{
                        return 1 // b1 is greater than b2
                }</span>
        }

        // If all compared bytes are equal, compare lengths
        <span class="cov0" title="0">if len(b1) &lt; len(b2) </span><span class="cov0" title="0">{
                return -1 // b1 is smaller than b2
        }</span> else<span class="cov0" title="0"> if len(b1) &gt; len(b2) </span><span class="cov0" title="0">{
                return 1 // b1 is greater than b2
        }</span>

        // If lengths are also equal, the slices are identical
        <span class="cov0" title="0">return 0</span>
}

func FalseBytes(data []byte) []byte <span class="cov0" title="0">{
        result := make([]byte, len(data))
        for i := 0; i &lt; len(data); i++ </span><span class="cov0" title="0">{
                result[i] = 0xFF - data[i]
                // result[i] = ^data[i]
        }</span>
        <span class="cov0" title="0">return result</span>
}

func ConvertToSlice(arr interface{}) []byte <span class="cov0" title="0">{
        // Use reflection to handle different lengths of fixed-length arrays
        v := reflect.ValueOf(arr)

        if v.Kind() != reflect.Array </span><span class="cov0" title="0">{
                panic("input is not an array")</span>
        }

        // Convert to a byte slice
        <span class="cov0" title="0">byteSlice := make([]byte, v.Len())
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                byteSlice[i] = byte(v.Index(i).Uint())
        }</span>

        <span class="cov0" title="0">return byteSlice</span>
}

// ConcatenateByteSlices concatenates a slice of byte slices into a single byte slice
func ConcatenateByteSlices(slices [][]byte) []byte <span class="cov0" title="0">{
        // Calculate the total length of the concatenated byte slice
        totalLen := 0
        for _, b := range slices </span><span class="cov0" title="0">{
                totalLen += len(b)
        }</span>

        // Create a single byte slice with the total length
        <span class="cov0" title="0">result := make([]byte, 0, totalLen)

        // Append each byte slice to the result
        for _, b := range slices </span><span class="cov0" title="0">{
                result = append(result, b...)
        }</span>

        <span class="cov0" title="0">return result</span>
}

func CompactPath(path []Hash) []byte <span class="cov0" title="0">{
        combined := make([]byte, 0)
        for _, h := range path </span><span class="cov0" title="0">{
                combined = append(combined, h[:]...)
        }</span>
        <span class="cov0" title="0">return combined</span>
}

func ExpandPath(compact []byte) ([]Hash, error) <span class="cov0" title="0">{
        if len(compact)%32 != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid compact path length, must be a multiple of 32")
        }</span>
        <span class="cov0" title="0">hashCount := len(compact) / 32
        hashes := make([]Hash, hashCount)
        for i := 0; i &lt; hashCount; i++ </span><span class="cov0" title="0">{
                var hash Hash
                copy(hash[:], compact[i*32:(i+1)*32]) // Copy 32 bytes into the hash
                hashes[i] = hash
        }</span>
        <span class="cov0" title="0">return hashes, nil</span>
}

func GetFilePath(fn string) string <span class="cov0" title="0">{
        // Use environment variable JAM_PATH, but if its not set, use
        basePath := os.Getenv("JAM_PATH")
        if basePath == "" </span><span class="cov0" title="0">{
                basePath = "/root/go/src/github.com/colorfulnotion/jam/"
        }</span>

        // Construct the full file path using filepath package
        <span class="cov0" title="0">return filepath.Join(basePath, fn)</span>
}

func Uint16Contains(slice []uint16, value uint16) bool <span class="cov0" title="0">{
        for _, v := range slice </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func StrContains(slice []string, value string) bool <span class="cov0" title="0">{
        for _, v := range slice </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func HashContains(slice []Hash, value Hash) bool <span class="cov0" title="0">{
        for _, v := range slice </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package erasurecoding

import (
        "fmt"
        "github.com/colorfulnotion/jam/types"
        "github.com/klauspost/reedsolomon"
)

var (
        // Configurations for the erasure coding library. See https://pkg.go.dev/github.com/klauspost/reedsolomon#New
        // TODO: Coding rate has been changed to 342:1023 in the latest version of the GP.
        // CodingRate_K                int = 2 // coding rate = 342:1023. See GP, Appendix H for more details.
        // CodingRate_N                int = 6 // coding rate = 342:1023. See GP, Appendix H for more details.
        // numPieces int = 6 // k = 6, shard size = k * 2. See GP, Appendix H.1 for more details.
        GFPointsSize = 2 //  little-endian Y2 (E2)
)

const (
        dataShards   = 2
        parityShards = 4
)

func GetCodingRate() (coding_rate_K int, coding_rate_N int) <span class="cov8" title="1">{
        coding_rate_K = types.W_E / 2
        coding_rate_N = types.TotalValidators
        return coding_rate_K, coding_rate_N
}</span>

// numPieces k or C_k is the number of data-parallel pieces, each of size where p ∈ ⟦Y_WC⟧ = unzip (p).
func Encode(original []byte, numPieces int) ([][][]byte, error) <span class="cov8" title="1">{
        // TODO: Using non-inplace operation on buffer, output is a bit memory inefficient.

        // Get coding rate K, N
        CodingRate_K, CodingRate_N := GetCodingRate()

        // Calculate the shardSize
        shardSize := numPieces * GFPointsSize                // 1 GF point = 2 bytes (E2)
        shardSizeRounded := 64 * ((shardSize + 64 - 1) / 64) // round up to 64 bytes. See https://github.com/klauspost/reedsolomon?tab=readme-ov-file#leopard-compatible-gf16
        dataSegmentSize := shardSize * CodingRate_K

        // Calculate the dataShards (original) and parityShards (redundant) arguments for the RS function
        dataShards := CodingRate_K
        parityShards := (CodingRate_N - CodingRate_K) // N = K + parityShards

        // Initialize the RS encoder
        encoder, err := reedsolomon.New(dataShards, parityShards, reedsolomon.WithLeopardGF16(true), reedsolomon.WithAutoGoroutines(shardSizeRounded))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Calculate the number of segments, create the buffer and output.
        <span class="cov8" title="1">numSegments := (len(original) + dataSegmentSize - 1) / dataSegmentSize
        buffer := make([][][]byte, numSegments) // Buffer to store the encoded data with padding. (numSegments, dataShards + parityShards, shardSizePadded)
        output := make([][][]byte, numSegments) // Buffer to store the encoded data WITHOUT padding. (numSegments, dataShards + parityShards, shardSize)

        // Fill the buffer/output with the original data and calculate the parity shards for each segment
        for segmentIndex := 0; segmentIndex &lt; numSegments; segmentIndex++ </span><span class="cov8" title="1">{

                buffer[segmentIndex] = make([][]byte, (dataShards + parityShards))
                output[segmentIndex] = make([][]byte, (dataShards + parityShards))

                for shardIndex := 0; shardIndex &lt; (dataShards + parityShards); shardIndex++ </span><span class="cov8" title="1">{

                        // Initialize the shard filled with zeros
                        buffer[segmentIndex][shardIndex] = make([]byte, shardSizeRounded)
                        output[segmentIndex][shardIndex] = make([]byte, shardSize)

                        if shardIndex &lt; dataShards </span><span class="cov8" title="1">{

                                // Assign the original data to the shard. NOTE: Only the first 6 GF points are used.
                                for GFPointIndex := 0; GFPointIndex &lt; numPieces; GFPointIndex++ </span><span class="cov8" title="1">{

                                        // Please note that the data are stored in the buffer vertically, from top to bottom and left to right.
                                        leftIndex := segmentIndex*dataSegmentSize + GFPointIndex*dataShards*2 + shardIndex*2
                                        rightIndex := leftIndex + 1

                                        offset := (GFPointIndex / 32) * 64
                                        index := GFPointIndex % 32

                                        if leftIndex &lt; len(original) </span><span class="cov8" title="1">{
                                                buffer[segmentIndex][shardIndex][offset+index] = original[leftIndex]
                                        }</span>
                                        <span class="cov8" title="1">if rightIndex &lt; len(original) </span><span class="cov8" title="1">{
                                                buffer[segmentIndex][shardIndex][offset+index+32] = original[rightIndex]
                                        }</span>
                                }
                        }
                }

                // Calculate the parity shards for the i-th segment
                <span class="cov8" title="1">err = encoder.Encode(buffer[segmentIndex])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Copy the buffer to the output
                <span class="cov8" title="1">for j := 0; j &lt; (dataShards + parityShards); j++ </span><span class="cov8" title="1">{
                        for GFPointIndex := 0; GFPointIndex &lt; numPieces; GFPointIndex++ </span><span class="cov8" title="1">{

                                offset := (GFPointIndex / 32) * 64
                                index := GFPointIndex % 32

                                output[segmentIndex][j][GFPointIndex*2] = buffer[segmentIndex][j][offset+index]
                                output[segmentIndex][j][GFPointIndex*2+1] = buffer[segmentIndex][j][offset+index+32]
                        }</span>
                }
        }

        <span class="cov8" title="1">return output, nil</span>
}

func Decode(encodedData [][][]byte, numPieces int) ([]byte, error) <span class="cov8" title="1">{

        // Get coding rate K, N
        CodingRate_K, CodingRate_N := GetCodingRate()

        // Calculate the shardSize
        shardSize := numPieces * GFPointsSize // 1 GF point = 2 bytes (E2)
        dataSegmentSize := shardSize * CodingRate_K
        shardSizeRounded := 64 * ((shardSize + 64 - 1) / 64) // round up to 64 bytes. See:         shardSizeRounded := 64 * ((shardSize + 64 - 1) / 64) // round up to 64 bytes. See https://github.com/klauspost/reedsolomon?tab=readme-ov-file#leopard-compatible-gf16
        numSegments := len(encodedData)

        // Calculate the dataShards (original) and parityShards (redundant) arguments for the RS function
        dataShards := CodingRate_K
        parityShards := (CodingRate_N - CodingRate_K) // N = K + parityShards

        // Initialize the RS decoder
        decoder, err := reedsolomon.New(dataShards, parityShards, reedsolomon.WithLeopardGF16(true)) //, reedsolomon.WithAutoGoroutines(shardSizeRounded))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Decode the segments
        <span class="cov8" title="1">data := make([]byte, (numSegments * dataSegmentSize))
        for segmentIndex := 0; segmentIndex &lt; len(encodedData); segmentIndex++ </span><span class="cov8" title="1">{
                decodedSegment := make([][]byte, CodingRate_N)
                for i := 0; i &lt; len(encodedData[segmentIndex]); i++ </span><span class="cov8" title="1">{
                        decodedSegment[i] = make([]byte, shardSizeRounded)
                        if encodedData[segmentIndex][i] == nil </span><span class="cov8" title="1">{
                                decodedSegment[i] = nil
                        }</span> else<span class="cov8" title="1"> {
                                for GFPointIndex := 0; GFPointIndex &lt; numPieces; GFPointIndex++ </span><span class="cov8" title="1">{

                                        offset := (GFPointIndex / 32) * 64
                                        index := GFPointIndex % 32

                                        decodedSegment[i][offset+index] = encodedData[segmentIndex][i][GFPointIndex*2]
                                        decodedSegment[i][offset+index+32] = encodedData[segmentIndex][i][GFPointIndex*2+1]
                                }</span>
                        }
                }

                // Decode the segment
                <span class="cov8" title="1">err = decoder.ReconstructData(decodedSegment)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Copy the decoded data to the output
                <span class="cov8" title="1">for shardIndex := 0; shardIndex &lt; dataShards; shardIndex++ </span><span class="cov8" title="1">{
                        for GFPointIndex := 0; GFPointIndex &lt; numPieces; GFPointIndex++ </span><span class="cov8" title="1">{

                                // Please note that the data are stored in the buffer vertically, from top to bottom and left to right.
                                leftIndex := segmentIndex*dataSegmentSize + GFPointIndex*dataShards*2 + shardIndex*2
                                rightIndex := leftIndex + 1

                                offset := (GFPointIndex / 32) * 64
                                index := GFPointIndex % 32

                                data[leftIndex] = decodedSegment[shardIndex][offset+index]
                                data[rightIndex] = decodedSegment[shardIndex][offset+index+32]
                        }</span>
                }
        }

        <span class="cov8" title="1">return data, nil</span>
}

func Print3DByteArray(arr [][][]byte) <span class="cov0" title="0">{
        for i := range arr </span><span class="cov0" title="0">{
                fmt.Printf("Segment %d:\n", i)
                fmt.Println("----------------")
                for j := range arr[i] </span><span class="cov0" title="0">{
                        for k := range arr[i][j] </span><span class="cov0" title="0">{
                                fmt.Printf("%02x ", arr[i][j][k])
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
                <span class="cov0" title="0">fmt.Println("----------------")</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package pvm

import (
        "encoding/binary"
        "fmt"
        "time"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/sp1"
        "github.com/colorfulnotion/jam/types"
)

// Appendix B - Host function
// Host function indexes
const (
        GAS               = 0
        LOOKUP            = 1
        READ              = 2
        WRITE             = 3
        INFO              = 4
        BLESS             = 5
        ASSIGN            = 6
        DESIGNATE         = 7
        CHECKPOINT        = 8
        NEW               = 9
        UPGRADE           = 10
        TRANSFER          = 11
        QUIT              = 12
        SOLICIT           = 13
        FORGET            = 14
        HISTORICAL_LOOKUP = 15
        IMPORT            = 16
        EXPORT            = 17
        MACHINE           = 18
        PEEK              = 19
        POKE              = 20
        ZERO              = 21
        VOID              = 22
        INVOKE            = 23
        EXPUNGE           = 24
        LOG               = 100
        SP1GROTH16VERIFY  = 101
        FOR_TEST          = 105
)

const maxUint64 = ^uint64(0)

const (
        Debug_Service_Storage = false
)

const (
        g = 10
)

// Mapping of host function names to their error cases
var errorCases = map[string][]uint64{
        // B.6 General Functions
        "Gas":              {OK},
        "Lookup":           {OK, NONE, OOB},
        "Read":             {OK, OOB, NONE},
        "Write":            {OK, OOB, NONE, FULL},
        "Info":             {OK, OOB, NONE},
        "Sp1Groth16Verify": {OK, OOB, HUH},
        // B.7 Accumulate Functions
        "Bless":      {OK, OOB, WHO},
        "Assign":     {OK, OOB, CORE},
        "Designate":  {OK, OOB},
        "Checkpoint": {OK},
        "New":        {OK, OOB, CASH},
        "Upgrade":    {OK, OOB},
        "Transfer":   {OK, WHO, CASH, LOW, HIGH},
        "Quit":       {OK, OOB, WHO, LOW},
        "Solicit":    {OK, OOB, FULL, HUH},
        "Forget":     {OK, OOB, HUH},
        // B.8 Refine Functions
        "Historical_lookup": {OK, OOB},
        "Import":            {OK, OOB, NONE},
        "Export":            {OK, OOB, NONE},
        "Machine":           {OK, OOB},
        "Peek":              {OK, OOB, WHO},
        "Poke":              {OK, OOB, WHO},
        "Zero":              {OK, OOB, WHO},
        "Void":              {OK, OOB, WHO},
        "Invoke":            {OK, OOB, WHO, HOST, FAULT, OOB, PANIC},
        "Expunge":           {OK, OOB, WHO},
}

// Mapping of host function names to their indexes
var hostIndexMap = map[string]int{
        // B.6 General Functions
        "Gas":              GAS,
        "Lookup":           LOOKUP,
        "Read":             READ,
        "Write":            WRITE,
        "Info":             INFO,
        "Sp1Groth16Verify": SP1GROTH16VERIFY,
        // B.7 Accumulate Functions
        "Bless":      BLESS,
        "Assign":     ASSIGN,
        "Designate":  DESIGNATE,
        "Checkpoint": CHECKPOINT,
        "New":        NEW,
        "Upgrade":    UPGRADE,
        "Transfer":   TRANSFER,
        "Quit":       QUIT,
        "Solicit":    SOLICIT,
        "Forget":     FORGET,
        // B.8 Refine Functions
        "Historical_lookup": HISTORICAL_LOOKUP,
        "Import":            IMPORT,
        "Export":            EXPORT,
        "Machine":           MACHINE,
        "Peek":              PEEK,
        "Poke":              POKE,
        "Zero":              ZERO,
        "Void":              VOID,
        "Invoke":            INVOKE,
        "Expunge":           EXPUNGE,
        // Other
        "Log":      LOG,
        "For_test": FOR_TEST,
}

// Function to retrieve index and error cases
func GetHostFunctionDetails(name string) (int, []uint64) <span class="cov0" title="0">{
        index, exists := hostIndexMap[name]
        if !exists </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">errors, hasErrors := errorCases[name]
        if !hasErrors </span><span class="cov0" title="0">{
                errors = []uint64{} // No error cases defined
        }</span>
        <span class="cov0" title="0">return index, errors</span>
}

type RefineM struct {
        P []byte `json:"P"`
        U *RAM   `json:"U"`
        I uint32 `json:"I"`
}

type RefineM_map map[uint32]*RefineM

// GP-0.5 B.5
type Refine_parameters struct {
        Gas                  uint64
        Ram                  *RAM
        Register             []uint32
        Machine              RefineM_map
        Export_segment       [][]byte
        Import_segement      [][]byte
        Export_segment_index uint32
        service_index        uint32
        Delta                map[uint32]uint32
        C_t                  uint32
}

// false byte
func falseBytes(data []byte) []byte <span class="cov0" title="0">{
        result := make([]byte, len(data))
        for i := 0; i &lt; len(data); i++ </span><span class="cov0" title="0">{
                result[i] = 0xFF - data[i]
                // result[i] = ^data[i]
        }</span>
        <span class="cov0" title="0">return result</span>
}

// InvokeHostCall handles host calls
// Returns true if the call results in a halt condition, otherwise false
func (vm *VM) InvokeHostCall(host_fn int) (bool, error) <span class="cov0" title="0">{
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("vm.host_fn=%v\n", vm.host_func_id) //Do you need operand here?
        }</span>
        <span class="cov0" title="0">vm.Gas = vm.Gas - g
        switch host_fn </span>{
        case GAS:<span class="cov0" title="0">
                vm.hostGas()
                return true, nil</span>

        case LOOKUP:<span class="cov0" title="0">
                vm.hostLookup()
                return true, nil</span>

        case READ:<span class="cov0" title="0">
                vm.hostRead()
                return true, nil</span>

        case WRITE:<span class="cov0" title="0">
                vm.hostWrite()
                return true, nil</span>

        case INFO:<span class="cov0" title="0">
                vm.hostInfo()
                return true, nil</span>

        case BLESS:<span class="cov0" title="0">
                vm.hostBless()
                return true, nil</span>

        case ASSIGN:<span class="cov0" title="0">
                vm.hostAssign()
                return true, nil</span>

        case DESIGNATE:<span class="cov0" title="0">
                vm.hostDesignate()
                return true, nil</span>

        case CHECKPOINT:<span class="cov0" title="0">
                vm.hostCheckpoint()
                return true, nil</span>

        case NEW:<span class="cov0" title="0">
                vm.hostNew()
                return true, nil</span>

        case UPGRADE:<span class="cov0" title="0">
                vm.hostUpgrade()
                return true, nil</span>

        case TRANSFER:<span class="cov0" title="0">
                vm.hostTransfer()
                return true, nil</span>

        case QUIT:<span class="cov0" title="0">
                vm.hostQuit()
                return true, nil</span>

        case SOLICIT:<span class="cov0" title="0">
                t := vm.hostenv.GetTimeslot()
                vm.hostSolicit(t)
                return true, nil</span>

        case FORGET:<span class="cov0" title="0">
                t := vm.hostenv.GetTimeslot()
                vm.hostForget(t)
                return true, nil</span>

        // Refine functions
        case HISTORICAL_LOOKUP:<span class="cov0" title="0">
                vm.hostHistoricalLookup(0)
                return true, nil</span>

        case IMPORT:<span class="cov0" title="0">
                vm.hostImport()
                return true, nil</span>

        case EXPORT:<span class="cov0" title="0">
                vm.hostExport(0)
                return true, nil</span>

        case MACHINE:<span class="cov0" title="0">
                vm.hostMachine()
                return true, nil</span>

        case PEEK:<span class="cov0" title="0">
                vm.hostPeek()
                return true, nil</span>

        case POKE:<span class="cov0" title="0">
                vm.hostPoke()
                return true, nil</span>

        case ZERO:<span class="cov0" title="0">
                vm.hostZero()
                return true, nil</span>

        case VOID:<span class="cov0" title="0">
                vm.hostVoid()
                return true, nil</span>

        case INVOKE:<span class="cov0" title="0">
                vm.hostInvoke()
                return true, nil</span>

        case EXPUNGE:<span class="cov0" title="0">
                vm.hostExpunge()
                return true, nil</span>

        case LOG:<span class="cov0" title="0">
                vm.hostLog()
                return true, nil</span>

        case SP1GROTH16VERIFY:<span class="cov0" title="0">
                vm.hostSP1Groth16Verify()
                return true, nil</span>

        default:<span class="cov0" title="0">
                vm.Gas = vm.Gas + g
                return false, fmt.Errorf("unknown host call: %d\n", host_fn)</span>
        }
}

func min(x, y int) int <span class="cov0" title="0">{
        if x &lt; y </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">return y</span>
}

// Information-on-Service
func (vm *VM) hostInfo() uint64 <span class="cov0" title="0">{
        omega_7, _ := vm.ReadRegister(7)

        t, errCode := vm.getXUDS(omega_7)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">bo, _ := vm.ReadRegister(8)

        e := []interface{}{t.CodeHash, t.Balance, t.GasLimitG, t.GasLimitM}
        m, err := types.Encode(e)
        if err != nil </span><span class="cov0" title="0">{
                return NONE
        }</span>
        <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(bo), m[:])

        return OK</span>
}

// Bless updates
func (vm *VM) hostBless() uint64 <span class="cov0" title="0">{
        m, _ := vm.ReadRegister(7)
        a, _ := vm.ReadRegister(8)
        v, _ := vm.ReadRegister(9)
        // Set (x'p)_m, (x'p)_a, (x'p)_v
        vm.X.U.PrivilegedState.Kai_m = uint32(m)
        vm.X.U.PrivilegedState.Kai_a = uint32(a)
        vm.X.U.PrivilegedState.Kai_v = uint32(v)
        return OK
}</span>

// Assign Core x_c[i]
func (vm *VM) hostAssign() uint64 <span class="cov0" title="0">{
        core, _ := vm.ReadRegister(7)
        if core &gt;= numCores </span><span class="cov0" title="0">{
                return CORE
        }</span>
        <span class="cov0" title="0">o, _ := vm.ReadRegister(8)
        c, _ := vm.Ram.ReadRAMBytes(uint32(o), 32*types.MaxAuthorizationQueueItems)
        qi := make([]common.Hash, 32)
        for i := 0; i &lt; 32; i++ </span><span class="cov0" title="0">{
                qi[i] = common.BytesToHash(c[i:(i + 32)])
        }</span>
        <span class="cov0" title="0">copy(vm.X.U.QueueWorkReport[core][:], qi[:])
        return OK</span>
}

// Designate validators
func (vm *VM) hostDesignate() uint64 <span class="cov0" title="0">{
        o, _ := vm.ReadRegister(7)
        v, errCode := vm.Ram.ReadRAMBytes(uint32(o), 176*V)
        if errCode == OOB </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">qi := make([]types.Validator, V)
        for i := 0; i &lt; types.TotalValidators; i++ </span><span class="cov0" title="0">{
                newv := types.Validator{}
                copy(newv.Bandersnatch[:], v[0:32])
                copy(newv.Ed25519[:], v[64:92])
                copy(newv.Bls[:], v[92:128])
                copy(newv.Metadata[:], v[128:])

                qi[i] = newv
        }</span>
        <span class="cov0" title="0">vm.X.U.UpcomingValidators = qi
        return OK</span>
}

// Checkpoint gets Gas-remaining
func (vm *VM) hostCheckpoint() uint32 <span class="cov0" title="0">{
        vm.Y = vm.X.Clone()
        vm.WriteRegister(7, uint64(vm.Gas)) // CHECK
        return OK
}</span>

func bump(i uint32) uint32 <span class="cov0" title="0">{
        const lowerLimit uint32 = 1 &lt;&lt; 8               // 2^8 = 256
        const upperLimit uint32 = (1 &lt;&lt; 32) - (1 &lt;&lt; 9) // 2^32 - 2^9 = 4294966784

        //(i - 256 + 42) =  (i - 241)??
        adjusted := int64(i) - int64(lowerLimit) + 42

        // need to make sure the result of the modulus operation is non-negative.
        // This is done by: ((adjusted % upperLimit) + upperLimit) % upperLimit.
        // This expression guarantees that if `adjusted` is negative, adding `upperLimit` first makes it positive.
        // Then, applying `% upperLimit` again ensures the result is within the range [0, upperLimit).
        // modResult := ((adjusted % int64(upperLimit)) + int64(upperLimit)) % int64(upperLimit)
        modResult := lowerLimit + uint32(adjusted)%upperLimit

        // Step 3: Return the result by adding `lowerLimit` back.
        // This aligns the final result with the desired range: [2^8, 2^32 - 2^9].
        // return lowerLimit + uint32(modResult)
        return uint32(modResult)
}</span>

func check(i uint32, u_d map[uint32]*types.ServiceAccount) uint32 <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                if _, ok := u_d[i]; !ok </span><span class="cov0" title="0">{
                        return i
                }</span>
                <span class="cov0" title="0">i = ((i - 256 + 1) % (4294967296 - 512)) + 256</span> // 2^32 - 2^9 + 2^8
        }
}

// New service
func (vm *VM) hostNew() uint64 <span class="cov0" title="0">{
        xContext := vm.X
        xs, _ := xContext.GetX_s()

        // put 'g' and 'm' together
        o, _ := vm.ReadRegister(7)
        c, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return errCode
        }</span>
        <span class="cov0" title="0">l, _ := vm.ReadRegister(8)
        g, _ := vm.ReadRegister(9)
        m, _ := vm.ReadRegister(10)

        xi := xContext.I

        // simulate a with c, g, m
        a := &amp;types.ServiceAccount{
                ServiceIndex:    xi,
                Mutable:         true,
                Dirty:           true,
                CodeHash:        common.BytesToHash(c),
                GasLimitG:       uint64(g),
                GasLimitM:       uint64(m),
                NumStorageItems: 2*1 + 0,            //a_s = 2⋅∣al∣+∣as∣
                StorageSize:     uint64(81 + l + 0), //a_l =  ∑ 81+z per (h,z) + ∑ 32+s
                Storage:         make(map[common.Hash]types.StorageObject),
                Lookup:          make(map[common.Hash]types.LookupObject),
                Preimage:        make(map[common.Hash]types.PreimageObject),
        }
        a.Balance = a.ComputeThreshold()
        // fmt.Printf("Service %d hostNew %v =&gt; %d, code hash: %v\n", s, a.CodeHash, a.GetServiceIndex(), common.BytesToHash(c))

        if debug_host </span><span class="cov0" title="0">{
                fmt.Printf("Service %d hostNew %v =&gt; %d\n", xContext.S, a.CodeHash, a.GetServiceIndex())
        }</span>
        // Compute footprint &amp; threshold: a_l, a_s, a-t

        <span class="cov0" title="0">xs.DecBalance(a.Balance)
        if xs.Balance &gt;= xs.ComputeThreshold() </span><span class="cov0" title="0">{
                //xs has enough balance to fund the creation of a AND covering its own threshold
                // xi' &lt;- check(bump(xi))
                // vm.WriteRegister(7, xi)
                // xContext.I = vm.hostenv.Check(bump(xi)) // this is the next xi
                xContext.I = check(bump(xi), xContext.U.D)

                // I believe this is the same as solicit. where l∶{(c, l)↦[]} need to be set, which will later be provided by E_P
                // a.WriteLookup(common.BytesToHash(c), l, []uint32{common.ComputeCurrenTS()})
                a.WriteLookup(common.BytesToHash(c), uint32(l), []uint32{}) // *** CHECK

                // (x's)b &lt;- (xs)b - at
                // xContext.S = a.ServiceIndex()

                // Here we are adding the new service account to the map
                xContext.U.D[xi] = a

                vm.X = xContext
                vm.WriteRegister(7, uint64(xi))
                return OK
        }</span> else<span class="cov0" title="0"> {
                if debug_host </span><span class="cov0" title="0">{
                        fmt.Println("Balance insufficient")
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(7, CASH)
                return CASH</span> //balance insufficient
        }
}

// Upgrade service
func (vm *VM) hostUpgrade() uint64 <span class="cov0" title="0">{
        xContext := vm.X
        xs, s := xContext.GetX_s()
        o, _ := vm.ReadRegister(7)
        gl, _ := vm.ReadRegister(8)
        gh, _ := vm.ReadRegister(9)
        ml, _ := vm.ReadRegister(10)
        mh, _ := vm.ReadRegister(11)
        c, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode == OOB </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">g := uint64(gh)&lt;&lt;32 + uint64(gl)
        m := uint64(mh)&lt;&lt;32 + uint64(ml)

        xs.Dirty = true
        xs.CodeHash = common.BytesToHash(c)
        xs.GasLimitG = g
        xs.GasLimitM = m
        xContext.D[s] = xs
        return OK</span>
}

// Transfer host call
func (vm *VM) hostTransfer() uint64 <span class="cov0" title="0">{
        d, _ := vm.ReadRegister(7)
        a, _ := vm.ReadRegister(8)
        g, _ := vm.ReadRegister(9)
        o, _ := vm.ReadRegister(10)

        // TODO check d -- WHO; check g -- LOW, HIGH
        m, errCode := vm.Ram.ReadRAMBytes(uint32(o), M)
        if errCode == OOB </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">t := types.DeferredTransfer{Amount: a, GasLimit: g, SenderIndex: vm.X.S, ReceiverIndex: uint32(d)} // CHECK
        copy(t.Memo[:], m[:])
        vm.X.T = append(vm.X.T, t)
        return OK</span>
}

// Gas Service
func (vm *VM) hostGas() uint32 <span class="cov0" title="0">{
        vm.WriteRegister(7, uint64(vm.Gas))
        return OK
}</span>

// Quit Service
func (vm *VM) hostQuit() uint32 <span class="cov0" title="0">{
        /*        d, _ := vm.ReadRegister(7)
                o, _ := vm.ReadRegister(8)
                xs, s := vm.X.GetX_s()
                a := xs.Balance - xs.StorageSize + types.BaseServiceBalance // TODO: (x_s)_t
                var transferMemo *TransferMemo
                if d == vm.X.S || d == maxUint64 {
                        transferMemo = nil
                } else {
                        o, _ := vm.ReadRegister(1)
                        transferMemo, _ := types.TransferMemoFromBytes(transferMemoBytes)
                        transferBytes, _ := vm.ReadRAMBytes(o, types.TransferMemoSize)
                }
                g := vm.ξ
        */
        return OK
}</span>
func (vm *VM) setGasRegister(gasBytes, registerBytes []byte) <span class="cov0" title="0">{

        // gas todo
        registers := make([]uint64, 13)
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                registers[i] = binary.LittleEndian.Uint64(registerBytes[i*8 : (i+1)*8])
        }</span>
        <span class="cov0" title="0">vm.register = registers</span>
}

// Invoke5
func (vm *VM) hostInvoke() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        gasBytes, errCodeGas := vm.Ram.ReadRAMBytes(uint32(o), 8)
        if errCodeGas != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>
        // gas := binary.LittleEndian.Uint32(gasBytes)
        <span class="cov0" title="0">m_n_reg := make([]uint32, 13)
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                reg_bytes, errCodeReg := vm.Ram.ReadRAMBytes(uint32(o)+8+4*uint32(i), 4)
                if errCodeReg != OK </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, OOB)
                        return OOB
                }</span>
                <span class="cov0" title="0">m_n_reg[i] = binary.LittleEndian.Uint32(reg_bytes)</span>
        }
        // intialize invoke

        <span class="cov0" title="0">registerBytes, _ := vm.Ram.ReadRAMBytes(uint32(o)+8, 13*8)
        m, ok := vm.GetVM(uint32(n))
        if !ok </span><span class="cov0" title="0">{
                return WHO
        }</span>
        <span class="cov0" title="0">m.setGasRegister(gasBytes, registerBytes)
        m.Execute(5)
        // put the register and gas back to the memory
        gas := binary.LittleEndian.Uint64(gasBytes)
        vm.PutGasAndRegistersToMemory(uint32(o), gas, m.register)
        // TODO: HOST, FAULT, PANIC
        return HALT</span>
}

// Lookup preimage
func (vm *VM) hostLookup() uint64 <span class="cov0" title="0">{
        s, _ := vm.ReadRegister(7)
        ho, _ := vm.ReadRegister(8)
        bo, _ := vm.ReadRegister(9)
        bz, _ := vm.ReadRegister(10)
        k_bytes, err_k := vm.Ram.ReadRAMBytes(uint32(ho), 32)
        if err_k == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(0, OOB)
                return OOB
        }</span>
        <span class="cov0" title="0">h := common.Blake2Hash(k_bytes)
        a, errCode := vm.getXUDS(s)
        if errCode != OK </span><span class="cov0" title="0">{
                return NONE
        }</span>
        <span class="cov0" title="0">ok, v := a.ReadPreimage(h, vm.hostenv)
        if !ok </span><span class="cov0" title="0">{
                return NONE
        }</span>
        <span class="cov0" title="0">l := uint64(len(v))
        if bz &lt; l </span><span class="cov0" title="0">{
                l = bz
        }</span>
        <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(bo), v[:l])

        if len(h) != 0 </span><span class="cov0" title="0">{
                vm.WriteRegister(7, l)
                return uint64(l)
        }</span> else<span class="cov0" title="0"> {
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>
}

func uint32ToBytes(s uint32) []byte <span class="cov0" title="0">{
        sbytes := make([]byte, 4)
        binary.LittleEndian.PutUint32(sbytes, s)
        return sbytes
}</span>

// Key Idea: fetch potential mutated (with Mutable=true) ServiceAccount from the XContext Partial State (X.U.D),
// which may have been changed
func (vm *VM) getXUDS(serviceindex uint64) (a *types.ServiceAccount, errCode uint64) <span class="cov0" title="0">{
        var ok bool
        var err error
        s := uint32(serviceindex)
        if serviceindex == maxUint64 || uint32(serviceindex) == vm.X.S </span><span class="cov0" title="0">{
                return vm.X.U.D[s], OK
        }</span>
        <span class="cov0" title="0">a, ok = vm.X.D[s]
        if !ok </span><span class="cov0" title="0">{
                a, ok, err = vm.hostenv.GetService(s)
                if err != nil || !ok </span><span class="cov0" title="0">{
                        return nil, NONE
                }</span>
                <span class="cov0" title="0">vm.X.D[s] = a</span>
        }
        <span class="cov0" title="0">return a, OK</span>
}

// Read Storage
func (vm *VM) hostRead() uint64 <span class="cov0" title="0">{
        // Assume that all ram can be read and written
        w7, _ := vm.ReadRegister(7)
        ko, _ := vm.ReadRegister(8)
        kz, _ := vm.ReadRegister(9)
        bo, _ := vm.ReadRegister(10)
        bz, _ := vm.ReadRegister(11)
        k, err_k := vm.Ram.ReadRAMBytes(uint32(ko), uint32(kz)) // this is the raw key.
        if err_k == OOB </span><span class="cov0" title="0">{
                fmt.Println("Read RAM Error")
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>
        // k for original raw key
        <span class="cov0" title="0">a, errCode := vm.getXUDS(w7)
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>

        <span class="cov0" title="0">var val []byte
        _, val = a.ReadStorage(k, vm.hostenv)
        l := uint64(len(val))
        if bz &lt; l </span><span class="cov0" title="0">{
                l = bz
        }</span>
        <span class="cov0" title="0">if len(k) != 0 </span><span class="cov0" title="0">{
                vm.Ram.WriteRAMBytes(uint32(bo), val[:l])
                vm.WriteRegister(7, l)
                return l
        }</span>
        <span class="cov0" title="0">return OK</span>
}

// Write Storage
func (vm *VM) hostWrite() uint64 <span class="cov0" title="0">{
        xContext := vm.X
        xs, s := xContext.GetX_s()

        // Assume that all ram can be read and written
        // Got storage of bold S(service account in GP) by setting s = 0, k = k(from RAM)
        ko, _ := vm.ReadRegister(7)
        kz, _ := vm.ReadRegister(8)
        vo, _ := vm.ReadRegister(9)
        vz, _ := vm.ReadRegister(10)
        k, err_k := vm.Ram.ReadRAMBytes(uint32(ko), uint32(kz))
        if err_k == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>

        // fmt.Printf("hostWrite s=%d, k=%v (%d) =&gt; Key: %v (hash(E_4(s)+k))\n", s, k, len(k), key)

        // C(255, s) ↦ a c ⌢E 8 (a b ,a g ,a m ,a l )⌢E 4 (a i ) ,
        <span class="cov0" title="0">a_t := uint64(0)
        if a_t &lt;= xs.Balance </span><span class="cov0" title="0">{
                // adjust S
                v := []byte{}
                if vz &gt; 0 </span><span class="cov0" title="0">{
                        v, _ = vm.Ram.ReadRAMBytes(uint32(vo), uint32(vz))
                }</span>

                <span class="cov0" title="0">if Debug_Service_Storage </span><span class="cov0" title="0">{
                        fmt.Printf("ServiceAccount.WriteStorage: s=%d xs.ServiceIndex=%d\n", s, xs.ServiceIndex)
                }</span>

                <span class="cov0" title="0">xs.WriteStorage(s, k, v)
                vm.WriteRegister(7, uint64(len(v)))
                //fmt.Printf("hostwrite: WriteStorage(%d, %v =&gt; %v) len(v)=%d Dirty: %v\n", s, key, v, len(v), xs.Dirty)
                return 0</span>
        } else<span class="cov0" title="0"> {
                vm.WriteRegister(7, FULL)
                return FULL
        }</span>
}

func (vm *VM) GetJCETime() uint32 <span class="cov0" title="0">{
        // timeslot mark

        // return common.ComputeCurrentJCETime()
        return common.ComputeTimeUnit(types.TimeUnitMode)
}</span>

// Solicit preimage
func (vm *VM) hostSolicit(t uint32) uint64 <span class="cov0" title="0">{
        xs, _ := vm.X.GetX_s()
        // Got l of X_s by setting s = 1, z = z(from RAM)
        o, _ := vm.ReadRegister(7)
        z, _ := vm.ReadRegister(8)                          // z: blob_len
        hBytes, err_h := vm.Ram.ReadRAMBytes(uint32(o), 32) // h: blobHash
        if err_h == OOB </span><span class="cov0" title="0">{
                fmt.Println("Read RAM Error")
                vm.WriteRegister(7, OOB)
                return OOB
        }</span>

        // check balance a_t &lt;= a_b
        /* TODO: william to figure out proper struct
        service_data := vm.hostenv.ReadServiceBytes(s) // read service account(X_s) where service index = 1
        if len(service_data) &gt; 0 {
                a_b_byte := service_data[len(service_data)-36 : len(service_data)-28]
                a_l_byte := service_data[len(service_data)-12 : len(service_data)-4]
                a_i_byte := service_data[len(service_data)-4:]
                a_b := binary.LittleEndian.Uint64(a_b_byte)
                a_l := binary.LittleEndian.Uint64(a_l_byte)
                a_i := binary.LittleEndian.Uint32(a_i_byte)
                a_t := 10 + uint64(1*a_i) + 100*a_l
                if a_b &lt; a_t {
                        fmt.Println("a_b &lt; a_t")
                        vm.WriteRegister(0, FULL)
                        return FULL
                }
        }
        */
        <span class="cov0" title="0">blobHash := common.Hash(hBytes)
        ok, X_s_l := xs.ReadLookup(blobHash, uint32(z), vm.hostenv)
        if !ok </span><span class="cov0" title="0">{
                return HUH
        }</span>
        // TODO: FULL
        //fmt.Printf("xs.ServiceIndex() = %d, blobHash = %v, z = %d, X_s_l = %v\n", xs.GetServiceIndex(), blobHash, z, X_s_l)
        <span class="cov0" title="0">if len(X_s_l) == 0 </span><span class="cov0" title="0">{
                // when preimagehash is not found, put it into solicit request - so we can ask other DAs
                xs.WriteLookup(blobHash, uint32(z), []uint32{})
                vm.WriteRegister(7, OK)
                return OK
        }</span> else<span class="cov0" title="0"> if X_s_l[0] == 2 </span><span class="cov0" title="0">{ // [x, y]
                xs.WriteLookup(blobHash, uint32(z), append(X_s_l, []uint32{t}...))
                vm.WriteRegister(7, OK)
                return OK
        }</span> else<span class="cov0" title="0"> {
                vm.WriteRegister(7, HUH)
                return HUH
        }</span>
}

// Forget preimage
func (vm *VM) hostForget(t uint32) uint64 <span class="cov0" title="0">{
        x_s, _ := vm.X.GetX_s()
        o, _ := vm.ReadRegister(7)
        z, _ := vm.ReadRegister(8)
        hBytes, errCode := vm.Ram.ReadRAMBytes(uint32(o), 32)
        if errCode == OOB </span><span class="cov0" title="0">{
                fmt.Println("Read RAM Error")
                return OOB
        }</span>

        <span class="cov0" title="0">blobHash := common.Hash(hBytes)
        ok, X_s_l := x_s.ReadLookup(blobHash, uint32(z), vm.hostenv)
        if !ok </span><span class="cov0" title="0">{
                return HUH
        }</span>
        <span class="cov0" title="0">if len(X_s_l) == 0 || (len(X_s_l) == 2 &amp;&amp; X_s_l[1] &lt; (t-D)) </span><span class="cov0" title="0">{
                x_s.WriteLookup(blobHash, uint32(z), []uint32{})
                vm.WriteRegister(7, OK)
                return OK
        }</span> else<span class="cov0" title="0"> if len(X_s_l) == 1 </span><span class="cov0" title="0">{
                x_s.WriteLookup(blobHash, uint32(z), append(X_s_l, []uint32{t}...))
                vm.WriteRegister(7, OK)
                return OK
        }</span> else<span class="cov0" title="0"> if len(X_s_l) == 3 &amp;&amp; X_s_l[1] &lt; (t-D) </span><span class="cov0" title="0">{
                X_s_l[2] = uint32(t)
                x_s.WriteLookup(blobHash, uint32(z), X_s_l)
                vm.WriteRegister(7, OK)
                return OK
        }</span> else<span class="cov0" title="0"> {
                vm.WriteRegister(7, HUH)
                return HUH
        }</span>
}

// HistoricalLookup determines whether the preimage of some hash h was available for lookup by some service account a at some timeslot t, and if so, provide its preimage
func (vm *VM) hostHistoricalLookup(t uint32) uint64 <span class="cov0" title="0">{
        // take a service s (from \omega_0 ),
        s := vm.Service_index
        ho, _ := vm.ReadRegister(8)
        bo, _ := vm.ReadRegister(9)
        bz, _ := vm.ReadRegister(10)

        hBytes, errCode := vm.Ram.ReadRAMBytes(uint32(ho), 32)
        if errCode == OOB </span><span class="cov0" title="0">{
                fmt.Println("Read RAM Error")
                vm.WriteRegister(0, OOB)
                return errCode
        }</span>
        <span class="cov0" title="0">h := common.Hash(hBytes)
        fmt.Println(h)
        v := vm.hostenv.HistoricalLookup(s, t, h)
        vLength := uint64(len(v))
        if vLength == 0 </span><span class="cov0" title="0">{
                vm.WriteRegister(7, NONE)
                return NONE
        }</span>

        <span class="cov0" title="0">if vLength != 0 </span><span class="cov0" title="0">{
                l := uint64(vLength)
                if bz &lt; l </span><span class="cov0" title="0">{
                        l = bz
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(uint32(bo), v[:l])
                vm.WriteRegister(7, vLength)
                fmt.Println(v[:l])
                return vLength</span>
        } else<span class="cov0" title="0"> {
                vm.WriteRegister(7, NONE)
                return NONE
        }</span>
}

// Import Segment
func (vm *VM) hostImport() uint64 <span class="cov0" title="0">{
        // import  - which copies  a specific i  (e.g. holding the bytes "9") into RAM from "ImportDA" to be "accumulated"
        omega_0, _ := vm.ReadRegister(7) // a0 = 7
        var v_Bytes []byte
        if omega_0 &lt; uint64(len(vm.Imports)) </span><span class="cov0" title="0">{
                v_Bytes = vm.Imports[omega_0][:]
        }</span> else<span class="cov0" title="0"> {
                v_Bytes = []byte{}
        }</span>
        <span class="cov0" title="0">o, _ := vm.ReadRegister(8) // a1 = 8
        l, _ := vm.ReadRegister(9) // a2 = 9
        if l &gt; (W_E * W_S) </span><span class="cov0" title="0">{
                l = W_E * W_S
        }</span>

        <span class="cov0" title="0">if len(v_Bytes) != 0 </span><span class="cov0" title="0">{
                errCode := vm.Ram.WriteRAMBytes(uint32(o), v_Bytes[:])
                if errCode != OK </span><span class="cov0" title="0">{
                        vm.WriteRegister(7, OOB)
                        return errCode
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("Write RAM Bytes: %v\n", v_Bytes[:])
                }</span>
                <span class="cov0" title="0">vm.WriteRegister(7, OK)
                return OK</span>
        } else<span class="cov0" title="0"> {
                vm.WriteRegister(7, NONE)
                return NONE
        }</span>
}

// Export segment host-call
func (vm *VM) hostExport(pi uint32) (uint64, [][]byte) <span class="cov0" title="0">{
        /*
                need to get
                        ς
                properly
        */
        p, _ := vm.ReadRegister(7) // a0 = 7
        z, _ := vm.ReadRegister(8) // a1 = 8
        if z &gt; (W_E * W_S) </span><span class="cov0" title="0">{
                z = W_E * W_S
        }</span>

        <span class="cov0" title="0">e := vm.Exports

        x, errCode := vm.Ram.ReadRAMBytes(uint32(p), uint32(z))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                vm.Exports = e
                return OOB, e
        }</span>

        /*  apply eq(187) zero-padding function:

        And P is the zero-padding function to take an octet array to some multiple of n in length:
        (187)         P n∈N 1∶ ∶{ Y → Y k⋅n
                        x ↦ x ⌢ [0, 0, ...] ((∣x∣+n−1) mod n)+1...n

        n := (W_E * W_S)
        length := n - ((len(x) + n - 1) % n) + 1
        zeroSequence := make([]byte, length)
        x = append(x, zeroSequence...)
        */
        <span class="cov0" title="0">x = common.PadToMultipleOfN(x, W_E*W_S)

        ς := vm.ExportSegmentIndex   // Assume ς (sigma, Represent segment offset), need to get ς properly
        if ς+uint32(len(e)) &gt;= W_X </span><span class="cov0" title="0">{ // W_X
                vm.WriteRegister(7, FULL)
                vm.Exports = e
                return FULL, e
        }</span> else<span class="cov0" title="0"> {
                vm.WriteRegister(7, uint64(ς)+uint64(len(e)))
                e = append(e, x)
                vm.Exports = e
                // errCode = vm.hostenv.ExportSegment(x)
                return OK, e
        }</span>
}

// Not sure but this is running a machine at instruction i? using bytes from po to pz
func (vm *VM) hostMachine() uint64 <span class="cov0" title="0">{
        po, _ := vm.ReadRegister(7)
        pz, _ := vm.ReadRegister(8)
        i, _ := vm.ReadRegister(9)
        p, errCode := vm.Ram.ReadRAMBytes(uint32(po), uint32(pz))
        if errCode != OK </span><span class="cov0" title="0">{
                vm.WriteRegister(7, errCode)
                fmt.Printf("hostMachine: Read RAM Error\n")
                return errCode
        }</span>
        // need service account here??
        <span class="cov0" title="0">serviceAcct := uint32(0)
        n := vm.CreateVM(serviceAcct, p, uint32(i))
        fmt.Printf("hostMachine: Created VM %d\n", n)
        vm.WriteRegister(7, uint64(n))
        return uint64(n)</span>
}

func (vm *VM) hostPeek() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        s, _ := vm.ReadRegister(9)
        z, _ := vm.ReadRegister(10)
        m_n, ok := vm.GetVM(uint32(n))
        if !ok </span><span class="cov0" title="0">{
                vm.WriteRegister(7, WHO)
                return WHO
        }</span>
        // read l bytes from m
        <span class="cov0" title="0">s_data, errCode := m_n.Ram.ReadRAMBytes(uint32(s), uint32(z))
        if errCode == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(7, uint64(errCode))
                return errCode
        }</span>
        // write l bytes to vm
        <span class="cov0" title="0">errCode = vm.Ram.WriteRAMBytes(uint32(o), s_data[:])
        if errCode == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return errCode
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(7, OK)
        return OK</span>
}

func (vm *VM) hostPoke() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        o, _ := vm.ReadRegister(8)
        s, _ := vm.ReadRegister(9)
        z, _ := vm.ReadRegister(10)
        m_n, ok := vm.GetVM(uint32(n))
        fmt.Printf("ok? %v\n", ok)
        if !ok </span><span class="cov0" title="0">{
                vm.WriteRegister(7, WHO)
                return WHO
        }</span>
        // read data from original vm
        <span class="cov0" title="0">s_data, errCode := vm.Ram.ReadRAMBytes(uint32(s), uint32(z))
        fmt.Printf("ok? %v\n", errCode)
        if errCode == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(7, uint64(errCode))
                return errCode
        }</span>
        // write data to m_n
        <span class="cov0" title="0">errCode = m_n.Ram.WriteRAMBytes(uint32(o), s_data[:])
        if errCode == OOB </span><span class="cov0" title="0">{
                vm.WriteRegister(7, OOB)
                return errCode
        }</span>
        <span class="cov0" title="0">fmt.Printf("ok? %v\n", errCode)
        vm.WriteRegister(7, OK)
        return OK</span>
}

func (vm *VM) hostExpunge() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        vm.WriteRegister(7, uint64(vm.VMs[uint32(n)].pc))
        if vm.ExpungeVM(uint32(n)) </span><span class="cov0" title="0">{
                return OK
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(7, WHO)
        return WHO</span>
}

func (vm *VM) hostVoid() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        p, _ := vm.ReadRegister(8)
        c, _ := vm.ReadRegister(9)

        m, ok := vm.GetVM(uint32(n))
        if !ok </span><span class="cov0" title="0">{
                return WHO
        }</span>
        <span class="cov0" title="0">if p+c &gt;= (1&lt;&lt;32)/Z_P </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">for i := uint32(0); i &lt; uint32(c); i++ </span><span class="cov0" title="0">{
                page, err := m.Ram.getOrAllocatePage(uint32(p) + i)
                if err != nil </span><span class="cov0" title="0">{
                        return OOB // TODO
                }</span>
                <span class="cov0" title="0">page.void()</span>
        }
        // TODO
        <span class="cov0" title="0">return OK</span>
}

func (vm *VM) hostZero() uint64 <span class="cov0" title="0">{
        n, _ := vm.ReadRegister(7)
        p, _ := vm.ReadRegister(8)
        c, _ := vm.ReadRegister(9)
        if p &lt; 16 || p+c &gt; (1&lt;&lt;32)/Z_P </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">m, ok := vm.GetVM(uint32(n))
        if !ok </span><span class="cov0" title="0">{
                return WHO
        }</span>
        <span class="cov0" title="0">for i := uint32(0); i &lt; uint32(c); i++ </span><span class="cov0" title="0">{
                page, err := m.Ram.getOrAllocatePage(uint32(p) + uint32(i))
                if err != nil </span><span class="cov0" title="0">{
                        return OOB // TODO
                }</span>
                <span class="cov0" title="0">fmt.Printf("Zeroing page %d\n", uint32(p)+i)
                page.zero()</span>
        }
        <span class="cov0" title="0">return OK</span>
}

func (vm *VM) hostSP1Groth16Verify() uint64 <span class="cov0" title="0">{
        proof, _ := vm.ReadRegister(7)
        proof_length, _ := vm.ReadRegister(8)
        verifierkey, _ := vm.ReadRegister(9)
        verifierkey_length, _ := vm.ReadRegister(10)
        public, _ := vm.ReadRegister(11)
        public_length, _ := vm.ReadRegister(12)

        proofBytes, errCode := vm.Ram.ReadRAMBytes(uint32(proof), uint32(proof_length))
        if errCode != OK </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">verifierBytes, errCode := vm.Ram.ReadRAMBytes(uint32(verifierkey), uint32(verifierkey_length))
        if errCode != OK </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">pubBytes, errCode := vm.Ram.ReadRAMBytes(uint32(public), uint32(public_length))
        if errCode != OK </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">verified := sp1.VerifyGroth16(proofBytes, string(verifierBytes), pubBytes)
        if verified </span><span class="cov0" title="0">{
                return OK
        }</span>
        <span class="cov0" title="0">return HUH</span>
}

func getLogLevelName(level uint64) string <span class="cov0" title="0">{
        switch level </span>{
        case 0:<span class="cov0" title="0">
                return "⛔️ FATAL"</span>
        case 1:<span class="cov0" title="0">
                return "⚠️ WARNING"</span>
        case 2:<span class="cov0" title="0">
                return "ℹ️ INFO"</span>
        case 3:<span class="cov0" title="0">
                return "💁 HELPFUL"</span>
        case 4:<span class="cov0" title="0">
                return "🪡 PEDANTIC"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// JIP-1 https://hackmd.io/@polkadot/jip1
func (vm *VM) hostLog() uint64 <span class="cov0" title="0">{

        level, _ := vm.ReadRegister(7)
        target, _ := vm.ReadRegister(8)
        targetlen, _ := vm.ReadRegister(9)
        message, _ := vm.ReadRegister(10)
        messagelen, _ := vm.ReadRegister(11)
        targetBytes, errCode := vm.Ram.ReadRAMBytes(uint32(target), uint32(targetlen))
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">messageBytes, errCode := vm.Ram.ReadRAMBytes(uint32(message), uint32(messagelen))
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">currentTime := time.Now().Format("2006-01-02 15:04:05")
        levelName := getLogLevelName(level) // Assume a function that maps level numbers to log level names.

        // &lt;YYYY-MM-DD hh-mm-ss&gt; &lt;LEVEL&gt;[@&lt;CORE&gt;]?[#&lt;SERVICE_ID&gt;]? [&lt;TARGET&gt;]? &lt;MESSAGE&gt;
        fmt.Printf("[%s] %s [TARGET: %s] %s\n", currentTime, levelName, string(targetBytes), string(messageBytes))
        return OK</span>
}

func (vm *VM) PutGasAndRegistersToMemory(input_address uint32, gas uint64, regs []uint64) (errCode uint64) <span class="cov0" title="0">{
        gasBytes := make([]byte, 8)
        binary.LittleEndian.PutUint64(gasBytes, gas)
        errCode = vm.Ram.WriteRAMBytes(input_address, gasBytes)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">for i, reg := range regs </span><span class="cov0" title="0">{
                regBytes := make([]byte, 8)
                binary.LittleEndian.PutUint64(regBytes, reg)
                errCode = vm.Ram.WriteRAMBytes(input_address+8+uint32(i*8), regBytes)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
        }
        <span class="cov0" title="0">return OK</span>
}

func (vm *VM) GetGasAndRegistersFromMemory(input_address uint32) (gas uint64, regs []uint64, errCode uint64) <span class="cov0" title="0">{
        gasBytes, errCode := vm.Ram.ReadRAMBytes(input_address, 8)
        if errCode != OK </span><span class="cov0" title="0">{
                return 0, nil, errCode
        }</span>
        <span class="cov0" title="0">gas = binary.LittleEndian.Uint64(gasBytes)
        regs = make([]uint64, 13)
        for i := 0; i &lt; 13; i++ </span><span class="cov0" title="0">{
                regBytes, errCode := vm.Ram.ReadRAMBytes(input_address+8+uint32(i*8), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        return 0, nil, errCode
                }</span>
                <span class="cov0" title="0">regs[i] = binary.LittleEndian.Uint64(regBytes)
                fmt.Printf("Register %d: %d\n", i, regs[i])</span>
        }
        <span class="cov0" title="0">return gas, regs, OK</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package pvm

import (
        "fmt"
        "log"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/trie"
        "github.com/colorfulnotion/jam/types"
)

// MockHostEnv struct implements the HostEnv interface with mock responses
type MockHostEnv struct {
        db *storage.StateDBStorage
}

func NewMockHostEnvDB() *storage.StateDBStorage <span class="cov0" title="0">{
        test_db, _ := trie.InitLevelDB()
        return test_db
}</span>

func NewMockHostEnv() *MockHostEnv <span class="cov0" title="0">{
        test_db := NewMockHostEnvDB()
        return &amp;MockHostEnv{db: test_db}
}</span>

// func (mh *MockHostEnv) GetXContext() *types.XContext {
//         return new(types.XContext)
// }

// func (mh *MockHostEnv) SetXContext(x *types.XContext) {}

// func (mh *MockHostEnv) UpdateXContext(x *types.XContext) {}

func (mh *MockHostEnv) GetDB() *storage.StateDBStorage <span class="cov0" title="0">{
        return mh.db
}</span>

func (mh *MockHostEnv) GetService(c uint32) (*types.ServiceAccount, bool, error) <span class="cov0" title="0">{
        return nil, false, nil
}</span>

func (mh *MockHostEnv) ReadServiceStorage(s uint32, k []byte) (storage []byte, ok bool, err error) <span class="cov0" title="0">{
        db := mh.GetDB()
        rootHash, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov0" title="0">storage, ok, err = tree.GetServiceStorage(s, k)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("get value=%x, err=%v\n", storage, err)
                return
        }</span>
}

func (mh *MockHostEnv) ReadServicePreimageBlob(s uint32, blob_hash common.Hash) (blob []byte, ok bool, err error) <span class="cov0" title="0">{
        db := mh.GetDB()
        rootHash, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov0" title="0">blob, ok, err = tree.GetPreImageBlob(s, blob_hash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("get value=%x, err=%v\n", blob, err)
                return
        }</span>
}

func (mh *MockHostEnv) ReadServicePreimageLookup(s uint32, blob_hash common.Hash, blob_length uint32) (time_slots []uint32, ok bool, err error) <span class="cov0" title="0">{
        db := mh.GetDB()
        rootHash, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov0" title="0">time_slots, ok, err = tree.GetPreImageLookup(s, blob_hash, blob_length)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("get value=%x, err=%v\n", time_slots, err)
                return
        }</span>
}

func (mh *MockHostEnv) HistoricalLookup(s uint32, t uint32, blob_hash common.Hash) []byte <span class="cov0" title="0">{
        db := mh.GetDB()
        rootHash, tree, err := trie.Initial_bpt(db)
        //tree := trie.NewMerkleTree(nil, db)
        defer tree.Close()
        fmt.Printf("Root Hash=%x, err=%v\n", rootHash, err)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal("fail to connect to BPT")
        }</span>
        <span class="cov0" title="0">blob, ok, err_v := tree.GetPreImageBlob(s, blob_hash)
        if err_v != nil || !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">blob_length := uint32(len(blob))

        //MK: william to fix &amp; verify
        //hbytes := falseBytes(h.Bytes()[4:])
        //lbytes := uint32ToBytes(blob_length)
        //key := append(lbytes, hbytes...)
        //timeslots, err_t := tree.GetPreImageLookup(s, key)
        timeslots, ok, err_t := tree.GetPreImageLookup(s, blob_hash, blob_length)
        if err_t != nil || !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if timeslots[0] == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if len(timeslots) == (12 + 1) </span><span class="cov0" title="0">{
                x := timeslots[0]
                y := timeslots[1]
                z := timeslots[2]
                if (x &lt;= t &amp;&amp; t &lt; y) || (z &lt;= t) </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> if len(timeslots) == (8 + 1) </span><span class="cov0" title="0">{
                x := timeslots[0]
                y := timeslots[1]
                if x &lt;= t &amp;&amp; t &lt; y </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                x := timeslots[0]
                if x &lt;= t </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}

func (mh *MockHostEnv) GetTimeslot() uint32 <span class="cov0" title="0">{
        return uint32(0)
}</span>

func (mh *MockHostEnv) WriteServicePreimageBlob(s uint32, blob []byte) {<span class="cov0" title="0">
        // TODO: elimnate the need for this by adjusting genesis.go
}</span>

func (mh *MockHostEnv) WriteServicePreimageLookup(s uint32, blob_hash common.Hash, blob_length uint32, time_slots []uint32) {<span class="cov0" title="0">
        // TODO: elimnate the need for this by adjusting genesis.go
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package pvm

import (
        "encoding/binary"
        "errors"
        "fmt"
        "math"
        "reflect"

        //        "reflect"

        "strings"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

const (
        debug_pvm      = false
        debug_host     = false
        ram_permission = true

        regSize  = 13
        numCores = types.TotalCores
        W_E      = types.W_E
        W_S      = types.W_S
        W_X      = 1024
        M        = 128
        V        = 1023
        D        = 28800
        Z_A      = 2
        Z_P      = (1 &lt;&lt; 12)
        Z_Q      = (1 &lt;&lt; 16)
        Z_I      = (1 &lt;&lt; 24)
        Z_Z      = (1 &lt;&lt; 16)
)

const (
        PageSize     = 4096                    // Size of each page (2^12 bytes)
        AddressSpace = 4294967296              // Total addressable memory (2^32)
        TotalPages   = AddressSpace / PageSize // Total number of pages
)

// AccessMode represents the access permissions of a memory page
type AccessMode struct {
        Inaccessible bool `json:"inaccessible"` // Indicates if the page is inaccessible
        Writable     bool `json:"writable"`     // Indicates if the page is writable
        Readable     bool `json:"readable"`     // Indicates if the page is readable
}

// MemoryPage represents a single memory page
type Page struct {
        Value  []byte     `json:"data"`   // The data stored in the page
        Access AccessMode `json:"access"` // The access mode of the page
}

// RAM represents the entire memory system
type RAM struct {
        Pages map[uint32]*Page `json:"pages"` // The pages in the RAM
}

func NewRAM() *RAM <span class="cov8" title="1">{
        return &amp;RAM{
                Pages: make(map[uint32]*Page),
        }
}</span>

// Ensure data allocation for a page (lazy allocation)
func (p *Page) ensureData() <span class="cov8" title="1">{
        if p.Value == nil </span><span class="cov8" title="1">{
                p.Value = make([]byte, PageSize)
        }</span>
}

func (p *Page) zero() <span class="cov0" title="0">{
        p.Value = make([]byte, PageSize)
        p.Access = AccessMode{
                Inaccessible: false,
                Writable:     true,
                Readable:     true,
        }
}</span>

func (p *Page) void() <span class="cov0" title="0">{
        p.Value = make([]byte, PageSize)
        p.Access = AccessMode{
                Inaccessible: true,
                Writable:     false,
                Readable:     false,
        }
}</span>

// Get or allocate a specific page
func (ram *RAM) getOrAllocatePage(pageIndex uint32) (*Page, error) <span class="cov8" title="1">{
        if pageIndex &gt;= TotalPages </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("page index %d out of bounds (max %d)", pageIndex, TotalPages-1)
        }</span>

        // Check if the page already exists
        <span class="cov8" title="1">if page, exists := ram.Pages[pageIndex]; exists </span><span class="cov8" title="1">{
                return page, nil
        }</span>

        // Allocate a new page dynamically
        <span class="cov8" title="1">newPage := &amp;Page{
                Access: AccessMode{
                        Inaccessible: true, // Default to inaccessible
                        Writable:     false,
                        Readable:     false,
                },
        }
        ram.Pages[pageIndex] = newPage
        return newPage, nil</span>
}

// Set the access mode for a specific page
func (ram *RAM) SetPageAccess(pageIndex uint32, Numpages uint32, mode AccessMode) uint64 <span class="cov8" title="1">{
        for i := pageIndex; i &lt; pageIndex+Numpages; i++ </span><span class="cov8" title="1">{
                page, err := ram.getOrAllocatePage(i)
                if err != nil </span><span class="cov0" title="0">{
                        return OOB
                }</span>
                <span class="cov8" title="1">page.Access = mode</span>
        }
        <span class="cov8" title="1">return OK</span>
}

// WriteRAMBytes writes data to a specific address in RAM
func (ram *RAM) WriteRAMBytes(address uint32, data []byte) uint64 <span class="cov8" title="1">{
        offset := address % PageSize
        remaining := uint32(len(data))

        for remaining &gt; 0 </span><span class="cov8" title="1">{
                currentPage := address / PageSize
                pageOffset := offset
                page, err := ram.getOrAllocatePage(currentPage)
                if err != nil </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Fail to get or allocate page %d to access address %d\n", currentPage, address)
                        }</span>
                        <span class="cov0" title="0">return OOB</span>
                }

                // Check if the page is writable
                <span class="cov8" title="1">if page.Access.Inaccessible || !page.Access.Writable </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Page %d is not writable, addess is %d\n", currentPage, address)
                        }</span>
                        <span class="cov0" title="0">return OOB</span>
                }

                // Ensure data allocation before writing
                <span class="cov8" title="1">page.ensureData()

                // Calculate how much data can be written to the current page
                bytesToWrite := PageSize - pageOffset
                if bytesToWrite &gt; remaining </span><span class="cov8" title="1">{
                        bytesToWrite = remaining
                }</span>
                <span class="cov8" title="1">copy(page.Value[pageOffset:pageOffset+bytesToWrite], data[:bytesToWrite])

                // Update the address, data slice, and remaining bytes
                address += bytesToWrite
                data = data[bytesToWrite:]
                remaining -= bytesToWrite
                offset = 0</span> // Offset is only used for the first page
        }
        <span class="cov8" title="1">return OK</span>
}

// ReadRAMBytes reads data from a specific address in RAM
func (ram *RAM) ReadRAMBytes(address uint32, length uint32) ([]byte, uint64) <span class="cov8" title="1">{
        result := make([]byte, 0, length)
        offset := address % PageSize
        remaining := length

        for remaining &gt; 0 </span><span class="cov8" title="1">{
                currentPage := address / PageSize
                pageOffset := offset

                // Ensure the page exists and is readable
                page, err := ram.getOrAllocatePage(currentPage)
                if err != nil </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Fail to get or allocate page %d to access address %d\n", currentPage, address)
                        }</span>
                        <span class="cov0" title="0">return nil, OOB</span>
                }
                <span class="cov8" title="1">if page.Access.Inaccessible || !page.Access.Readable </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("Page %d is not readable, addess is %d, length is %d\n", currentPage, address, length)
                        }</span>
                        <span class="cov0" title="0">return nil, OOB</span>
                }

                // Calculate how much data can be read from the current page
                <span class="cov8" title="1">bytesToRead := PageSize - pageOffset
                if bytesToRead &gt; remaining </span><span class="cov8" title="1">{
                        bytesToRead = remaining
                }</span>

                // Append data to the result
                <span class="cov8" title="1">result = append(result, page.Value[pageOffset:pageOffset+bytesToRead]...)

                // Update the address and remaining bytes
                address += bytesToRead
                remaining -= bytesToRead
                offset = 0</span> // Offset is only used for the first page
        }
        <span class="cov8" title="1">return result, OK</span>
}

// DebugStatus provides a snapshot of the RAM's state
func (ram *RAM) DebugStatus() <span class="cov0" title="0">{
        fmt.Println("RAM Status:")
        for pageIndex, page := range ram.Pages </span><span class="cov0" title="0">{
                fmt.Printf("Page %d: Inaccessible=%v, Writable=%v, Readable=%v, Data Allocated=%v\n",
                        pageIndex, page.Access.Inaccessible, page.Access.Writable, page.Access.Readable, page.Value != nil)
        }</span>
}

type VM struct {
        JSize        uint64
        Z            uint8
        J            []uint32
        code         []byte
        bitmask      string // K in GP
        pc           uint32 // Program counter
        resultCode   uint8
        terminated   bool
        hostCall     bool // ̵h in GP
        host_func_id int  // h in GP
        // ram                 map[uint32][4096]byte
        Ram                 *RAM
        register            []uint64
        Gas                 int64
        hostenv             types.HostEnv
        writable_ram_start  uint32
        writable_ram_length uint32

        VMs map[uint32]*VM

        // Work Package Inputs
        Extrinsics [][]byte
        payload    []byte
        Imports    [][]byte

        // Invocation funtions entry point
        EntryPoint uint32

        // Malicious Setting
        IsMalicious bool

        // standard program initialization parameters
        o_size uint32
        w_size uint32
        z      uint32
        s      uint32
        o_byte []byte
        w_byte []byte

        // Refine argument
        RefineM_map        RefineM_map
        Exports            [][]byte
        ExportSegmentIndex uint32

        // Accumulate argument
        X        *types.XContext
        Y        types.XContext
        Timeslot uint32

        // Gereral argument
        ServiceAccount *types.ServiceAccount
        Service_index  uint32
        Delta          map[uint32]*types.ServiceAccount
}

type Forgets struct {
}

type Solicit struct {
        BlobHash common.Hash
        Length   uint32
}

type Program struct {
        JSize uint64
        Z     uint8 // 1 byte
        CSize uint64
        J     []uint32
        Code  []byte
        //K     []byte
        K []string
}

// Appendix A - Instuctions

// A.5.1. Instructions without Arguments.
const (
        TRAP        = 0
        FALLTHROUGH = 1
)

// A.5.2. Instructions with Arguments of One Immediate.
const (
        ECALLI = 10 // 0x0a
)

// A.5.3. Instructions with Arguments of One Register and One Extended Width Immediate.
const (
        LOAD_IMM_64 = 20 // 0x14
)

// A.5.4. Instructions with Arguments of Two Immediates.
const (
        STORE_IMM_U8  = 30
        STORE_IMM_U16 = 31
        STORE_IMM_U32 = 32
        STORE_IMM_U64 = 33 // NEW, 32-bit twin = store_imm_u32
)

// A.5.5. Instructions with Arguments of One Offset.
const (
        JUMP = 40 // 0x28
)

// A.5.6. Instructions with Arguments of One Register &amp; Two Immediates.
const (
        JUMP_IND  = 50 // 0x32
        LOAD_IMM  = 51 // 0x33 NOTE: 64-bit twin = load_imm_64
        LOAD_U8   = 52
        LOAD_I8   = 53 // NEW
        LOAD_U16  = 54
        LOAD_I16  = 55 // NEW
        LOAD_U32  = 56
        LOAD_I32  = 57 // NEW
        LOAD_U64  = 58
        STORE_U8  = 59
        STORE_U16 = 60
        STORE_U32 = 61
        STORE_U64 = 62 // NEW, 32-bit twin = store_u32
)

// A.5.7. Instructions with Arguments of One Register &amp; Two Immediates.
const (
        STORE_IMM_IND_U8  = 70 // 0x46
        STORE_IMM_IND_U16 = 71 // 0x47
        STORE_IMM_IND_U32 = 72 // 0x48
        STORE_IMM_IND_U64 = 73 // 0x49 NEW, 32-bit twin = store_imm_ind_u32
)

// A.5.8. Instructions with Arguments of One Register, One Immediate and One Offset.
const (
        LOAD_IMM_JUMP   = 80
        BRANCH_EQ_IMM   = 81 // 0x51
        BRANCH_NE_IMM   = 82
        BRANCH_LT_U_IMM = 83
        BRANCH_LE_U_IMM = 84
        BRANCH_GE_U_IMM = 85
        BRANCH_GT_U_IMM = 86
        BRANCH_LT_S_IMM = 87
        BRANCH_LE_S_IMM = 88
        BRANCH_GE_S_IMM = 89
        BRANCH_GT_S_IMM = 90
)

// A.5.9. Instructions with Arguments of Two Registers.
const (
        MOVE_REG = 100 // 0x64
        SBRK     = 101
)

// A.5.9. Instructions with Arguments of Two Registers &amp; One Immediate.
const (
        STORE_IND_U8      = 110 // 0x6e
        STORE_IND_U16     = 111 // 0x6f
        STORE_IND_U32     = 112 // 0x70
        STORE_IND_U64     = 113 // 0x71 NEW, 32-bit twin = store_ind_u32
        LOAD_IND_U8       = 114
        LOAD_IND_I8       = 115
        LOAD_IND_U16      = 116
        LOAD_IND_I16      = 117 // 0x75
        LOAD_IND_U32      = 118 // 0x76
        LOAD_IND_I32      = 119 // 0x77 NEW, no twin.
        LOAD_IND_U64      = 120 // 0x78 NEW, 32-bit twin = load_ind_u32
        ADD_IMM_32        = 121 // 0x79
        AND_IMM           = 122
        XOR_IMM           = 123
        OR_IMM            = 124
        MUL_IMM_32        = 125
        MUL_IMM           = 125
        SET_LT_U_IMM      = 126
        SET_LT_S_IMM      = 127
        SHLO_L_IMM_32     = 128
        SHLO_R_IMM_32     = 129
        SHAR_R_IMM_32     = 130
        NEG_ADD_IMM_32    = 131
        SET_GT_U_IMM      = 132
        SET_GT_S_IMM      = 133
        SHLO_L_IMM_ALT_32 = 134
        SHLO_R_IMM_ALT_32 = 135
        SHAR_R_IMM_ALT_32 = 136
        CMOV_IZ_IMM       = 137
        CMOV_NZ_IMM       = 138
        ADD_IMM_64        = 139 // 0x8b NEW, 32-bit twin = add_imm_32
        MUL_IMM_64        = 140 // 0x8c NEW, 32-bit twin = mul_imm_32
        SHLO_L_IMM_64     = 141 // 0x8d NEW, 32-bit twin = shlo_l_imm_32
        SHLO_R_IMM_64     = 142 // 0x8e NEW, 32-bit twin = shlo_r_imm_32
        SHAR_R_IMM_64     = 143 // 0x8f NEW, 32-bit twin = shar_r_imm_32
        NEG_ADD_IMM_64    = 144 // 0x90 NEW, 32-bit twin = neg_add_imm_32
        SHLO_L_IMM_ALT_64 = 145 // 0x91 NEW, 32-bit twin = shlo_l_imm_alt_32
        SHLO_R_IMM_ALT_64 = 146 // 0x92 NEW, 32-bit twin = shlo_r_imm_alt_32
        SHAR_R_IMM_ALT_64 = 147 // 0x93 NEW, 32-bit twin = shar_r_imm_alt_32
)

// A.5.11. Instructions with Arguments of Two Registers &amp; One Offset.
const (
        BRANCH_EQ   = 150
        BRANCH_NE   = 151
        BRANCH_LT_U = 152
        BRANCH_LT_S = 153
        BRANCH_GE_U = 154
        BRANCH_GE_S = 155
)

// A.5.12. Instruction with Arguments of Two Registers and Two Immediates.
const (
        LOAD_IMM_JUMP_IND = 160
)

// A.5.13. Instructions with Arguments of Three Registers.
const (
        ADD_32        = 170 // 0xaa
        SUB_32        = 171
        MUL_32        = 172
        DIV_U_32      = 173
        DIV_S_32      = 174
        REM_U_32      = 175
        REM_S_32      = 176
        SHLO_L_32     = 177
        SHLO_R_32     = 178
        SHAR_R_32     = 179
        ADD_64        = 180 // 0xb4 NEW, 32-bit twin = ADD_32
        SUB_64        = 181 // NEW, 32-bit twin = SUB_32
        MUL_64        = 182 // NEW, 32-bit twin = MUL_32
        DIV_U_64      = 183 // NEW, 32-bit twin = DIV_U_32
        DIV_S_64      = 184 // NEW, 32-bit twin = DIV_S_32
        REM_U_64      = 185 // NEW, 32-bit twin = REM_U_32
        REM_S_64      = 186 // NEW, 32-bit twin = REM_S_32
        SHLO_L_64     = 187 // NEW, 32-bit twin =  SHLO_L_32
        SHLO_R_64     = 188 // NEW, 32-bit twin = SHLO_R_32
        SHAR_R_64     = 189 // NEW, 32-bit twin =  SHAR_R_32
        AND           = 190
        XOR           = 191 // 0xbf
        OR            = 192
        MUL_UPPER_S_S = 193
        MUL_UPPER_U_U = 194
        MUL_UPPER_S_U = 195
        SET_LT_U      = 196
        SET_LT_S      = 197
        CMOV_IZ       = 198
        CMOV_NZ       = 199
)

// Termination Instructions
var T = map[int]struct{}{
        TRAP:            {},
        FALLTHROUGH:     {},
        JUMP:            {},
        JUMP_IND:        {},
        LOAD_IMM_JUMP:   {},
        BRANCH_EQ_IMM:   {},
        BRANCH_NE_IMM:   {},
        BRANCH_LT_U_IMM: {},
        BRANCH_LE_U_IMM: {},
        BRANCH_GE_U_IMM: {},
        BRANCH_GT_U_IMM: {},
        BRANCH_LT_S_IMM: {},
        BRANCH_LE_S_IMM: {},
        BRANCH_GE_S_IMM: {},
        BRANCH_GT_S_IMM: {},
        BRANCH_EQ:       {},
        BRANCH_NE:       {},
        BRANCH_LT_U:     {},
        BRANCH_LT_S:     {},
        BRANCH_GE_U:     {},
        BRANCH_GE_S:     {},
}

const (
        NONE = (1 &lt;&lt; 64) - 1  // 2^32 - 1
        OOB  = (1 &lt;&lt; 64) - 2  // 2^32 - 2
        WHO  = (1 &lt;&lt; 64) - 3  // 2^32 - 3
        FULL = (1 &lt;&lt; 64) - 4  // 2^32 - 4
        CORE = (1 &lt;&lt; 64) - 5  // 2^32 - 5
        CASH = (1 &lt;&lt; 64) - 6  // 2^32 - 6
        LOW  = (1 &lt;&lt; 64) - 7  // 2^32 - 7
        HIGH = (1 &lt;&lt; 64) - 8  // 2^32 - 8
        WAT  = (1 &lt;&lt; 64) - 9  // 2^32 - 9
        HUH  = (1 &lt;&lt; 64) - 10 // 2^32 - 10
        OK   = 0              // 0

        HALT  = 0              // 0
        PANIC = (1 &lt;&lt; 64) - 12 // 2^32 - 12
        FAULT = (1 &lt;&lt; 64) - 13 // 2^32 - 13
        HOST  = (1 &lt;&lt; 64) - 14 // 2^32 - 14

// BAD = 1111
// S   = 2222
// BIG = 3333
)

func extractBytes(input []byte) ([]byte, []byte) <span class="cov0" title="0">{
        /*
                In GP_0.36 (272):
                If the input value of (272) is large, "l" will also increase and vice versa.
                "l" is than be used to encode first byte and the reaming "l" bytes.
                If the first byte is large, that means the number of the entire encoded bytes is large and vice versa.
                So the first byte can be used to determine the number of bytes to extract and the rule is as follows:
        */

        if len(input) == 0 </span><span class="cov0" title="0">{
                return nil, input
        }</span>

        <span class="cov0" title="0">firstByte := input[0]
        var numBytes int

        // Determine the number of bytes to extract based on the value of the 0th byte.
        switch </span>{
        case firstByte &gt;= 1 &amp;&amp; firstByte &lt; 128:<span class="cov0" title="0">
                numBytes = 1</span>
        case firstByte &gt;= 128 &amp;&amp; firstByte &lt; 192:<span class="cov0" title="0">
                numBytes = 2</span>
        case firstByte &gt;= 192 &amp;&amp; firstByte &lt; 224:<span class="cov0" title="0">
                numBytes = 3</span>
        case firstByte &gt;= 224 &amp;&amp; firstByte &lt; 240:<span class="cov0" title="0">
                numBytes = 4</span>
        case firstByte &gt;= 240 &amp;&amp; firstByte &lt; 248:<span class="cov0" title="0">
                numBytes = 5</span>
        case firstByte &gt;= 248 &amp;&amp; firstByte &lt; 252:<span class="cov0" title="0">
                numBytes = 6</span>
        case firstByte &gt;= 252 &amp;&amp; firstByte &lt; 254:<span class="cov0" title="0">
                numBytes = 7</span>
        case firstByte &gt;= 254:<span class="cov0" title="0">
                numBytes = 8</span>
        default:<span class="cov0" title="0">
                numBytes = 1</span>
        }

        // If the input length is insufficient to extract the specified number of bytes, return the original input.
        <span class="cov0" title="0">if len(input) &lt; numBytes </span><span class="cov0" title="0">{
                return input, nil
        }</span>

        // Extract the specified number of bytes and return the remaining bytes.
        <span class="cov0" title="0">extracted := input[:numBytes]
        remaining := input[numBytes:]

        return extracted, remaining</span>
}

func value_check(value []byte) []byte <span class="cov0" title="0">{
        if len(value) == 0 </span><span class="cov0" title="0">{
                return []byte{0}
        }</span>
        <span class="cov0" title="0">return value</span>
}

func PrintProgam(p *Program) <span class="cov0" title="0">{
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("JSize=%d\n", p.JSize)
                fmt.Printf("Z=%d\n", p.Z)
                fmt.Printf("CSize=%d\n", p.CSize)
                fmt.Printf("J=%v\n", p.J)
                fmt.Printf("Code=%v\n", p.Code)
                fmt.Printf("K=%v\n", p.K)
        }</span>
}

func reverseString(s string) string <span class="cov0" title="0">{
        runes := []rune(s)
        for i, j := 0, len(runes)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                runes[i], runes[j] = runes[j], runes[i]
        }</span>
        <span class="cov0" title="0">return string(runes)</span>
}

func binaryStringToByte(binaryStr string) byte <span class="cov0" title="0">{
        var result byte
        for i, bit := range binaryStr </span><span class="cov0" title="0">{
                if bit == '1' </span><span class="cov0" title="0">{
                        result |= 1 &lt;&lt; (len(binaryStr) - 1 - i)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func EncodeProgram(p *Program) []byte <span class="cov0" title="0">{
        // Encode the program
        encoded := make([]byte, 0)

        encodedJSize := types.E(p.JSize)
        encoded = append(encoded, encodedJSize...)

        encodedZ := types.E_l(uint64(p.Z), 1)
        encoded = append(encoded, encodedZ...)

        encodedCSize := types.E(p.CSize)
        encoded = append(encoded, encodedCSize...)
        for _, j := range p.J </span><span class="cov0" title="0">{
                encodedj := types.E_l(uint64(j), uint32(p.Z))
                encoded = append(encoded, encodedj...)
        }</span>
        <span class="cov0" title="0">encoded = append(encoded, p.Code...)

        var k_bytes []byte
        for i := 0; i &lt; len(p.K[0]); i += 8 </span><span class="cov0" title="0">{
                end := i + 8
                if end &gt; len(p.K[0]) </span><span class="cov0" title="0">{
                        end = len(p.K[0])
                }</span>
                <span class="cov0" title="0">group := p.K[0][i:end]
                reversedGroup := reverseString(group)
                if len(reversedGroup) &lt; 8 </span><span class="cov0" title="0">{
                        reversedGroup = strings.Repeat("1", 8-len(reversedGroup)) + reversedGroup
                }</span>

                <span class="cov0" title="0">byteValue := binaryStringToByte(reversedGroup)
                k_bytes = append(k_bytes, byteValue)</span>
        }
        <span class="cov0" title="0">encoded = append(encoded, k_bytes...)
        encoded = append(encoded, []byte{0}...)
        return encoded</span>
}

func DecodeProgram(p []byte) (*Program, uint32, uint32, uint32, uint32, []byte, []byte) <span class="cov0" title="0">{
        // Check if the program include ascii byte code
        var pure_code []byte
        pure_code = p

        // extract standard program information
        o_size_byte := pure_code[:3]
        o_size := types.DecodeE_l(o_size_byte)
        w_size_byte := pure_code[3:6]
        w_size := types.DecodeE_l(w_size_byte)
        standard_z_byte := pure_code[6:8]
        standard_s_byte := pure_code[8:11]
        var o_byte []byte
        if 11+o_size &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                o_byte = make([]byte, o_size)
        }</span> else<span class="cov0" title="0"> {
                o_byte = pure_code[11 : 11+o_size]
        }</span>
        <span class="cov0" title="0">var w_byte []byte
        if 11+o_size+w_size &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                w_byte = make([]byte, w_size)
        }</span> else<span class="cov0" title="0"> {
                w_byte = pure_code[11+o_size : 11+o_size+w_size]
        }</span>
        <span class="cov0" title="0">var standard_c_size_byte []byte
        if 11+o_size+w_size+4 &gt; uint64(len(pure_code)) </span><span class="cov0" title="0">{
                standard_c_size_byte = pure_code[11+0+0 : 11+0+0+4]
                pure_code = pure_code[11+0+0+4:]
        }</span> else<span class="cov0" title="0"> {
                standard_c_size_byte = pure_code[11+o_size+w_size : 11+o_size+w_size+4]
                pure_code = pure_code[11+o_size+w_size+4:]
        }</span>

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("OSIZE=%d\n", o_size)
                fmt.Printf("WSIZE=%d\n", w_size)
                fmt.Printf("Z=%d\n", types.DecodeE_l(standard_z_byte))
                fmt.Printf("S=%d\n", types.DecodeE_l(standard_s_byte))
                fmt.Printf("O=%v\n", o_byte)
                fmt.Printf("W=%v\n", w_byte)
                fmt.Printf("Code and Jump Table size: %d\n", types.DecodeE_l(standard_c_size_byte))
        }</span>
        <span class="cov0" title="0">var j_size_byte, z_byte, c_size_byte []byte
        j_size_byte, pure_code = extractBytes(pure_code)
        z_byte, pure_code = extractBytes(pure_code)
        c_size_byte, pure_code = extractBytes(pure_code)
        j_size, _ := types.DecodeE(j_size_byte)
        z, _ := types.DecodeE(z_byte)
        c_size, _ := types.DecodeE(c_size_byte)
        j_byte := pure_code[:j_size*z]
        c_byte := pure_code[j_size*z : j_size*z+c_size]
        k_bytes := pure_code[j_size*z+c_size:]
        var kCombined string
        for _, b := range k_bytes </span><span class="cov0" title="0">{
                binaryStr := fmt.Sprintf("%08b", b)
                kCombined += reverseString(binaryStr)
        }</span>
        <span class="cov0" title="0">if len(kCombined) &gt; int(c_size) </span><span class="cov0" title="0">{
                kCombined = kCombined[:int(c_size)]
        }</span>
        // process j_array
        <span class="cov0" title="0">var j_array []uint32
        for i := uint64(0); i &lt; uint64(len(j_byte)); i += z </span><span class="cov0" title="0">{
                end := i + z
                if end &gt; uint64(len(j_byte)) </span><span class="cov0" title="0">{
                        end = uint64(len(j_byte))
                }</span>
                <span class="cov0" title="0">slice := j_byte[i:end]
                decodedValue := types.DecodeE_l(slice)
                j_array = append(j_array, uint32(decodedValue))</span>
        }

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("JSize=%d\n", j_size)
                fmt.Printf("Z=%d\n", z)
                fmt.Printf("CSize=%d\n", c_size)
                fmt.Println("Jump Table: ", j_array)
                fmt.Printf("Code: %x\n", c_byte)
                fmt.Printf("K(bitmask): %v\n", kCombined)
                fmt.Println("================================================================")
        }</span>
        <span class="cov0" title="0">program := &amp;Program{
                JSize: j_size,
                Z:     uint8(z),
                CSize: c_size,
                J:     j_array,
                Code:  c_byte,
                K:     []string{kCombined},
        }
        return program, uint32(o_size), uint32(w_size), uint32(types.DecodeE_l(standard_z_byte)), uint32(types.DecodeE_l(standard_s_byte)), o_byte, w_byte</span>

}

func CelingDevide(a, b uint32) uint32 <span class="cov0" title="0">{
        return (a + b - 1) / b
}</span>

func P_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_P * CelingDevide(x, Z_P)
}</span>

func Q_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_Q * CelingDevide(x, Z_Q)
}</span>

func Z_func(x uint32) uint32 <span class="cov0" title="0">{
        return Z_Z * CelingDevide(x, Z_Z)
}</span>

func Standard_Program_Initialization(vm *VM, argument_data_a []byte) <span class="cov0" title="0">{
        // Standard Program Initialization
        // check condition for standard program GP-0.4.0 (261))
        if len(argument_data_a) == 0 </span><span class="cov0" title="0">{
                argument_data_a = []byte{0}
        }</span>
        <span class="cov0" title="0">condition := uint64(5*Z_Z+Q_func(vm.o_size)+Q_func(vm.w_size+vm.z*Z_P)+Q_func(vm.s)+Z_I) &lt;= uint64((1 &lt;&lt; 32))
        if condition </span><span class="cov0" title="0">{
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Standard Program Initialization...")
                }</span>
                // set up the initial values and access mode for the RAM
                <span class="cov0" title="0">var page_index, page_length uint32
                var access_mode AccessMode

                page_index = (Z_Z + vm.o_size) / PageSize
                page_length = CelingDevide((P_func(vm.o_size) - vm.o_size), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("1. Set Page Index %d and Page Length %d with Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = (2*Z_Z + Z_func(vm.o_size)) / PageSize
                page_length = CelingDevide(vm.w_size, PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("2. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes(2*Z_Z+Z_func(vm.o_size), vm.w_byte)

                page_index = (2*Z_Z + Z_func(vm.o_size) + vm.w_size) / PageSize
                page_length = CelingDevide(P_func(vm.w_size)+vm.z*Z_P-vm.w_size, PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("3. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = ((1 &lt;&lt; 32) - 2*Z_Z - Z_I - P_func(vm.s)) / PageSize
                page_length = CelingDevide(P_func(vm.s), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}

                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("4. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                <span class="cov0" title="0">page_index = ((1 &lt;&lt; 32) - Z_Z - Z_I) / PageSize
                page_length = CelingDevide(uint32(len(argument_data_a)), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: true, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("5. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>
                <span class="cov0" title="0">vm.Ram.WriteRAMBytes((1&lt;&lt;32)-Z_Z-Z_I, argument_data_a)

                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)

                page_index = ((1 &lt;&lt; 32) - Z_Z - Z_I + uint32(len(argument_data_a))) / PageSize
                page_length = CelingDevide(P_func(uint32(len(argument_data_a)))-uint32(len(argument_data_a)), PageSize)
                access_mode = AccessMode{Inaccessible: false, Writable: false, Readable: true}
                vm.Ram.SetPageAccess(page_index, page_length, access_mode)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("6. Set Page Index %d and Page Length %d with Access Mode %v\n", page_index, page_length, access_mode)
                }</span>

                // set up the initial values for the registers
                <span class="cov0" title="0">vm.WriteRegister(0, (1&lt;&lt;32)-(1&lt;&lt;16))
                vm.WriteRegister(1, (1&lt;&lt;32)-2*Z_Z-Z_I)
                vm.WriteRegister(7, (1&lt;&lt;32)-Z_Z-Z_I)
                vm.WriteRegister(8, uint64(len(argument_data_a)))</span>
        } else<span class="cov0" title="0"> {
                panic("Standard Program Initialization Error\n")</span>
        }
}

// NewVM initializes a new VM with a given program
func NewVM(service_index uint32, code []byte, initialRegs []uint64, initialPC uint32, hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        if len(code) == 0 </span><span class="cov0" title="0">{
                panic("NO CODE\n")</span>
        }
        <span class="cov0" title="0">p, o_size, w_size, z, s, o_byte, w_byte := DecodeProgram(code)
        _ = o_byte
        _ = w_byte

        // TODO: William - initialize RAM "a" @ 0xFEFF0000 (2^32 - Z_Q - Z_I) based on entrypoint:
        //  Refine a = E(s, y, p, c, a, o, x bar ...) Eq 271
        //  Accumulate a = E(o) Eq 275
        //  IsAuthorized - E(p,c) Eq 268
        //  Transfer - E(t) Eq 282
        vm := &amp;VM{
                JSize:         p.JSize,
                Z:             p.Z,
                J:             p.J,
                code:          p.Code,
                bitmask:       p.K[0], // pass in bitmask K
                register:      make([]uint64, regSize),
                pc:            initialPC,
                Ram:           NewRAM(),
                hostenv:       hostENV, //check if we need this
                Exports:       make([][]byte, 0),
                Service_index: service_index,
                o_size:        o_size,
                w_size:        w_size,
                z:             z,
                s:             s,
                o_byte:        o_byte,
                w_byte:        w_byte,
        }
        // for _, pg := range pages {
        //         vm.writeRAMBytes(pg.Address, pg.Contents)
        // }
        copy(vm.register, initialRegs)
        // Standard Program Initialization
        // Standard_Program_Initialization(vm, []byte{})
        return vm</span>
}

// NewVM with entrypoint and IsMalicious
// func NewVM_With_EntryPoint(service_index uint32, code []byte, initialRegs []uint32, initialPC uint32, pagemap []PageMap, pages []Page, hostENV types.HostEnv, Entrypoint uint32, IsMalicious bool) *VM {
//         if len(code) == 0 {
//                 panic("NO CODE\n")
//         }
//         fmt.Println("Code: ", code)
//         p := DecodeProgram(code)
//         fmt.Printf("Code: %v K(bitmask): %v\n", p.Code, p.K[0])
//         fmt.Println("================================================================")
//         vm := &amp;VM{
//                 JSize:         p.JSize,
//                 Z:             p.Z,
//                 J:             p.J,
//                 code:          p.Code,
//                 bitmask:       p.K[0], // pass in bitmask K
//                 register:      make([]uint32, regSize),
//                 pc:            initialPC,
//                 ram:           make(map[uint32][4096]byte),
//                 hostenv:       hostENV, //check if we need this
//                 Exports:       make([][]byte, 0),
//                 service_index: service_index,
//                 EntryPoint:    Entrypoint,
//                 IsMalicious:   IsMalicious,
//         }
//         // set vm.pc with entrypoint
//         vm.pc = Entrypoint
//         for _, pg := range pages {
//                 vm.writeRAMBytes(pg.Address, pg.Contents)
//         }
//         copy(vm.register, initialRegs)
//         return vm
// }

// func NewVMFromParseProgramTest(code []byte) {
//         p := DecodeProgram(code)
//         fmt.Printf("Code: %v K(bitmask): %v\n", p.Code, p.K[0])
//         fmt.Println("================================================================")
// }

func NewVMFromCode(serviceIndex uint32, code []byte, i uint32, hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        return NewVM(serviceIndex, code, []uint64{}, i, hostENV)
}</span>

// func NewVMFromCode_With_EntryPoint(serviceIndex uint32, code []byte, i uint32, hostENV types.HostEnv, Entrypoint uint32, IsMalicious bool) *VM {
//         return NewVM_With_EntryPoint(serviceIndex, code, []uint32{}, i, []PageMap{}, []Page{}, hostENV, Entrypoint, IsMalicious)
// }

func NewForceCreateVM(code []byte, bitmask string, hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        return &amp;VM{
                code:    code,
                bitmask: bitmask,
                hostenv: hostENV,
        }
}</span>

func NewVMFortest(hostENV types.HostEnv) *VM <span class="cov0" title="0">{
        return &amp;VM{
                register: make([]uint64, regSize),
                hostenv:  hostENV,
                Ram:      NewRAM(),
        }
}</span>

func (vm *VM) SetServiceIndex(index uint32) <span class="cov0" title="0">{
        vm.Service_index = index
}</span>

func (vm *VM) GetServiceIndex() uint32 <span class="cov0" title="0">{
        return vm.Service_index
}</span>

func (vm *VM) ExecuteRefine(s uint32, y []byte, workPackageHash common.Hash, codeHash common.Hash, authorizerCodeHash common.Hash, authorization []byte) (r types.Result, res uint64) <span class="cov0" title="0">{
        // TODO: William -- work with Sean on encode/decode of argument inputs here
        // Refine inputs: let a = E(s, y, p, c, a, o, ↕[↕x S x &lt;− x])
        a := common.Uint32ToBytes(s)                 // s - the service index
        a = append(a, y...)                          //  work payload, y,
        a = append(a, workPackageHash.Bytes()...)    // p - work package hash
        a = append(a, codeHash.Bytes()...)           //  c - the prediction of the hash of that service’s code c at the time of reporting,
        a = append(a, authorizerCodeHash.Bytes()...) //
        a = append(a, authorization...)              // authorization
        // a = append(a, common.ConcatenateByteSlices(extrinsicsBlobs)...)
        // vm.setArgumentInputs(a)

        Standard_Program_Initialization(vm, a) // eq 264/265
        vm.Execute(types.EntryPointRefine)
        return vm.getArgumentOutputs()
}</span>

func (vm *VM) ExecuteAccumulate(elements []types.AccumulateOperandElements, X *types.XContext) (r types.Result, res uint64) <span class="cov0" title="0">{
        var arguments []types.AccumulateOperandElements
        a, _ := types.Encode(elements)
        // need to figure out how the encoded elements are used in the PVM
        decoded, _, err := types.Decode(a, reflect.TypeOf(arguments))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">arguments, ok := decoded.([]types.AccumulateOperandElements)
        if !ok </span><span class="cov0" title="0">{
                panic("decoded data is not of type []types.AccumulateOperandElements")</span>
        }
        <span class="cov0" title="0">for _, argument := range arguments </span><span class="cov0" title="0">{ // here I can't understand, why you encode and decode the elements. should use encoded elements directly
                Standard_Program_Initialization(vm, argument.Results.Ok) // eq 264/265
                vm.X = X                                                 //⎩I(u, s), I(u, s)⎫⎭
                vm.Y = X.Clone()
                vm.Execute(types.EntryPointAccumulate) // F ∈ Ω⟨(X, X)⟩
        }</span>
        // where is the gas being used?
        // return vm.getArgumentOutputs()
        <span class="cov0" title="0">r.Err = vm.resultCode
        r.Ok = []byte{}
        return r, 0</span>
}
func (vm *VM) ExecuteTransfer(arguments []byte, service_account *types.ServiceAccount) (r types.Result, res uint64) <span class="cov0" title="0">{
        // a = E(t)   take transfer memos t and encode them
        vm.ServiceAccount = service_account

        Standard_Program_Initialization(vm, arguments) // eq 264/265
        vm.Execute(types.EntryPointOnTransfer)
        // return vm.getArgumentOutputs()
        r.Err = vm.resultCode
        r.Ok = []byte{}
        return r, 0
}</span>

// E(p, c)
func (vm *VM) ExecuteAuthorization(p types.WorkPackage, c uint32) (r types.Result, res uint64) <span class="cov0" title="0">{
        a := p.Bytes()
        a = append(a, common.Uint32ToBytes(c)...)
        // vm.setArgumentInputs(a)
        Standard_Program_Initialization(vm, a) // eq 264/265
        vm.Execute(types.EntryPointOnTransfer)
        return vm.getArgumentOutputs()
}</span>

// Execute runs the program until it terminates
func (vm *VM) Execute(entryPoint int) error <span class="cov0" title="0">{
        vm.pc = uint32(entryPoint)
        for !vm.terminated </span><span class="cov0" title="0">{
                if err := vm.step(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // host call invocation
                <span class="cov0" title="0">if vm.hostCall </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Println("Invocate Host Function: ", vm.host_func_id)
                        }</span>
                        <span class="cov0" title="0">vm.InvokeHostCall(vm.host_func_id)
                        vm.hostCall = false
                        vm.terminated = false</span>
                }
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("-----------------------------------------------------------------------")
                }</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Println("last pc: ", vm.pc)
        }</span>
        // if vm finished without error, set result code to OK
        <span class="cov0" title="0">vm.resultCode = types.RESULT_OK
        return nil</span>
}

// set ups extrinsics and payload
func (vm *VM) SetExtrinsicsPayload(extrinsics [][]byte, payload []byte) error <span class="cov0" title="0">{
        vm.Extrinsics = extrinsics
        vm.payload = payload
        return nil
}</span>

// set up Imports
func (vm *VM) SetImports(imports [][]byte) error <span class="cov0" title="0">{
        vm.Imports = imports
        return nil
}</span>

// copy a into 2^32 - Z_Q - Z_I and initialize registers
func (vm *VM) setArgumentInputs(a []byte) error <span class="cov0" title="0">{
        vm.WriteRegister(0, 0)
        vm.WriteRegister(1, 0xFFFF0000) // 2^32 - 2^16
        vm.WriteRegister(2, 0xFEFE0000) // 2^32 - 2 * 2^16 - 2^24
        for r := 3; r &lt; 10; r++ </span><span class="cov0" title="0">{
                vm.WriteRegister(r, 0)
        }</span>
        <span class="cov0" title="0">vm.WriteRegister(10, 0xFEFF0000) // 2^32 - 2^16 - 2^24
        vm.WriteRegister(11, uint64(len(a)))
        for r := 12; r &lt; 16; r++ </span><span class="cov0" title="0">{
                vm.WriteRegister(r, 0)
        }</span>
        <span class="cov0" title="0">vm.Ram.WriteRAMBytes(0xFEFF0000, a)
        return nil</span>
}

func (vm *VM) getArgumentOutputs() (r types.Result, res uint64) <span class="cov0" title="0">{
        o, _ := vm.ReadRegister(10)
        l, _ := vm.ReadRegister(11)

        output, res := vm.Ram.ReadRAMBytes(uint32(o), uint32(l))
        r.Err = vm.resultCode
        if r.Err == types.RESULT_OK </span><span class="cov0" title="0">{
                r.Ok = output
        }</span>
        <span class="cov0" title="0">return r, res</span>
}

// step performs a single step in the PVM
func (vm *VM) step() error <span class="cov0" title="0">{
        if vm.pc &gt;= uint32(len(vm.code)) </span><span class="cov0" title="0">{
                return errors.New("program counter out of bounds")
        }</span>

        <span class="cov0" title="0">instr := vm.code[vm.pc]
        opcode := instr
        len_operands := skip(vm.pc, vm.bitmask)
        x := vm.pc + 4
        if x &gt; uint32(len(vm.code)) </span><span class="cov0" title="0">{
                x = uint32(len(vm.code))
        }</span>
        <span class="cov0" title="0">operands := vm.code[vm.pc+1 : vm.pc+1+len_operands]
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("pc: %d opcode: %d - operands: %v, len(operands) = %d\n", vm.pc, opcode, operands, len_operands)
        }</span>
        <span class="cov0" title="0">switch instr </span>{
        case TRAP:<span class="cov0" title="0">
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("TERMINATED\n")
                }</span>
                <span class="cov0" title="0">if instr == TRAP </span><span class="cov0" title="0">{
                        vm.resultCode = types.RESULT_PANIC
                }</span> else<span class="cov0" title="0"> {
                        vm.resultCode = types.RESULT_OK
                }</span>
                <span class="cov0" title="0">vm.terminated = true</span>
        case FALLTHROUGH:<span class="cov0" title="0">
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("FALLTHROUGH")
                }</span>
                <span class="cov0" title="0">vm.pc += 1</span>
        case JUMP:<span class="cov0" title="0">
                // handle no operand means 0
                originalOperands := make([]byte, len(operands))
                copy(originalOperands, operands)
                lx := min(4, len(originalOperands))
                if lx == 0 </span><span class="cov0" title="0">{
                        lx = 1
                        originalOperands = append(originalOperands, 0)
                }</span>
                <span class="cov0" title="0">vx := z_encode(types.DecodeE_l(originalOperands[0:lx]), uint32(lx))

                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Jump to: ", uint32(int64(vm.pc)+vx))
                }</span>
                <span class="cov0" title="0">errCode := vm.branch(uint32(int64(vm.pc)+vx), true)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case JUMP_IND:<span class="cov0" title="0">
                // handle no operand means 0
                originalOperands := make([]byte, len(operands))
                copy(originalOperands, operands)

                registerIndexA := min(12, int(originalOperands[0])%16)
                lx := min(4, max(0, len(originalOperands))-1)
                if lx == 0 </span><span class="cov0" title="0">{
                        lx = 1
                        originalOperands = append(originalOperands, 0)
                }</span>
                <span class="cov0" title="0">vx := uint32(types.DecodeE_l(originalOperands[1 : 1+lx]))

                valueA, errCode := vm.ReadRegister(registerIndexA)
                j := uint32(valueA) + uint32(vx)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Djump to: ", j)
                }</span>
                <span class="cov0" title="0">vm.djump(j)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case LOAD_IMM_JUMP:<span class="cov0" title="0">
                errCode := vm.loadImmJump(operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case LOAD_IMM_JUMP_IND:<span class="cov0" title="0">
                errCode := vm.loadImmJumpInd(operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case BRANCH_EQ, BRANCH_NE, BRANCH_LT_U, BRANCH_LT_S, BRANCH_GE_U, BRANCH_GE_S:<span class="cov0" title="0">
                errCode := vm.branchReg(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case BRANCH_EQ_IMM, BRANCH_NE_IMM, BRANCH_LT_U_IMM, BRANCH_LT_S_IMM, BRANCH_LE_U_IMM, BRANCH_LE_S_IMM, BRANCH_GE_U_IMM, BRANCH_GE_S_IMM, BRANCH_GT_U_IMM, BRANCH_GT_S_IMM:<span class="cov0" title="0">
                errCode := vm.branchCond(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
        case ECALLI:<span class="cov0" title="0">
                errCode := vm.ecalli(operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands

                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("TERMINATED\n")
                }</span>
                <span class="cov0" title="0">if errCode != OK </span><span class="cov0" title="0">{
                        vm.resultCode = types.RESULT_FAULT
                        vm.terminated = true
                }</span>
        case STORE_IMM_U8, STORE_IMM_U16, STORE_IMM_U32, STORE_IMM_U64:<span class="cov0" title="0">
                errCode := vm.storeImm(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case LOAD_IMM:<span class="cov0" title="0">
                errCode := vm.loadImm(operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case LOAD_U8, LOAD_U16, LOAD_U32, LOAD_U64, LOAD_I8, LOAD_I16, LOAD_I32:<span class="cov0" title="0">
                errCode := vm.load(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case STORE_U8, STORE_U16, STORE_U32:<span class="cov0" title="0">
                errCode := vm.store(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case STORE_IMM_IND_U8, STORE_IMM_IND_U16, STORE_IMM_IND_U32, STORE_IMM_IND_U64:<span class="cov0" title="0">
                errCode := vm.storeImmInd(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case STORE_IND_U8, STORE_IND_U16, STORE_IND_U32, STORE_IND_U64:<span class="cov0" title="0">
                errCode := vm.storeInd(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case LOAD_IND_U8, LOAD_IND_I8, LOAD_IND_U16, LOAD_IND_I16, LOAD_IND_U32, LOAD_IND_I32, LOAD_IND_U64:<span class="cov0" title="0">
                errCode := vm.loadInd(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
                // MUL_UPPER_S_S_IMM, MUL_UPPER_S_S_IMM
        case ADD_IMM_32, AND_IMM, XOR_IMM, OR_IMM, MUL_IMM, SET_LT_U_IMM, SET_LT_S_IMM:<span class="cov0" title="0">
                errCode := vm.aluImm(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case CMOV_IZ_IMM, CMOV_NZ_IMM:<span class="cov0" title="0">
                errCode := vm.cmovImm(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>

        case SHLO_R_IMM_32, SHLO_L_IMM_32, SHAR_R_IMM_32, NEG_ADD_IMM_32, SET_GT_U_IMM, SET_GT_S_IMM, SHLO_R_IMM_ALT_32, SHLO_L_IMM_ALT_32, SHAR_R_IMM_ALT_32:<span class="cov0" title="0">
                errCode := vm.shiftImm(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case ADD_32, ADD_64, SUB_32, SUB_64, AND, XOR, OR, MUL_32, MUL_64, MUL_UPPER_S_S, MUL_UPPER_U_U, MUL_UPPER_S_U, DIV_U_32, DIV_U_64, DIV_S_32, DIV_S_64, REM_U_32, REM_U_64, REM_S_32, REM_S_64, CMOV_IZ, CMOV_NZ, SHLO_L_32, SHLO_L_64, SHLO_R_32, SHLO_R_64, SHAR_R_32, SHAR_R_64, SET_LT_U, SET_LT_S:<span class="cov0" title="0">
                errCode := vm.aluReg(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case MOVE_REG:<span class="cov0" title="0">
                errCode := vm.moveReg(operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                // vm.writeRegister(0, errCode)
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case SBRK:<span class="cov0" title="0">
                vm.sbrk(operands)
                break</span>

        // New opcodes
        case LOAD_IMM_64:<span class="cov0" title="0">
                errCode := vm.Instructions_with_Arguments_of_One_Register_and_One_Extended_Width_Immediate(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>
        case ADD_IMM_64, SHLO_L_IMM_64, SHLO_R_IMM_64:<span class="cov0" title="0">
                errCode := vm.Instructions_with_Arguments_of_Two_Registers_and_One_Immediate(opcode, operands)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Println("Error: ", errCode)
                }</span>
                <span class="cov0" title="0">vm.pc += 1 + len_operands</span>

        default:<span class="cov0" title="0">
                vm.terminated = true
                vm.resultCode = types.RESULT_PANIC
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("Unknown opcode: %d\n", opcode)
                        fmt.Printf("----\n")
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        //vm.pc += 1 + uint32(skip(opcode))

        <span class="cov0" title="0">return nil</span>
}

func reverseBytes(b []byte) []byte <span class="cov0" title="0">{
        n := len(b)
        for i := 0; i &lt; n/2; i++ </span><span class="cov0" title="0">{
                b[i], b[n-1-i] = b[n-1-i], b[i]
        }</span>
        <span class="cov0" title="0">return b</span>
}

// skip calculates the skip distance based on the opcode
// func skip(opcode byte) uint32 {
//         switch opcode {
//         case JUMP, LOAD_IMM_JUMP, LOAD_IMM_JUMP_IND:
//                 return uint32(1)
//         case BRANCH_EQ, BRANCH_NE, BRANCH_GE_U, BRANCH_GE_S, BRANCH_LT_U, BRANCH_LT_S:
//                 return uint32(2)
//         case BRANCH_EQ_IMM, BRANCH_NE_IMM, BRANCH_LT_U_IMM, BRANCH_LT_S_IMM, BRANCH_LE_U_IMM, BRANCH_LE_S_IMM, BRANCH_GE_U_IMM, BRANCH_GE_S_IMM, BRANCH_GT_U_IMM, BRANCH_GT_S_IMM:
//                 return uint32(3)
//         default:
//                 return uint32(0)
//         }
// }

// skip function calculates the distance to the next instruction
func skip(pc uint32, bitmask string) uint32 <span class="cov0" title="0">{
        // Convert the bitmask string to a slice of bytes
        bitmaskBytes := []byte(bitmask)

        // Iterate through the bitmask starting from the given pc position
        var i uint32
        for i = pc + 1; i &lt; pc+25 &amp;&amp; i &lt; uint32(len(bitmaskBytes)); i++ </span><span class="cov0" title="0">{
                // Ensure we do not access out of bounds
                if bitmaskBytes[i] == '1' </span><span class="cov0" title="0">{
                        return i - pc - 1
                }</span>
        }
        // If no '1' is found within the next 24 positions, check the last index
        <span class="cov0" title="0">if i &lt; pc+25 </span><span class="cov0" title="0">{
                return i - pc - 1
        }</span>
        <span class="cov0" title="0">return uint32(24)</span>
}

func (vm *VM) get_varpi(opcodes []byte, bitmask string) map[int]struct{} <span class="cov0" title="0">{
        result := make(map[int]struct{})
        for i, opcode := range opcodes </span><span class="cov0" title="0">{
                if bitmask[i] == '1' </span><span class="cov0" title="0">{
                        if _, exists := T[int(opcode)]; exists </span><span class="cov0" title="0">{
                                result[int(opcode)] = struct{}{}
                        }</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

// func (vm *VM) djump(operands []byte) uint32 {

//         if len(operands) != 1 {
//                 return OOB
//         }

//         registerIndexA := minInt(12, int(operands[0])%16)
//         immIndexX := minInt(4, (len(operands)-1)%256)

//         var vx uint32
//         if 1+immIndexX &lt; len(operands) {
//                 vx = get_elided_uint32(operands[1 : 1+immIndexX])
//         } else {
//                 vx = 0
//         }

//         valueA, errCode := vm.readRegister(registerIndexA)
//         if errCode != OK {
//                 return errCode
//         }

//         var target uint32
//         Za := uint32(4)
//         terminationInstructions := vm.get_varpi(vm.code, vm.bitmask)

//         if (valueA/Za - 1) &lt; uint32(len(vm.J)) {
//                 target = uint32(vm.J[(valueA/Za - 1)])
//         } else {
//                 target = uint32(99999)
//         }

//         _, exists := terminationInstructions[int(target)]

//         if valueA == uint32((1&lt;&lt;32)-(1&lt;&lt;16)) {
//                 fmt.Printf("TERMINATED\n")
//                 vm.resultCode = types.RESULT_OK
//                 vm.terminated = true
//         } else if valueA == 0 || valueA &gt; vx*Za || valueA%Za != 0 || exists {
//                 vm.resultCode = types.RESULT_OOB
//                 vm.terminated = true
//                 return OOB
//         } else {
//                 vm.pc = vm.pc + target
//         }

//         return OK
// }

func (vm *VM) djump(a uint32) <span class="cov0" title="0">{
        if a == uint32((1&lt;&lt;32)-(1&lt;&lt;16)) </span><span class="cov0" title="0">{
                vm.terminated = true
        }</span> else<span class="cov0" title="0"> if a == 0 || a &gt; uint32(len(vm.J)*Z_A) || a%Z_A != 0 </span><span class="cov0" title="0">{
                vm.terminated = true
                // panic("OOB")
        }</span> else<span class="cov0" title="0"> {
                vm.pc = uint32(vm.J[(a/Z_A)-1])
        }</span>
}

func (vm *VM) ReadRegister(index int) (uint64, uint64) <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(vm.register) </span><span class="cov0" title="0">{
                return 0, OOB
        }</span>
        // fmt.Printf(" REGISTERS %v (index=%d =&gt; %d)\n", vm.register, index, vm.register[index])
        <span class="cov0" title="0">return vm.register[index], OK</span>
}

func (vm *VM) WriteRegister(index int, value uint64) uint64 <span class="cov0" title="0">{
        if index &lt; 0 || index &gt;= len(vm.register) </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">vm.register[index] = value
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("Register[%d] = %d\n", index, value)
        }</span>
        <span class="cov0" title="0">return OK</span>
}

func (vm *VM) ReadRegisters() []uint64 <span class="cov0" title="0">{
        return vm.register
}</span>

// Implement the dynamic jump logic
func (vm *VM) dynamicJump(operands []byte) uint64 <span class="cov0" title="0">{
        if len(operands) != 1 </span><span class="cov0" title="0">{
                return OOB
        }</span>
        <span class="cov0" title="0">a := int(operands[0])
        const ZA = 4

        if a == 0 || a &gt; 0x7FFFFFFF </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">targetIndex := uint32(a/ZA - 1)
        if targetIndex &gt;= uint32(len(vm.code)) </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">vm.pc = targetIndex
        return OK</span>
}

// Implement ecall logic
func (vm *VM) ecalli(operands []byte) uint64 <span class="cov0" title="0">{
        // Implement ecalli logic here
        lx := uint32(types.DecodeE_l(operands))
        vm.hostCall = true
        vm.host_func_id = int(lx)
        return HOST
}</span>

// Implement storeImm logic
func (vm *VM) storeImm(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        lx := min(4, int(originalOperands[0])%8)
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly))

        switch opcode </span>{
        case STORE_IMM_U8:<span class="cov0" title="0">
                value := vy % (1 &lt;&lt; 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U8: %d %v\n", vx, []byte{byte(value)})
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), []byte{byte(value)})</span>
        case STORE_IMM_U16:<span class="cov0" title="0">
                value := types.E_l(uint64(vy%(1&lt;&lt;16)), 2)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        case STORE_IMM_U32:<span class="cov0" title="0">
                value := types.E_l(uint64(vy), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        case STORE_IMM_U64:<span class="cov0" title="0">
                // TODO: NEW - check this
                value := types.E_l(uint64(vy), 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_IMM_U64: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        }

        <span class="cov0" title="0">return OOB</span>
}

// load_imm (opcode 4)
func (vm *VM) loadImm(operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        return vm.WriteRegister(registerIndexA, uint64(vx))</span>
}

// LOAD_U8, LOAD_U16, LOAD_U32, LOAD_U64, LOAD_I8, LOAD_I16, LOAD_I32
func (vm *VM) load(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case LOAD_U8, LOAD_I8:<span class="cov0" title="0"> // TODO: CHECK NEW LOAD_I8
                value, errCode := vm.Ram.ReadRAMBytes((uint32(vx)), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U8: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, uint64(value[0]))</span>
        case LOAD_U16, LOAD_I16:<span class="cov0" title="0"> // TODO: CHECK NEW LOAD_I16
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, uint64(types.DecodeE_l(value)))</span>
        case LOAD_U32, LOAD_I32:<span class="cov0" title="0"> // TODO: CHECK NEW LOAD_I32
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, uint64(types.DecodeE_l(value)))</span>
        case LOAD_U64:<span class="cov0" title="0"> // TODO: NEW, check this
                value, errCode := vm.Ram.ReadRAMBytes(uint32(vx), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_U64: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, uint64(types.DecodeE_l(value)))</span>
        }
        <span class="cov0" title="0">return OK</span>
}

func get_elided_uint32(o []byte) uint32 <span class="cov0" title="0">{
        /* GP:
        Immediate arguments are encoded in little-endian format with the most-significant bit being the sign bit.
        They may be compactly encoded by eliding more significant octets. Elided octets are assumed to be zero if the MSB of the value is zero, and 255 otherwise.
        */
        if len(o) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">if len(o) &lt; 4 </span><span class="cov0" title="0">{
                newNumbers := make([]byte, 4)
                copy(newNumbers, o)
                var fillValue byte
                if o[len(o)-1] &gt; 127 </span><span class="cov0" title="0">{
                        fillValue = byte(255)
                }</span> else<span class="cov0" title="0"> {
                        fillValue = byte(0)
                }</span>
                <span class="cov0" title="0">for i := len(o); i &lt; 4; i++ </span><span class="cov0" title="0">{
                        newNumbers[i] = fillValue
                }</span>
                <span class="cov0" title="0">o = newNumbers</span>
        }

        <span class="cov0" title="0">x := make([]byte, 4)
        if len(o) &gt; 0 </span><span class="cov0" title="0">{
                x[3] = o[0]
        }</span>
        <span class="cov0" title="0">if len(o) &gt; 1 </span><span class="cov0" title="0">{
                x[2] = o[1]
        }</span>
        <span class="cov0" title="0">if len(o) &gt; 2 </span><span class="cov0" title="0">{
                x[1] = o[2]
        }</span>
        <span class="cov0" title="0">if len(o) &gt; 3 </span><span class="cov0" title="0">{
                x[0] = o[3]
        }</span>

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("get_elided_uint32 %v from %v\n", x, o)
        }</span>
        <span class="cov0" title="0">return binary.BigEndian.Uint32(x)</span>
}

func get_elided_int32(o []byte) int32 <span class="cov0" title="0">{
        x := make([]byte, 4)
        x[0] = 0xff
        x[1] = 0xff
        x[2] = 0xff
        x[3] = 0xff
        // Copy the input bytes to the right end of x
        copy(x[4-len(o):], o)
        if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("get_elided_int32 %v from %v\n", x, o)
        }</span>
        <span class="cov0" title="0">return int32(binary.BigEndian.Uint32(x))</span>
}

// STORE_U8, STORE_U16, STORE_U32
func (vm *VM) store(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case STORE_U8:<span class="cov0" title="0">
                value := valueA % (1 &lt;&lt; 8)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_u8: %d %v\n", vx, []byte{byte(value)})
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), []byte{byte(value)})</span>
        case STORE_U16:<span class="cov0" title="0">
                value := types.E_l(uint64(valueA%(1&lt;&lt;16)), 2)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_U16: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        case STORE_U32:<span class="cov0" title="0">
                value := types.E_l(uint64(valueA), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("STORE_U32: %d %v\n", vx, value)
                }</span>
                <span class="cov0" title="0">return vm.Ram.WriteRAMBytes(uint32(vx), value)</span>
        }
        <span class="cov0" title="0">return OOB</span>
}

// storeImmInd implements STORE_IMM_{U8, U16, U32}
func (vm *VM) storeImmInd(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0])/16)%8)
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return OOB
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly))

        switch opcode </span>{
        case STORE_IMM_IND_U8:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U8: %d %v\n", valueA+vx, []byte{byte(vy % 8)})
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), []byte{byte(vy % 8)})</span>
        case STORE_IMM_IND_U16:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U16: %d %v\n", valueA+vx, types.E_l(uint64(vy%1&lt;&lt;16), 2))
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy%1&lt;&lt;16), 2))</span>
        case STORE_IMM_IND_U32:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IMM_IND_U32: %d %v\n", valueA+vx, types.E_l(uint64(vy), 4))
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy), 4))</span>
        case STORE_IMM_IND_U64:<span class="cov0" title="0">
                return vm.Ram.WriteRAMBytes(uint32(valueA)+uint32(vx), types.E_l(uint64(vy), 8))</span>
        }
        <span class="cov0" title="0">return OOB</span>
}

// Implement loadImmJump logic
func (vm *VM) loadImmJump(operands []byte) uint32 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0]) / 16 % 8))
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := uint32(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly)))

        vm.WriteRegister(registerIndexA, uint64(vx))

        vm.branch(vy, true)
        return OK</span>
}

// Implement loadImmJumpInd logic
func (vm *VM) loadImmJumpInd(operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, (int(originalOperands[1]) % 8))
        ly := min(4, max(0, len(originalOperands)-lx-2))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[2:2+lx]), uint32(lx))
        vy := x_encode(types.DecodeE_l(originalOperands[2+lx:2+lx+ly]), uint32(ly))

        valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">vm.WriteRegister(registerIndexA, uint64(vx))
        vm.djump(uint32(valueB) + uint32(vy))

        return OK</span>
}

// move_reg (opcode 82)
func (vm *VM) moveReg(operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexD := min(12, int(originalOperands[0])%16)
        registerIndexA := min(12, int(originalOperands[0])/16)

        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("MOVE_REG: %d %d\n", registerIndexA, registerIndexD)
        }</span>
        <span class="cov0" title="0">return vm.WriteRegister(registerIndexD, valueA)</span>
}

func (vm *VM) sbrk(operands []byte) error <span class="cov0" title="0">{
        // TODO
        fmt.Printf("sbrk not implemented -- operands %v", operands)
        /*        srcIndex, destIndex := splitRegister(operands[0])

                amount := int(operands[0])
                newRAM := make([]byte, len(vm.ram)+amount)
                copy(newRAM, vm.ram)
                vm.ram = newRAM */
        return nil
}</span>

func (vm *VM) branch(vx uint32, condition bool) uint32 <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                vm.pc = uint32(vx)
        }</span>
        <span class="cov0" title="0">return OK</span>
}

func (vm *VM) branchCond(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, (int(originalOperands[0]) / 16 % 8))
        ly := min(4, max(0, len(originalOperands)-lx-1))
        if ly == 0 </span><span class="cov0" title="0">{
                ly = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        vy := uint32(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1+lx:1+lx+ly]), uint32(ly)))

        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">switch opcode </span>{
        case BRANCH_EQ_IMM:<span class="cov0" title="0">
                if valueA == uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_EQ_IMM: %valueA=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_NE_IMM:<span class="cov0" title="0">
                if valueA != uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_NE_IMM: %valueA!=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LT_U_IMM:<span class="cov0" title="0">
                if valueA &lt; uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LT_U_IMM: %valueA&lt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt; z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LT_S_IMM: %valueA&lt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LE_U_IMM:<span class="cov0" title="0">
                if valueA &lt;= uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LE_U_IMM: %valueA&lt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LE_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt;= z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_LE_S_IMM: %valueA&lt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GE_U_IMM:<span class="cov0" title="0">
                if valueA &gt;= uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GE_U_IMM: %valueA&gt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GE_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt;= z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GE_S_IMM: %valueA&gt;=%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GT_U_IMM:<span class="cov0" title="0">
                if valueA &gt; uint64(vx) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GT_U_IMM: %valueA&gt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt; z_encode(vx, 4) </span><span class="cov0" title="0">{
                        if debug_pvm </span><span class="cov0" title="0">{
                                fmt.Printf("BRANCH_GT_S_IMM: %valueA&gt;%d, jump to %d\n", valueA, vx, vy)
                        }</span>
                        <span class="cov0" title="0">vm.branch(vy, true)</span>
                } else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        }
        <span class="cov0" title="0">return OK</span>

}

func (vm *VM) storeInd(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        switch opcode </span>{
        case STORE_IND_U8:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U8: %d %v\n", valueB+vx, []byte{byte(valueA % 8)})
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), []byte{byte(valueA % 8)})</span>
        case STORE_IND_U16:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U16: %d %v\n", valueB+vx, types.E_l(uint64(valueA%1&lt;&lt;16), 2))
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 2))</span>
        case STORE_IND_U32:<span class="cov0" title="0">
                // if debug_pvm {
                //         fmt.Printf("STORE_IND_U32: %d %v\n", valueB+vx, types.E_l(uint64(valueA), 4))
                // }
                return vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 4))</span>
        case STORE_IND_U64:<span class="cov0" title="0">
                return vm.Ram.WriteRAMBytes(uint32(valueB)+uint32(vx), types.E_l(uint64(valueA), 8))</span>
        default:<span class="cov0" title="0">
                return OOB</span>
        }

}

func (vm *VM) loadInd(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))
        switch opcode </span>{
        case LOAD_IND_U8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := uint64(value[0])
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U8: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I8:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 1)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := uint64(z_decode(z_encode(uint64(value[0]), 1), 4))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_I8: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U16: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I16:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 2)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := z_decode(z_encode(types.DecodeE_l(value), 2), 4)
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_I16: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf("LOAD_IND_U32: ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
                }</span>
                <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_I32:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 4)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := z_decode(z_encode(types.DecodeE_l(value), 4), 4)
                return vm.WriteRegister(registerIndexA, result)</span>
        case LOAD_IND_U64:<span class="cov0" title="0">
                value, errCode := vm.Ram.ReadRAMBytes(uint32(valueB)+uint32(vx), 8)
                if errCode != OK </span><span class="cov0" title="0">{
                        return errCode
                }</span>
                <span class="cov0" title="0">result := uint64(types.DecodeE_l(value))
                return vm.WriteRegister(registerIndexA, result)</span>
        }
        <span class="cov0" title="0">return OOB</span>
}

func splitRegister(operand byte) (int, int) <span class="cov0" title="0">{
        registerIndexA := int(operand &amp; 0xF)
        registerIndexB := int((operand &gt;&gt; 4) &amp; 0xF)
        return registerIndexA, registerIndexB
}</span>

// Implement ALU operations with immediate values
func (vm *VM) aluImm(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint64(x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))) // CHECK

        var result uint64
        switch opcode </span>{
        case ADD_IMM_32:<span class="cov0" title="0">
                result = uint64(valueB) + vx</span>
        case AND_IMM:<span class="cov0" title="0">
                result = valueB &amp; vx</span>
        case XOR_IMM:<span class="cov0" title="0">
                result = valueB ^ vx</span>
        case OR_IMM:<span class="cov0" title="0">
                result = valueB | vx</span>
        case MUL_IMM:<span class="cov0" title="0">
                result = valueB * vx</span>
        //case MUL_UPPER_S_S_IMM:
        //        result = uint32(z_decode((z_encode(valueB, 4) * z_encode(vx, 4)), 4))
        //case MUL_UPPER_U_U_IMM:
        //        result = valueB * vx
        case SET_LT_U_IMM:<span class="cov0" title="0">
                if uint32(valueB) &lt; uint32(vx) </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_LT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueB, 4) &lt; z_encode(vx, 4) </span><span class="cov0" title="0">{ // CHECK
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        default:<span class="cov0" title="0">
                return OOB</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("aluImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
}

// Implement cmov_nz_imm, cmov_nz_imm
func (vm *VM) cmovImm(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint64(x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx)))

        var result uint64
        switch opcode </span>{
        case CMOV_IZ_IMM:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = vx
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        case CMOV_NZ_IMM:<span class="cov0" title="0">
                if valueB != 0 </span><span class="cov0" title="0">{
                        result = vx
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        default:<span class="cov0" title="0">
                return OOB</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("cmovImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
}

// Implement shift operations with immediate values
func (vm *VM) shiftImm(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)

        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">var result uint64
        switch opcode </span>{
        case SHLO_R_IMM_32:<span class="cov0" title="0">
                result = valueB / (1 &lt;&lt; (vx % 32))</span>
        case SHLO_L_IMM_32:<span class="cov0" title="0">
                result = valueB * (1 &lt;&lt; (vx % 32))</span>
        case SHAR_R_IMM_32:<span class="cov0" title="0">
                result = uint64(z_decode(z_encode(valueB, 4)/(1&lt;&lt;(vx%32)), 4))</span> // CHECK
        case NEG_ADD_IMM_32:<span class="cov0" title="0">
                result = uint64(uint64(vx) + uint64(1&lt;&lt;32) - uint64(valueB))</span>
        case SET_GT_U_IMM:<span class="cov0" title="0">
                if valueB &gt; vx </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_GT_S_IMM:<span class="cov0" title="0">
                if z_encode(valueB, 4) &gt; z_encode(vx, 4) </span><span class="cov0" title="0">{ // CHECK
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SHLO_L_IMM_ALT_32:<span class="cov0" title="0">
                result = uint64(vx * (1 &lt;&lt; (valueB % 32)))</span>
        case SHLO_R_IMM_ALT_32:<span class="cov0" title="0">
                result = uint64(vx / (1 &lt;&lt; (valueB % 32)))</span>
        case SHAR_R_IMM_ALT_32:<span class="cov0" title="0">
                result = uint64(z_decode(z_encode(vx, 4)/(1&lt;&lt;(valueB%32)), 4))</span>
        default:<span class="cov0" title="0">
                return OOB</span>
        }
        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("shiftImm ra=%d rb=%d valueB=%d lx=%d vx=%d\n", registerIndexA, registerIndexB, valueB, lx, vx)
        }</span>
        <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
}

// GP_.0.3.6(219)
func z_encode(a uint64, n uint32) int64 <span class="cov0" title="0">{
        modValue := uint64(1 &lt;&lt; (8*n - 1))
        if a &lt; modValue </span><span class="cov0" title="0">{
                return int64(a)
        }</span> else<span class="cov0" title="0"> {
                return int64(a) - int64(1&lt;&lt;(8*n))
        }</span>
}

// GP_.0.3.6(220)
func z_decode(a int64, n uint32) uint64 <span class="cov0" title="0">{
        return (uint64(math.Pow(2, float64(8*n))) + uint64(a)) % uint64(math.Pow(2, float64(8*n)))
}</span>

// GP_.0.3.8(224)
func x_encode(x uint64, n uint32) uint64 <span class="cov0" title="0">{
        if n == 0 </span><span class="cov0" title="0">{
                return x
        }</span>
        <span class="cov0" title="0">return x + (uint64(x)/(1&lt;&lt;(8*n-1)))*(uint64(1&lt;&lt;32)-(1&lt;&lt;(8*n)))</span>
}

// Implement branch logic for two registers and one offset
func (vm *VM) branchReg(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := uint32(int64(vm.pc) + z_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx)))

        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">switch opcode </span>{
        case BRANCH_EQ:<span class="cov0" title="0">
                if valueA == valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_NE:<span class="cov0" title="0">
                if valueA != valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LT_U:<span class="cov0" title="0">
                if valueA &lt; valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_LT_S:<span class="cov0" title="0">
                if z_encode(valueA, 4) &lt; z_encode(valueB, 4) </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GE_U:<span class="cov0" title="0">
                if valueA &gt;= valueB </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        case BRANCH_GE_S:<span class="cov0" title="0">
                if z_encode(valueA, 4) &gt;= z_encode(valueB, 4) </span><span class="cov0" title="0">{
                        vm.branch(vx, true)
                }</span> else<span class="cov0" title="0"> {
                        vm.pc += uint32(1 + len(operands))
                        return OK
                }</span>
        default:<span class="cov0" title="0">
                return OOB</span>
        }

        <span class="cov0" title="0">return OK</span>
}

// Implement ALU operations with register values
func (vm *VM) aluReg(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{

        registerIndexA := min(12, int(operands[0])%16)
        registerIndexB := min(12, int(operands[0])/16)
        registerIndexD := min(12, int(operands[1]))

        valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">var result uint64
        switch opcode </span>{
        case ADD_32, ADD_64:<span class="cov0" title="0">
                // condition on IsMalicious
                if vm.IsMalicious </span><span class="cov0" title="0">{
                        result = valueA * valueB
                }</span> else<span class="cov0" title="0"> {
                        result = valueA + valueB
                }</span>
        case SUB_32, SUB_64:<span class="cov0" title="0">
                result = valueA - valueB</span>
        case AND:<span class="cov0" title="0">
                result = valueA &amp; valueB</span>
        case XOR:<span class="cov0" title="0">
                result = valueA ^ valueB</span>
        case OR:<span class="cov0" title="0">
                result = valueA | valueB</span>
        case MUL_32, MUL_64:<span class="cov0" title="0">
                result = valueA * valueB</span>
        case MUL_UPPER_S_S:<span class="cov0" title="0">
                result = uint64(int(valueA) * int(valueB) &gt;&gt; 32)</span>
        case MUL_UPPER_U_U:<span class="cov0" title="0">
                result = uint64((uint(valueA) * uint(valueB)) &gt;&gt; 32)</span>
        case MUL_UPPER_S_U:<span class="cov0" title="0">
                result = uint64((int(valueA) * int(valueB)) &gt;&gt; 32)</span>
        case DIV_U_32, DIV_U_64:<span class="cov0" title="0"> // TODO: CHECK
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = 0xFFFFFFFF
                }</span> else<span class="cov0" title="0"> {
                        result = valueA / valueB
                }</span>
        case DIV_S_32, DIV_S_64:<span class="cov0" title="0"> // TODO: check
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = 0xFFFFFFFF
                }</span> else<span class="cov0" title="0"> if int32(valueA) == -(1&lt;&lt;31) &amp;&amp; int32(valueB) == -(1&lt;&lt;0) </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> {
                        result = uint64(int32(valueA) / int32(valueB))
                }</span>
        case REM_U_32, REM_U_64:<span class="cov0" title="0"> // TODO: check
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> {
                        result = valueA % valueB
                }</span>
        case REM_S_32, REM_S_64:<span class="cov0" title="0"> // TODO: check
                if debug_pvm </span><span class="cov0" title="0">{
                        fmt.Printf(" REM_S %d %d \n", int32(valueA), int32(valueB))
                }</span>
                <span class="cov0" title="0">if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> if valueA == 0x80 &amp;&amp; valueB == 0xFF </span><span class="cov0" title="0">{
                        return OOB
                }</span> else<span class="cov0" title="0"> {
                        result = uint64(int32(valueA) % int32(valueB))
                }</span>
        case CMOV_IZ:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = valueA
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case CMOV_NZ:<span class="cov0" title="0">
                if valueB == 0 </span><span class="cov0" title="0">{
                        result = 0
                }</span> else<span class="cov0" title="0"> {
                        result = valueA
                }</span>
        case SET_LT_U:<span class="cov0" title="0">
                if valueA &lt; valueB </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>
        case SET_LT_S:<span class="cov0" title="0">
                if int64(valueA) &lt; int64(valueB) </span><span class="cov0" title="0">{
                        result = 1
                }</span> else<span class="cov0" title="0"> {
                        result = 0
                }</span>

        case SHLO_L_32, SHLO_L_64:<span class="cov0" title="0"> // TODO: split
                result = valueA &lt;&lt; (valueB % 32)</span>
        case SHLO_R_32, SHLO_R_64:<span class="cov0" title="0"> // TODO: split
                result = valueA &gt;&gt; (valueB % 32)</span>
        case SHAR_R_32, SHAR_R_64:<span class="cov0" title="0"> // TODO: split
                if int32(valueA)/(1&lt;&lt;(valueB%32)) &lt; 0 &amp;&amp; int32(valueA)%(1&lt;&lt;(valueB%32)) != 0 </span><span class="cov0" title="0">{
                        result = uint64((int32(valueA) / (1 &lt;&lt; (valueB % 32))) - 1)
                }</span> else<span class="cov0" title="0"> {
                        result = uint64(int32(valueA) / (1 &lt;&lt; (valueB % 32)))
                }</span>

        default:<span class="cov0" title="0">
                return OOB</span> // unknown ALU register
        }

        <span class="cov0" title="0">if debug_pvm </span><span class="cov0" title="0">{
                fmt.Printf("aluReg - rA[%d]=%d  regB[%d]=%d regD[%d]=%d\n", registerIndexA, valueA, registerIndexB, valueB, registerIndexD, result)
        }</span>
        <span class="cov0" title="0">return vm.WriteRegister(registerIndexD, result)</span>
}

// VM Management: CreateVM, GetVM, ExpungeVM
func (vm *VM) CreateVM(serviceAcct uint32, code []byte, i uint32) uint32 <span class="cov0" title="0">{
        maxN := uint32(0)
        for n := range vm.VMs </span><span class="cov0" title="0">{
                if n &gt; maxN </span><span class="cov0" title="0">{
                        maxN = n
                }</span>
        }
        <span class="cov0" title="0">if vm.VMs == nil </span><span class="cov0" title="0">{
                vm.VMs = make(map[uint32]*VM)
        }</span>
        <span class="cov0" title="0">fmt.Printf("CreateVM: %d\n", maxN)
        vm.VMs[maxN+1] = NewVMFromCode(serviceAcct, code, i, vm.hostenv)
        return maxN + 1</span>
}

func (vm *VM) GetVM(n uint32) (*VM, bool) <span class="cov0" title="0">{
        vm, ok := vm.VMs[n]
        if !ok </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return vm, true</span>
}

func (vm *VM) ExpungeVM(n uint32) bool <span class="cov0" title="0">{
        _, ok := vm.VMs[n]
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">delete(vm.VMs, n)
        return true</span>
}

// shawn : add a pub function to get the register value
func (vm *VM) GetRegisterValue(registerIndex int) (uint64, uint64) <span class="cov0" title="0">{
        value, errCode := vm.ReadRegister(registerIndex)
        return value, errCode
}</span>

func (vm *VM) SetRegisterValue(registerIndex int, value uint64) uint64 <span class="cov0" title="0">{
        return vm.WriteRegister(registerIndex, value)
}</span>

func (vm *VM) HostCheat(input string) (errcode uint64) <span class="cov0" title="0">{
        if input == "machine" </span><span class="cov0" title="0">{
                errcode = vm.hostMachine()
        }</span> else<span class="cov0" title="0"> if input == "poke" </span><span class="cov0" title="0">{
                errcode = vm.hostPoke()
        }</span> else<span class="cov0" title="0"> if input == "peek" </span><span class="cov0" title="0">{
                errcode = vm.hostPeek()
        }</span> else<span class="cov0" title="0"> if input == "invoke" </span><span class="cov0" title="0">{
                errcode = vm.hostInvoke()
        }</span> else<span class="cov0" title="0"> if input == "expunge" </span><span class="cov0" title="0">{
                errcode = vm.hostExpunge()
        }</span> else<span class="cov0" title="0"> if input == "zero" </span><span class="cov0" title="0">{
                errcode = vm.hostZero()
        }</span>
        <span class="cov0" title="0">return errcode</span>
}

func (vm *VM) Instructions_with_Arguments_of_One_Register_and_One_Extended_Width_Immediate(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>
        <span class="cov0" title="0">vx := types.DecodeE_l(originalOperands[1 : 1+lx])
        return vm.WriteRegister(registerIndexA, uint64(vx))</span>
}

func (vm *VM) Instructions_with_Arguments_of_Two_Registers_and_One_Immediate(opcode byte, operands []byte) uint64 <span class="cov0" title="0">{
        // handle no operand means 0
        originalOperands := make([]byte, len(operands))
        copy(originalOperands, operands)

        registerIndexA := min(12, int(originalOperands[0])%16)
        registerIndexB := min(12, int(originalOperands[0])/16)
        lx := min(4, max(0, len(originalOperands)-1))
        if lx == 0 </span><span class="cov0" title="0">{
                lx = 1
                originalOperands = append(originalOperands, 0)
        }</span>

        <span class="cov0" title="0">valueA, errCode := vm.ReadRegister(registerIndexA)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>
        <span class="cov0" title="0">valueB, errCode := vm.ReadRegister(registerIndexB)
        if errCode != OK </span><span class="cov0" title="0">{
                return errCode
        }</span>

        <span class="cov0" title="0">vx := x_encode(types.DecodeE_l(originalOperands[1:1+lx]), uint32(lx))

        var result uint64
        switch opcode </span>{
        case ADD_IMM_64:<span class="cov0" title="0">
                valueA = valueB + uint64(vx)
                result = valueA</span>

        case SHLO_L_IMM_64:<span class="cov0" title="0">
                valueA = x_encode(valueB*(1&lt;&lt;(vx%64)), 8)
                result = valueA</span>
        case SHLO_R_IMM_64:<span class="cov0" title="0">
                valueA = x_encode(valueB/(1&lt;&lt;(vx%64)), 8)
                result = valueA</span>
        default:<span class="cov0" title="0">
                return OOB</span> // unknown ALU register
        }

        <span class="cov0" title="0">return vm.WriteRegister(registerIndexA, result)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package statedb

import (
        "errors"

        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/pvm"
        "github.com/colorfulnotion/jam/types"
)

type BeefyPool []Beta_state
type BeefyCommitment struct {
        Service    uint32      `json:"service"`
        Commitment common.Hash `json:"commitment"`
}

type Peaks []*common.Hash
type MMR struct {
        Peaks Peaks `json:"peaks"`
}

// v0.4.5 eq.165 - W^!
func AccumulatedImmediately(W []types.WorkReport) []types.WorkReport <span class="cov8" title="1">{
        outputWorkReports := []types.WorkReport{}
        for _, workReport := range W </span><span class="cov0" title="0">{
                if len(workReport.RefineContext.Prerequisites) == 0 &amp;&amp; len(workReport.SegmentRootLookup) == 0 </span><span class="cov0" title="0">{
                        outputWorkReports = append(outputWorkReports, workReport)
                }</span>
        }
        <span class="cov8" title="1">return outputWorkReports</span>
}

// v0.4.5 eq.166 - W^Q
func (j *JamState) QueuedExecution(W []types.WorkReport) []types.AccumulationQueue <span class="cov8" title="1">{
        outputWorkReports := []types.WorkReport{}
        for _, workReport := range W </span><span class="cov0" title="0">{
                if len(workReport.RefineContext.Prerequisites) != 0 || len(workReport.SegmentRootLookup) != 0 </span><span class="cov0" title="0">{
                        outputWorkReports = append(outputWorkReports, workReport)
                }</span>
        }
        <span class="cov8" title="1">accumulatedcup := []common.Hash{}
        accumulated := j.AccumulationHistory
        for i := 0; i &lt; len(accumulated); i++ </span><span class="cov8" title="1">{
                accumulatedcup = append(accumulatedcup, accumulated[i].WorkPackageHash...)
        }</span>

        <span class="cov8" title="1">depandancy := []types.AccumulationQueue{}
        for _, workReport := range outputWorkReports </span><span class="cov0" title="0">{
                depandancy = append(depandancy, Depandancy(workReport))
        }</span>
        <span class="cov8" title="1">return QueueEditing(depandancy, accumulatedcup)</span>
}

// v0.4.5 eq.167 - D(w)
func Depandancy(w types.WorkReport) types.AccumulationQueue <span class="cov0" title="0">{
        result := types.AccumulationQueue{}
        result.WorkReports = append(result.WorkReports, w)
        // w.RefineContext.Prerequisite union key(w.SegmentRootLookup)
        hashSet := make(map[common.Hash]struct{})
        for _, p := range w.RefineContext.Prerequisites </span><span class="cov0" title="0">{
                hashSet[p] = struct{}{}
        }</span>
        /*
                for _, key := range w.SegmentRootLookup {
                        hashSet[key] = struct{}{}
                }
                depandancy := []common.Hash{}
                for key := range hashSet {
                        depandancy = append(depandancy, key)
                }
        */
        // Shawn please check
        <span class="cov0" title="0">for _, segmentRootLookupItem := range w.SegmentRootLookup </span><span class="cov0" title="0">{
                hashSet[segmentRootLookupItem.WorkPackageHash] = struct{}{}
        }</span>
        <span class="cov0" title="0">depandancy := []common.Hash{}
        for key := range hashSet </span><span class="cov0" title="0">{
                depandancy = append(depandancy, key)
        }</span>
        <span class="cov0" title="0">result.WorkPackageHash = depandancy
        return result</span>
}

// v0.4.5 eq.168 - function E
func QueueEditing(r []types.AccumulationQueue, x []common.Hash) []types.AccumulationQueue <span class="cov8" title="1">{
        var result []types.AccumulationQueue
        hashSet := make(map[common.Hash]struct{}, len(x))
        for _, h := range x </span><span class="cov0" title="0">{
                hashSet[h] = struct{}{}
        }</span>

        <span class="cov8" title="1">for _, item := range r </span><span class="cov0" title="0">{
                found := false
                for _, report := range item.WorkReports </span><span class="cov0" title="0">{
                        h := report.AvailabilitySpec.WorkPackageHash
                        if _, exists := hashSet[h]; exists </span><span class="cov0" title="0">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                        new_wp_hash := []common.Hash{}
                        for _, h := range item.WorkPackageHash </span><span class="cov0" title="0">{
                                if _, exists := hashSet[h]; !exists </span><span class="cov0" title="0">{
                                        new_wp_hash = append(new_wp_hash, h)
                                }</span>
                        }
                        <span class="cov0" title="0">item.WorkPackageHash = new_wp_hash
                        result = append(result, item)</span>
                }
        }
        <span class="cov8" title="1">return result</span>
}

// v0.4.5 eq.169 - function Q
func PriorityQueue(r []types.AccumulationQueue) []types.WorkReport <span class="cov8" title="1">{
        g := []types.WorkReport{}
        for _, item := range r </span><span class="cov0" title="0">{
                if len(item.WorkPackageHash) == 0 </span><span class="cov0" title="0">{
                        g = append(g, item.WorkReports...)
                }</span>
        }
        <span class="cov8" title="1">if len(g) == 0 </span><span class="cov8" title="1">{
                return []types.WorkReport{}
        }</span> else<span class="cov0" title="0"> {
                result := g
                result = append(result, PriorityQueue(QueueEditing(r, Mapping(g)))...)
                return result
        }</span>
}

// v0.4.5 eq.170 - function P
func Mapping(w []types.WorkReport) []common.Hash <span class="cov8" title="1">{
        result := []common.Hash{}
        for _, workReport := range w </span><span class="cov0" title="0">{
                result = append(result, workReport.AvailabilitySpec.WorkPackageHash)
        }</span>
        <span class="cov8" title="1">return result</span>
}

// v0.4.5 eq.171 - m
func (s *StateDB) CurrentEpochSlot() uint32 <span class="cov8" title="1">{
        Ht := s.Block.Header.Slot
        return Ht % types.EpochLength
}</span>

// v0.4.5 eq.172 - W^*
func (s *StateDB) AccumulatableSequence(W []types.WorkReport) []types.WorkReport <span class="cov0" title="0">{
        accumulated_immediately := AccumulatedImmediately(W)
        result := accumulated_immediately
        j := s.GetJamState()
        queued_execution := j.QueuedExecution(W)
        result = append(result, PriorityQueue(s.ComputeReadyQueue(queued_execution, accumulated_immediately))...)
        return result
}</span>

// v0.4.5 eq.173 - q
func (s *StateDB) GetReadyQueue(W []types.WorkReport) []common.Hash <span class="cov8" title="1">{
        accumulated_immediately := AccumulatedImmediately(W)
        j := s.GetJamState()
        queued_execution := j.QueuedExecution(W)
        readyQueue := PriorityQueue(s.ComputeReadyQueue(queued_execution, accumulated_immediately))
        readyQueueHeader := []common.Hash{}
        for _, workReport := range readyQueue </span><span class="cov0" title="0">{
                readyQueueHeader = append(readyQueueHeader, workReport.AvailabilitySpec.WorkPackageHash)
        }</span>
        <span class="cov8" title="1">return readyQueueHeader</span>
}

// v0.4.5 eq.173 - q
func (s *StateDB) ComputeReadyQueue(queued_execution []types.AccumulationQueue, accumulated_immediately []types.WorkReport) []types.AccumulationQueue <span class="cov8" title="1">{
        j := s.GetJamState()
        ready_state := j.AccumulationQueue
        m := s.CurrentEpochSlot()
        ready := []types.AccumulationQueue{}
        for i := m; i &lt; types.EpochLength; i++ </span><span class="cov8" title="1">{
                ready = append(ready, ready_state[i]...)
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; int(m); i++ </span><span class="cov8" title="1">{
                ready = append(ready, ready_state[i]...)
        }</span>
        <span class="cov8" title="1">return QueueEditing(append(ready, queued_execution...), Mapping(accumulated_immediately))</span>
}

// CalculateGasAttributable calculates the gas attributable for each service.
func CalculateGasAttributable(
        workReports map[int][]types.WorkReport, // workReports maps service index to their respective work reports
        privilegedServices []int, // privilegedServices contains indices of privileged services
        electiveAccumulationGas float64, // electiveAccumulationGas represents GA in the formula
) []types.GasAttributable <span class="cov0" title="0">{
        gasAttributable := []types.GasAttributable{}
        serviceGasTotals := make(map[int]float64)

        for serviceIndex, reports := range workReports </span><span class="cov0" title="0">{
                var gasSum float64
                for range reports </span><span class="cov0" title="0">{
                        gasSum += 1 // TODO
                }</span>
                <span class="cov0" title="0">serviceGasTotals[serviceIndex] = gasSum</span>
        }

        <span class="cov0" title="0">for _, serviceIndex := range privilegedServices </span><span class="cov0" title="0">{
                if _, exists := serviceGasTotals[serviceIndex]; !exists </span><span class="cov0" title="0">{
                        serviceGasTotals[serviceIndex] = 0
                }</span>
        }

        <span class="cov0" title="0">var totalGasSum float64
        for _, gas := range serviceGasTotals </span><span class="cov0" title="0">{
                totalGasSum += gas
        }</span>

        <span class="cov0" title="0">for serviceIndex, gasSum := range serviceGasTotals </span><span class="cov0" title="0">{
                gas := gasSum + electiveAccumulationGas*(1-(gasSum/totalGasSum))
                gasAttributable = append(gasAttributable, types.GasAttributable{
                        ServiceIndex: serviceIndex,
                        Gas:          gas,
                })
        }</span>

        <span class="cov0" title="0">return gasAttributable</span>
}

/*
We define the outer accumulation function ∆+ which
transforms a gas-limit, a sequence of work-reports, an
initial partial-state and a dictionary of services enjoying
free accumulation, into a tuple of the number of work-
results accumulated, a posterior state-context, the resul-
tant deferred-transfers and accumulation-output pairings:
*/
// eq 173
// ∆+
func (s *StateDB) OuterAccumulate(g uint64, w []types.WorkReport, o *types.PartialState, f map[uint32]uint32) (num uint64, output_t []types.DeferredTransfer, output_b []BeefyCommitment) <span class="cov0" title="0">{
        // not really sure i here , the max meaning. use uint32 for now
        var gas_tmp uint64
        i := uint64(0)
        // calculate how to maximize the work reports to enter the parallelized accumulation
        for _, workReport := range w </span><span class="cov0" title="0">{
                for _, workResult := range workReport.Results </span><span class="cov0" title="0">{
                        gas_tmp += workResult.Gas
                        if gas_tmp &lt;= g </span><span class="cov0" title="0">{
                                i++
                                if i &gt;= uint64(len(w))+1 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                        }

                }
        }
        // fmt.Printf("OuterAccumulate i=%d\n", i)
        <span class="cov0" title="0">if i == 0 </span><span class="cov0" title="0">{ // if i = 0, then nothing to do
                num = 0

                output_t = make([]types.DeferredTransfer, 0)
                output_b = make([]BeefyCommitment, 0)
                return
        }</span>
        <span class="cov0" title="0">if i &gt;= uint64(len(w)) </span><span class="cov0" title="0">{ // if i &gt;= len(w), then all work reports are accumulated
                i = uint64(len(w))
        }</span>
        <span class="cov0" title="0">g_star, t_star, b_star := s.ParallelizedAccumulate(o, w[0:i], f) // parallelized accumulation the 0 to i work reports
        //o.Dump("OuterAccumulate", s.Id)
        if i &gt;= uint64(len(w)) </span><span class="cov0" title="0">{ // no more reports
                return i, t_star, b_star
        }</span>
        <span class="cov0" title="0">j, outputT, outputB := s.OuterAccumulate(g-g_star, w[i+1:], o, nil) // recursive call to the rest of the work reports
        num = i + j

        output_t = append(outputT, t_star...)
        for _, b := range b_star </span><span class="cov0" title="0">{
                duplicate := false
                for _, existingB := range outputB </span><span class="cov0" title="0">{
                        if existingB.Service == b.Service &amp;&amp; existingB.Commitment == b.Commitment </span><span class="cov0" title="0">{
                                duplicate = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !duplicate </span><span class="cov0" title="0">{
                        output_b = append(output_b, b)
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

/*
the parallelized accumulation function ∆∗ which, with the help of the single-service accumulation function ∆1, transforms an initial state-context, together with a sequence of work-reports and a dictionary of
privileged always-accumulate services, into a tuple of the total gas utilized in pvm execution u, a posterior statecontext (x′,d′,i′,q′) and the resultant accumulationoutput pairings b and deferred-transfers Ì
*/
// the parallelized accumulation function ∆*
// eq 174
func (s *StateDB) ParallelizedAccumulate(o *types.PartialState, w []types.WorkReport, f map[uint32]uint32) (output_u uint64, output_t []types.DeferredTransfer, output_b []BeefyCommitment) <span class="cov0" title="0">{
        services := make([]uint32, 0)
        for _, workReport := range w </span><span class="cov0" title="0">{
                for _, workResult := range workReport.Results </span><span class="cov0" title="0">{
                        services = append(services, workResult.ServiceID)
                }</span>
        }
        <span class="cov0" title="0">output_u = 0
        // get services from f key
        for k := range f </span><span class="cov0" title="0">{
                services = append(services, k)
        }</span>
        // remove duplicates
        <span class="cov0" title="0">services = UniqueUint32Slice(services)
        for _, service := range services </span><span class="cov0" title="0">{
                // this is parallelizable
                T, B, U := s.SingleAccumulate(o, w, f, service)
                output_u += U
                output_b = append(output_b, BeefyCommitment{
                        Service:    service,
                        Commitment: B,
                })
                output_t = append(output_t, T...)
        }</span>

        // s ∈ K(d) ∖ s
        /*s.SingleAccumulate(o, w, f, o.PrivilegedState.Kai_m)
        s.SingleAccumulate(o, w, f, o.PrivilegedState.Kai_a)
        s.SingleAccumulate(o, w, f, o.PrivilegedState.Kai_v) */

        <span class="cov0" title="0">return</span>
}

func UniqueUint32Slice(slice []uint32) []uint32 <span class="cov0" title="0">{
        keys := make(map[uint32]bool)
        list := []uint32{}
        for _, entry := range slice </span><span class="cov0" title="0">{
                if _, value := keys[entry]; !value </span><span class="cov0" title="0">{
                        keys[entry] = true
                        list = append(list, entry)
                }</span>
        }
        <span class="cov0" title="0">return list</span>
}

func (sdb *StateDB) Check(i uint32) uint32 <span class="cov0" title="0">{
        const lowerLimit uint32 = 1 &lt;&lt; 8               // 2^8 = 256
        const upperLimit uint32 = (1 &lt;&lt; 32) - (1 &lt;&lt; 9) // 2^32 - 2^9 = 4294966784

        // Base case: return i if it is not in the set K(delta)
        // if !vm.k_exist(i) {
        //         return i
        // }
        // // Correct handling of the adjustment to prevent negative values:
        // // Convert the expression to int64 to handle potential negatives safely.
        // adjusted := int64(i) - int64(lowerLimit) + 1

        // // Ensure the adjusted value is non-negative and within the valid range:
        // // modResult := ((adjusted % int64(upperLimit)) + int64(upperLimit)) % int64(upperLimit)
        // modResult := (adjusted % int64(upperLimit)) + int64(lowerLimit)

        // // Return check with the adjusted result, adding lowerLimit back to align the range
        // // (i−2^8 +1)mod(2^32 −2^9)+2^8
        // // return vm.check(lowerLimit + uint32(modResult))
        // return vm.check(uint32(modResult))
        for sdb.k_exist(i) </span><span class="cov0" title="0">{
                adjusted := int64(i) - int64(lowerLimit) + 1
                modResult := (adjusted % int64(upperLimit)) + int64(lowerLimit)
                i = uint32(modResult)
        }</span>

        <span class="cov0" title="0">return i</span>
}

func (sdb *StateDB) k_exist(i uint32) bool <span class="cov0" title="0">{
        //check i not in K(δ†) or c(255,i)
        _, ok, err := sdb.GetService(i)
        if err == nil &amp;&amp; ok </span><span class="cov0" title="0">{
                // account found
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// 0.5.2 (B.9)
func (sdb *StateDB) NewXContext(s uint32, serviceAccount *types.ServiceAccount, u *types.PartialState) *types.XContext <span class="cov0" title="0">{

        // Calculate i for X_i eq(277)
        encoded_service, _ := types.Encode(s)
        encoded_entropy, _ := types.Encode(sdb.JamState.SafroleState.Entropy[0].Bytes())
        encoded_timeslot, _ := types.Encode(sdb.JamState.SafroleState.Timeslot)
        encoded := append(encoded_service, append(encoded_entropy, encoded_timeslot...)...)
        hash := common.Blake2Hash(encoded).Bytes()
        decoded := uint32(types.DecodeE_l(hash[:4]))

        x := &amp;types.XContext{
                D: make(map[uint32]*types.ServiceAccount, 0), // this is NOT mutated but holds the state that could get mutatted
                S: s,
                I: sdb.Check(decoded%((1&lt;&lt;32)-(1&lt;&lt;9)) + (1 &lt;&lt; 8)),
        }
        x.D[s] = serviceAccount // this the immutable service account and cannot have Set{...}

        js := sdb.JamState
        if u != nil </span><span class="cov0" title="0">{
                x.U = u
        }</span> else<span class="cov0" title="0"> if x.U == nil </span><span class="cov0" title="0">{
                x.U = &amp;types.PartialState{
                        D:                  make(map[uint32]*types.ServiceAccount), // this IS mutated
                        UpcomingValidators: js.SafroleState.NextValidators,
                        QueueWorkReport:    js.AuthorizationQueue,
                        PrivilegedState:    js.PrivilegedServiceIndices,
                }
        }</span>
        // IMPORTABLE NOW WE MAKE A COPY of serviceAccount AND MAKE IT MUTABLE
        <span class="cov0" title="0">mutableServiceAccount := serviceAccount.Clone()
        mutableServiceAccount.ALLOW_MUTABLE()
        x.U.D[s] = mutableServiceAccount // NOTE: this is a distinct COPY of serviceAccount and CAN have Set{...}
        return x</span>
}

/*
The single-service accumulation function, ∆1, trans-
forms an initial state-context, sequence of work-reports
and a service index into an alterations state-context, a
sequence of transfers, a possible accumulation-output and
the actual pvm gas used. This function wrangles the work-
items of a particular service from a set of work-reports and
invokes pvm execution
*/
// ∆1
// eq 176
func (sd *StateDB) SingleAccumulate(o *types.PartialState, w []types.WorkReport, f map[uint32]uint32, s uint32) (output_t []types.DeferredTransfer, output_b common.Hash, output_u uint64) <span class="cov0" title="0">{
        // gas need to check again
        // check if s is in f
        gas := uint32(0)
        if _, ok := f[s]; ok </span><span class="cov0" title="0">{
                gas = f[s]
        }</span>
        // add all gas from work reports
        <span class="cov0" title="0">for _, workReport := range w </span><span class="cov0" title="0">{
                for _, workResult := range workReport.Results </span><span class="cov0" title="0">{
                        if workResult.ServiceID == s </span><span class="cov0" title="0">{
                                gas += uint32(workResult.Gas)
                        }</span>
                }
        }

        <span class="cov0" title="0">var codeHash common.Hash
        p := make([]types.AccumulateOperandElements, 0)
        for _, workReport := range w </span><span class="cov0" title="0">{
                for _, workResult := range workReport.Results </span><span class="cov0" title="0">{
                        if workResult.ServiceID == s </span><span class="cov0" title="0">{
                                codeHash = workResult.CodeHash
                                p = append(p, types.AccumulateOperandElements{
                                        Results: types.Result{
                                                Ok:  workResult.Result.Ok[:],
                                                Err: types.RESULT_OK,
                                        },
                                        Payload:         workResult.PayloadHash,
                                        WorkPackageHash: workReport.AvailabilitySpec.WorkPackageHash,
                                        AuthOutput:      workReport.AuthOutput,
                                })
                                //fmt.Printf("SingleAccumulate %d workpackagehash=%v result=%v len(result)=%d\n", s, workReport.AvailabilitySpec.WorkPackageHash, workResult.Result.Ok[:], len(workResult.Result.Ok[:]))
                        }</span>
                }
        }

        // this is immutable going into NewXContext
        <span class="cov0" title="0">serviceAccount, ok, err := sd.GetService(s)
        if err != nil || !ok </span><span class="cov0" title="0">{
                // how did we even get here
                panic("Unknown service")</span>
        }
        <span class="cov0" title="0">xContext := sd.NewXContext(s, serviceAccount, o)
        code, ok, err := sd.ReadServicePreimageBlob(s, codeHash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                panic("Could not read blob")</span>
        }
        //o.Dump("SingleAccumulate", sd.Id)
        //(B.8) start point
        <span class="cov0" title="0">vm := pvm.NewVMFromCode(s, code, 0, sd)
        r, _ := vm.ExecuteAccumulate(p, xContext)
        //xContext.U.Dump("POST-ExecuteAccumulate", sd.Id)

        // BeefyCommitment represents a service accumulation result.
        if r.Err == types.RESULT_OK </span><span class="cov0" title="0">{
                output_b = common.Blake2Hash(r.Ok)
        }</span>
        <span class="cov0" title="0">return</span>
}

// input t is a sequence of deferred transfers, d is the desired destination service index, output is a sequence of transfers targeting said service
// eq 179
func TransferSelect(t []types.DeferredTransfer, d uint32) []types.DeferredTransfer <span class="cov0" title="0">{
        var output []types.DeferredTransfer
        for _, transfer := range t </span><span class="cov0" title="0">{
                if transfer.ReceiverIndex == d </span><span class="cov0" title="0">{
                        output = append(output, transfer)
                }</span>
        }
        <span class="cov0" title="0">return output</span>
}

func (s *StateDB) HostTransfer(delta_dager map[uint32]*types.ServiceAccount, time_slot uint32, self_index uint32, t []types.DeferredTransfer) (sa *types.ServiceAccount, err error) <span class="cov0" title="0">{
        // check if self_index is in delta_dager
        if _, ok := delta_dager[self_index]; !ok </span><span class="cov0" title="0">{
                return &amp;types.ServiceAccount{}, errors.New("HostTransfer Error: service not found")
        }</span>

        // select transfers eq 12.23
        <span class="cov0" title="0">selectedTransfers := TransferSelect(t, self_index)
        if len(selectedTransfers) == 0 </span><span class="cov0" title="0">{
                return delta_dager[self_index], nil
        }</span>

        <span class="cov0" title="0">self := delta_dager[self_index]
        code, ok, err := s.ReadServicePreimageBlob(self_index, self.CodeHash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return sa, fmt.Errorf("No blob")
        }</span>
        <span class="cov0" title="0">vm := pvm.NewVMFromCode(self_index, code, 0, s)

        var input_argument []byte
        encode_time_slot, _ := types.Encode(time_slot)
        encodeService_index, _ := types.Encode(self_index)
        encodeSelectedTransfers, _ := types.Encode(selectedTransfers)

        input_argument = append(input_argument, encode_time_slot...)
        input_argument = append(input_argument, encodeService_index...)
        input_argument = append(input_argument, encodeSelectedTransfers...)

        vm.ExecuteTransfer(input_argument, self)

        return vm.ServiceAccount, nil</span>
}

// eq 12.24
func (s *StateDB) ProcessDeferredTransfers(delta_dager map[uint32]*types.ServiceAccount, time_slot uint32, t []types.DeferredTransfer) (map[uint32]*types.ServiceAccount, error) <span class="cov0" title="0">{
        delta_dager_dager := make(map[uint32]*types.ServiceAccount)
        for k, v := range delta_dager </span><span class="cov0" title="0">{
                delta_dager_dager[k] = v
        }</span>

        <span class="cov0" title="0">for i := range delta_dager </span><span class="cov0" title="0">{
                updated_service, err := s.HostTransfer(delta_dager, time_slot, uint32(i), t)
                if err != nil </span><span class="cov0" title="0">{
                        return delta_dager, fmt.Errorf("Service index:%d failed to process deferred transfers", i)
                }</span> else<span class="cov0" title="0"> {
                        delta_dager_dager[i] = updated_service
                }</span>

        }
        <span class="cov0" title="0">return delta_dager_dager, nil</span>
}

func (s *StateDB) ApplyStateTransitionAccumulation(w_star []types.WorkReport, num uint64, previousTimeslot uint32) <span class="cov0" title="0">{
        // fmt.Printf("ApplyStateTransitionAccumulation num=%d previousTimeslot=%d\n", num, previousTimeslot)
        jam := s.GetJamState()
        w_q := jam.QueuedExecution(s.AvailableWorkReport)
        jam.UpdateLatestHistory(w_star, int(num))
        jam.UpdateReadyQueuedReport(w_q, previousTimeslot)
}</span>

// eq 186, 187 0.4.5
func (j *JamState) UpdateLatestHistory(w_star []types.WorkReport, num int) <span class="cov0" title="0">{
        // get accumulated work report
        accumulated_wr := w_star[:num]
        // phasing every history
        // 187
        for i := 0; i &lt; types.EpochLength-1; i++ </span><span class="cov0" title="0">{
                tmp_history := j.AccumulationHistory[i+1]
                j.AccumulationHistory[i] = tmp_history
        }</span>
        // eq 186 0.4.5
        <span class="cov0" title="0">j.AccumulationHistory[types.EpochLength-1].WorkPackageHash = Mapping(accumulated_wr)</span>
        // if len(j.AccumulationHistory[types.EpochLength-1].WorkPackageHash) &gt; 0 {
        //         fmt.Printf("UpdateLatestHistory WorkPackageHash=%v\n", j.AccumulationHistory[types.EpochLength-1].WorkPackageHash)
        // }
}

func (j *JamState) UpdateReadyQueuedReport(w_q []types.AccumulationQueue, previous_t uint32) <span class="cov0" title="0">{
        timeslot := j.SafroleState.Timeslot
        _, phase := j.SafroleState.EpochAndPhase(timeslot)
        // fmt.Printf("UpdateReadyQueuedReport timeslot=%d phase=%d, previous= %d\n", timeslot, phase, previous_t)
        if previous_t == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for i := uint32(0); i &lt; types.EpochLength; i++ </span><span class="cov0" title="0">{
                // mod to get the correct index
                num := (int(phase) - int(i) + types.EpochLength) % types.EpochLength
                if i == 0 </span><span class="cov0" title="0">{
                        j.AccumulationQueue[num] = QueueEditing(w_q, j.AccumulationHistory[types.EpochLength-1].WorkPackageHash)
                }</span> else<span class="cov0" title="0"> if i &gt;= 1 &amp;&amp; i &lt; timeslot-previous_t </span><span class="cov0" title="0">{
                        j.AccumulationQueue[num] = []types.AccumulationQueue{}
                }</span> else<span class="cov0" title="0"> {
                        j.AccumulationQueue[num] = QueueEditing(j.AccumulationQueue[num], j.AccumulationHistory[types.EpochLength-1].WorkPackageHash)
                }</span>

        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package statedb

import (
        "errors"
        "fmt"
        "sort"

        "github.com/colorfulnotion/jam/jamerrors"
        "github.com/colorfulnotion/jam/types"
)

func (s *StateDB) VerifyAssurance(a types.Assurance) error <span class="cov8" title="1">{
        // 0.5.0 11.9 Verify the anchor
        if a.Anchor != s.ParentHeaderHash </span><span class="cov8" title="1">{
                if debugA </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] VerifyAssurance Fail  a.Anchor %v != s.ParentHeaderHash %v (ValidatorIndex %d)\n", s.Id, a.Anchor, s.ParentHeaderHash, a.ValidatorIndex)
                }</span>
                <span class="cov8" title="1">return jamerrors.ErrABadParentHash</span>
        }

        // 0.5.0 11.8
        <span class="cov8" title="1">if a.ValidatorIndex &gt;= types.TotalValidators </span><span class="cov0" title="0">{
                return jamerrors.ErrABadValidatorIndex
        }</span>
        <span class="cov8" title="1">var HasRhoState []bool
        for _, rho := range s.JamState.AvailabilityAssignments </span><span class="cov8" title="1">{
                if rho != nil </span><span class="cov8" title="1">{
                        HasRhoState = append(HasRhoState, true)
                }</span> else<span class="cov8" title="1"> {
                        HasRhoState = append(HasRhoState, false)
                }</span>
        }
        //0.5.0 11.8
        <span class="cov8" title="1">if !a.ValidBitfield(HasRhoState) </span><span class="cov8" title="1">{
                return jamerrors.ErrABadCore
        }</span>

        // 0.5.0 11.14
        <span class="cov8" title="1">var IsRhoTimeOut []bool
        for _, rho := range s.JamState.AvailabilityAssignments </span><span class="cov8" title="1">{
                if rho != nil </span><span class="cov8" title="1">{
                        ts := s.JamState.SafroleState.Timeslot
                        timeoutbool := ts &gt;= (rho.Timeslot)+uint32(types.UnavailableWorkReplacementPeriod)
                        if timeoutbool </span><span class="cov8" title="1">{
                                IsRhoTimeOut = append(IsRhoTimeOut, true)
                        }</span> else<span class="cov8" title="1"> {
                                IsRhoTimeOut = append(IsRhoTimeOut, false)
                        }</span>
                } else<span class="cov0" title="0"> {
                        IsRhoTimeOut = append(IsRhoTimeOut, false)
                }</span>
        }
        <span class="cov8" title="1">if !a.CheckTimeout(IsRhoTimeOut) </span><span class="cov8" title="1">{
                return jamerrors.ErrAStaleReport
        }</span>

        // 0.5.0 11.11 Verify the signature
        <span class="cov8" title="1">err := a.Verify(s.GetSafrole().CurrValidators[a.ValidatorIndex])
        if err != nil </span><span class="cov8" title="1">{
                return jamerrors.ErrABadSignature
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CheckDuplicate(assurances []types.Assurance, new types.Assurance) error <span class="cov0" title="0">{
        // Check for duplicate assurances
        seen := make(map[uint16]bool)
        for _, a := range assurances </span><span class="cov0" title="0">{
                if seen[a.ValidatorIndex] </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("duplicate assurance from validator %v", a.ValidatorIndex))
                }</span>
                <span class="cov0" title="0">seen[a.ValidatorIndex] = true</span>
        }
        <span class="cov0" title="0">if seen[new.ValidatorIndex] </span><span class="cov0" title="0">{
                return errors.New(fmt.Sprintf("duplicate assurance from validator %v", new.ValidatorIndex))
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// State transition function
func (j *JamState) CountAvailableWR(assurances []types.Assurance) []uint32 <span class="cov0" title="0">{
        // Count the number of available assurances for each validator
        tally := make([]uint32, types.TotalCores)
        for c := 0; c &lt; types.TotalCores; c++ </span><span class="cov0" title="0">{
                for _, a := range assurances </span><span class="cov0" title="0">{
                        if a.GetBitFieldBit(uint16(c)) </span><span class="cov0" title="0">{
                                tally[c]++
                        }</span>
                }
        }
        <span class="cov0" title="0">return tally</span>
}

func (j *JamState) ProcessAssuranceState(tally []uint32) (uint32, []types.WorkReport) <span class="cov0" title="0">{
        // Update the validator's assurance state
        numAssurances := uint32(0)
        BigW := make([]types.WorkReport, 0) // eq 129: BigW (available work report) is the work report that has been assured by more than 2/3 validators
        for c, available := range tally </span><span class="cov0" title="0">{
                if j.AvailabilityAssignments[c] == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if available &gt;= 2*types.TotalValidators/3 </span><span class="cov0" title="0">{
                        BigW = append(BigW, j.AvailabilityAssignments[c].WorkReport)
                        j.AvailabilityAssignments[c] = nil
                }</span>
                <span class="cov0" title="0">numAssurances++</span>
        }
        <span class="cov0" title="0">return numAssurances, BigW</span>
}

func (j *JamState) ProcessAssurances(assurances []types.Assurance) (uint32, []types.WorkReport) <span class="cov0" title="0">{
        // Count the number of available assurances for each validator
        tally := j.CountAvailableWR(assurances)
        // Update the validator's assurance state
        numAssurances, BigW := j.ProcessAssuranceState(tally)
        return numAssurances, BigW
}</span>

func SortAssurances(assurances []types.Assurance) <span class="cov0" title="0">{
        // Sort the assurances by validator index
        sort.Slice(assurances, func(i, j int) bool </span><span class="cov0" title="0">{
                return assurances[i].ValidatorIndex &lt; assurances[j].ValidatorIndex
        }</span>)
}

// This function is for the validator to check the assurances extrinsic when the block is received
// Strong Verification
func (s *StateDB) ValidateAssurances(assurances []types.Assurance) error <span class="cov8" title="1">{
        // Sort the assurances by validator index
        err := CheckSortingEAs(assurances)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // Verify each assurance
        <span class="cov8" title="1">for _, a := range assurances </span><span class="cov8" title="1">{
                if err := s.VerifyAssurance(a); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func CheckSortingEAs(assurances []types.Assurance) error <span class="cov8" title="1">{
        // Check the SortAssurances is correct
        for i := 0; i &lt; len(assurances)-1; i++ </span><span class="cov8" title="1">{
                if assurances[i].ValidatorIndex &gt;= types.TotalValidators </span><span class="cov8" title="1">{
                        return jamerrors.ErrABadValidatorIndex
                }</span>
                <span class="cov8" title="1">if assurances[i].ValidatorIndex &gt; assurances[i+1].ValidatorIndex </span><span class="cov8" title="1">{
                        return jamerrors.ErrANotSortedAssurers
                }</span>
                <span class="cov8" title="1">for j := i + 1; j &lt; len(assurances); j++ </span><span class="cov8" title="1">{
                        if assurances[i].ValidatorIndex == assurances[j].ValidatorIndex </span><span class="cov8" title="1">{
                                return jamerrors.ErrADuplicateAssurer
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// For generating assurance extrinsic
func (j *JamState) GetWorkReportFromRho() ([types.TotalCores]types.WorkReport, error) <span class="cov0" title="0">{
        reports := [types.TotalCores]types.WorkReport{}
        for i, rho := range j.AvailabilityAssignments </span><span class="cov0" title="0">{
                if rho == nil </span><span class="cov0" title="0">{
                        reports[i] = types.WorkReport{}
                }</span> else<span class="cov0" title="0"> {
                        reports[i] = rho.WorkReport
                }</span>
        }
        <span class="cov0" title="0">return reports, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">/*
we cannot assume consensus, we henceforth consider ourselves a specific validator
of index v and assume ourselves focused on some block B with other terms corresponding,
 so σ′ is said block’s posterior state, H is its header &amp;c.
 Practically, all considerations must be replicated for all blocks and multiple blocks’ considerations may be underway simultaneously.
*/

package statedb

import (
        "bytes"
        "errors"
        "fmt"
        "math/rand"
        "sort"
        "time"

        "github.com/colorfulnotion/jam/bandersnatch"
        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

// eq 191
func (s *StateDB) GetWorkReportNeedAudit() types.WorkReportNeedAudit <span class="cov0" title="0">{
        var w types.WorkReportNeedAudit
        for i, W := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                //if W in availableWorkReport , then add to w
                for _, bigW := range s.AvailableWorkReport </span><span class="cov0" title="0">{
                        if W.WorkReport.GetWorkPackageHash() == bigW.GetWorkPackageHash() </span><span class="cov0" title="0">{
                                w.Q[i] = bigW
                                fmt.Println("Add to w")
                        }</span> else<span class="cov0" title="0"> {
                                w.Q[i] = types.WorkReport{}
                        }</span>
                }

        }
        <span class="cov0" title="0">return w</span>
}

func (s *StateDB) GetWorkReportNeedAuditTiny() []types.WorkReport <span class="cov0" title="0">{
        var w []types.WorkReport
        for _, W := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                //if W in availableWorkReport , then add to w
                for _, bigW := range s.AvailableWorkReport </span><span class="cov0" title="0">{
                        if W.WorkReport.GetWorkPackageHash() == bigW.GetWorkPackageHash() </span><span class="cov0" title="0">{
                                w = append(w, bigW)
                        }</span>
                }

        }
        <span class="cov0" title="0">return w</span>
}

// eq 190
func (s *StateDB) Get_s0Quantity(V bandersnatch.BanderSnatchSecret) ([]byte, error) <span class="cov0" title="0">{
        if len(V) != 32 </span><span class="cov0" title="0">{
                return nil, errors.New("Invalid length of V")
        }</span>
        <span class="cov0" title="0">alias, err := AliasOutput(s.Block.Header.EntropySource.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">signtext := append([]byte(types.X_U), alias...)
        // TODO: Check the input of IetfVrfSign, the second parameter should be empty
        signature, _, err := bandersnatch.IetfVrfSign(V, []byte{0}, []byte(signtext))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return signature, nil</span>
}

func (s *StateDB) Verify_s0(pubkey bandersnatch.BanderSnatchKey) (bool, error) <span class="cov0" title="0">{
        if len(pubkey) != 32 </span><span class="cov0" title="0">{
                return false, errors.New("Invalid length of pubkey")
        }</span>
        <span class="cov0" title="0">alias, err := AliasOutput(s.Block.Header.EntropySource.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">signtext := append([]byte(types.X_U), alias...)
        _, err = bandersnatch.IetfVrfVerify(pubkey, []byte{0}, []byte(signtext), s.Block.Header.EntropySource.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// func 201 TODO check double plus means
func (s *StateDB) Get_snQuantity(V bandersnatch.BanderSnatchSecret, W types.WorkReport) ([]byte, error) <span class="cov0" title="0">{
        signcontext := append(append([]byte(types.X_U), W.Hash().Bytes()...), common.Uint32ToBytes(s.GetTranche())...)
        signature, _, err := bandersnatch.IetfVrfSign(V, []byte{0}, signcontext)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return signature, nil</span>
}

func (s *StateDB) Verify_sn(pubkey bandersnatch.BanderSnatchKey, W common.Hash, signature []byte) (bool, error) <span class="cov0" title="0">{
        signcontext := append(append([]byte(types.X_U), W.Bytes()...), common.Uint32ToBytes(s.GetTranche())...)
        _, err := bandersnatch.IetfVrfVerify(pubkey, []byte{0}, signcontext, signature)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

func WorkReportToSelection(W []types.WorkReport) []types.WorkReportSelection <span class="cov0" title="0">{
        selections := make([]types.WorkReportSelection, 0)
        for _, w := range W </span><span class="cov0" title="0">{
                selections = append(selections, types.WorkReportSelection{
                        WorkReport: w,
                        Core:       w.CoreIndex,
                })
        }</span>
        <span class="cov0" title="0">return selections</span>
}

// eq 192
func (s *StateDB) Select_a0(V bandersnatch.BanderSnatchSecret) ([]types.WorkReportSelection, bandersnatch.BandersnatchVrfSignature, error) <span class="cov0" title="0">{
        s0, err := s.Get_s0Quantity(V)
        if err != nil </span><span class="cov0" title="0">{
                return nil, bandersnatch.BandersnatchVrfSignature{}, err
        }</span>
        <span class="cov0" title="0">s0_alias, err := AliasOutput(s0)
        if err != nil </span><span class="cov0" title="0">{
                return nil, bandersnatch.BandersnatchVrfSignature{}, err
        }</span>
        <span class="cov0" title="0">tmp := WorkReportToSelection(s.AvailableWorkReport)

        entropy := NumericSequenceFromHash(common.BytesToHash(s0_alias), uint32(len(tmp)))
        ShuffleWorkReport(tmp, entropy)

        var a0 []types.WorkReportSelection
        count := 0
        for _, W := range tmp </span><span class="cov0" title="0">{
                //choose the first 10 without empty work report
                if bytes.Equal(W.WorkReport.Bytes(), []byte{}) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">a0 = append(a0, W)
                count++
                if count == 10 </span><span class="cov0" title="0">{
                        break</span>
                }

        }
        <span class="cov0" title="0">if len(s0) != 96 </span><span class="cov0" title="0">{
                return nil, bandersnatch.BandersnatchVrfSignature{}, errors.New("Invalid length of s0")
        }</span>
        <span class="cov0" title="0">var s0Signature bandersnatch.BandersnatchVrfSignature
        copy(s0Signature[:], s0)
        return a0, s0Signature, nil</span>
}

func (s *StateDB) GetAnnouncementWithoutJtrue(A types.AnnounceBucket, J types.JudgeBucket, W_hash common.Hash) ([]types.Announcement, int) <span class="cov0" title="0">{
        count := 0
        var announcements = make([]types.Announcement, 0)
        for _, a := range A.Announcements[W_hash] </span><span class="cov0" title="0">{
                var tmp types.Judgement
                for _, j := range J.Judgements[W_hash] </span><span class="cov0" title="0">{
                        tmp = j
                        if !j.Judge &amp;&amp; a.ValidatorIndex == uint32(j.Validator) </span><span class="cov0" title="0">{
                                count++
                                announcements = append(announcements, a)
                                break</span>
                        } else<span class="cov0" title="0"> if a.ValidatorIndex == uint32(j.Validator) </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
                // check the last one
                <span class="cov0" title="0">if a.ValidatorIndex != uint32(tmp.Validator) &amp;&amp; debugAudit </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] [T:%d] Validator %d didn't judge in Tranche %d\n", s.Id, s.Block.TimeSlot(), a.ValidatorIndex, a.Tranche)
                        count++
                        announcements = append(announcements, a)
                }</span>
        }
        <span class="cov0" title="0">return announcements, count</span>
}
func (s *StateDB) Select_an(V bandersnatch.BanderSnatchSecret, A_sub1 types.AnnounceBucket, J types.JudgeBucket) ([]types.WorkReportSelection, map[common.Hash][]types.Announcement, map[common.Hash]int, []bandersnatch.BandersnatchVrfSignature, error) <span class="cov0" title="0">{
        an := []types.WorkReportSelection{}
        availible_workreport := WorkReportToSelection(s.AvailableWorkReport)
        no_show_announcements := make(map[common.Hash][]types.Announcement)
        no_show_length := make(map[common.Hash]int)
        sns := make([]bandersnatch.BandersnatchVrfSignature, 0)
        for _, W := range availible_workreport </span><span class="cov0" title="0">{
                //get the number of true count
                sn, err := s.Get_snQuantity(V, W.WorkReport)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">sn_alias, err := AliasOutput(sn)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, nil, nil, err
                }</span>
                <span class="cov0" title="0">announcements, length := s.GetAnnouncementWithoutJtrue(A_sub1, J, W.WorkReport.Hash())
                if Bytes2Int(sn_alias)*types.AuditBiasFactor/256*types.TotalValidators &lt; length || true </span><span class="cov0" title="0">{
                        an = append(an, W)
                        // sn=&gt; bandersnatch.BandersnatchVrfSignature
                        var sig bandersnatch.BandersnatchVrfSignature
                        copy(sig[:], sn)
                        sns = append(sns, sig)
                        no_show_announcements[W.WorkReport.Hash()] = announcements
                        no_show_length[W.WorkReport.Hash()] = length
                }</span>
        }
        <span class="cov0" title="0">return an, no_show_announcements, no_show_length, sns, nil</span>
}

// func (s *StateDB) SelectionToAnnouncement(an []types.WorkReportSelection) []types.Announcement

func Bytes2Int(b []byte) int <span class="cov0" title="0">{
        var x int
        for i := 0; i &lt; len(b); i++ </span><span class="cov0" title="0">{
                x = x &lt;&lt; 8
                x = x | int(b[i])
        }</span>
        <span class="cov0" title="0">return x</span>
}

// for eq 194
func AliasOutput(x []byte) ([]byte, error) <span class="cov0" title="0">{
        //check length &gt; 32
        if len(x) &lt; 32 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid length")
        }</span>
        <span class="cov0" title="0">return x[:32], nil</span>
}

// for eq 193
func ShuffleWorkReport(slice []types.WorkReportSelection, entropy []uint32) <span class="cov0" title="0">{
        n := len(slice)
        for i := n - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                j := entropy[i] % uint32(i+1)
                slice[i], slice[j] = slice[j], slice[i]
        }</span>
        <span class="cov0" title="0">return</span>
}

// eq 195
func (s *StateDB) GetTranche() uint32 <span class="cov0" title="0">{
        // timeslot mark
        currentTime := time.Now().Unix()
        JCE := uint32(common.ComputeJCETime(currentTime, true))
        // currentJCETime := common.ComputeCurrentJCETime() // Replace with the actual value or variable representing the current JCE time
        timeslot := s.Block.TimeSlot()
        if s.Block == nil </span><span class="cov0" title="0">{
                fmt.Printf("Block is nil\n")
        }</span>
        <span class="cov0" title="0">return (JCE - types.SecondsPerSlot*timeslot) / types.PeriodSecond</span>
        // return 0
}

// eq 196
func (s *StateDB) MakeAnnouncement(tranche uint32, workreport []types.WorkReportSelection, Ed25519Secret []byte, validatoridx uint32) (types.Announcement, error) <span class="cov0" title="0">{
        var annReports []types.AnnouncementReport
        for _, w := range workreport </span><span class="cov0" title="0">{
                annReports = append(annReports, types.AnnouncementReport{
                        Core:           w.Core,
                        WorkReportHash: w.WorkReport.Hash(),
                })
        }</span>

        <span class="cov0" title="0">announcement := types.Announcement{
                HeaderHash:          s.GetHeaderHash(),
                Tranche:             tranche,
                Selected_WorkReport: annReports,
                ValidatorIndex:      validatoridx,
        }
        announcement.Sign(Ed25519Secret)
        return announcement, nil</span>
}

// eq 203

func (s *StateDB) ValidateWorkReport(wp types.WorkPackage) bool <span class="cov0" title="0">{
        // Simulate a 10% chance of returning false
        if rand.Intn(10) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        // TODO: Implement the actual validation logic
        <span class="cov0" title="0">return true</span>
}

// eq 205
func (a *StateDB) IsReportAudited(A types.AnnounceBucket, J types.JudgeBucket, W_hash common.Hash) bool <span class="cov0" title="0">{
        _, length := a.GetAnnouncementWithoutJtrue(A, J, W_hash)
        if length == 0 </span><span class="cov0" title="0">{
                //double check no invalid
                for _, j := range J.Judgements[W_hash] </span><span class="cov0" title="0">{
                        if !j.Judge </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov0" title="0">return true</span>
        } else<span class="cov0" title="0"> if J.GetTrueCount(W_hash) &gt;= types.ValidatorsSuperMajority </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (s *StateDB) IsReportAuditedTiny(A types.AnnounceBucket, J types.JudgeBucket, W_hash common.Hash) error <span class="cov0" title="0">{
        _, length := s.GetAnnouncementWithoutJtrue(A, J, W_hash)
        if length == 0 </span><span class="cov0" title="0">{
                //double check no invalid
                for _, j := range J.Judgements[W_hash] </span><span class="cov0" title="0">{
                        if j.Judge != true </span><span class="cov0" title="0">{
                                return fmt.Errorf("Validator[%d] said false /n", j.Validator)
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if J.GetTrueCount(W_hash) &gt;= types.ValidatorsSuperMajority </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return fmt.Errorf("Audit not yet finished")</span>

}

// 206 big U
func (s *StateDB) IsBlockAudited(A types.AnnounceBucket, J types.JudgeBucket) bool <span class="cov0" title="0">{

        for _, av := range s.AvailableWorkReport </span><span class="cov0" title="0">{
                if s.IsReportAudited(A, J, av.Hash()) </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (s *StateDB) IsBlockAuditedTiny(A types.AnnounceBucket, J types.JudgeBucket) error <span class="cov0" title="0">{
        for _, av := range s.AvailableWorkReport </span><span class="cov0" title="0">{
                if s.IsReportAuditedTiny(A, J, av.GetWorkPackageHash()) == nil </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        return fmt.Errorf("WorkReport:%v didn't finish audit\n", av.GetWorkPackageHash())
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func JudgementToVote(J []types.Judgement) []types.Vote <span class="cov0" title="0">{
        votes := make([]types.Vote, 0)
        for _, j := range J </span><span class="cov0" title="0">{
                votes = append(votes, types.Vote{
                        Voting:    j.Judge,
                        Index:     j.Validator,
                        Signature: j.Signature,
                })
        }</span>
        //sort by Index
        <span class="cov0" title="0">sort.Slice(votes, func(i, j int) bool </span><span class="cov0" title="0">{
                return votes[i].Index &lt; votes[j].Index
        }</span>)
        <span class="cov0" title="0">return votes</span>
}

func (s *StateDB) JudgementToFault(J []types.Judgement, W_hash common.Hash) []types.Fault <span class="cov0" title="0">{
        faults := make([]types.Fault, 0)
        for _, j := range J </span><span class="cov0" title="0">{
                if j.Judge </span><span class="cov0" title="0">{
                        continue</span>
                } else<span class="cov0" title="0"> {
                        faults = append(faults, types.Fault{
                                Target:    W_hash,
                                Voting:    j.Judge,
                                Key:       s.GetSafrole().CurrValidators[int(j.Validator)].Ed25519,
                                Signature: j.Signature,
                        })
                }</span>
        }
        //sort by key
        <span class="cov0" title="0">sort.Slice(faults, func(i, j int) bool </span><span class="cov0" title="0">{
                return bytes.Compare(faults[i].Key[:], faults[j].Key[:]) &lt; 0
        }</span>)
        <span class="cov0" title="0">return faults</span>
}

func (s *StateDB) JudgementToCulprit(old_guarantee types.Guarantee) []types.Culprit <span class="cov0" title="0">{
        //Stub: need culprit from judgment here.
        culprits := make([]types.Culprit, 0)
        for _, cred := range old_guarantee.Signatures </span><span class="cov0" title="0">{
                key := s.GetSafrole().GetCurrValidator(int(cred.ValidatorIndex)).Ed25519
                culprits = append(culprits, types.Culprit{
                        Target:    old_guarantee.Report.Hash(),
                        Key:       key,
                        Signature: cred.Signature,
                })
        }</span>
        <span class="cov0" title="0">return culprits</span>
}

// TODO: here is the stub code to lookup the EG
func (s *StateDB) GetCulprits(ts uint32, report types.WorkReport) []types.Culprit <span class="cov0" title="0">{
        culprits := make([]types.Culprit, 0)
        // for _, G := range s.GuarantorAssignments {
        //         if G.CoreIndex == report.CoreIndex {
        //                 culprits = append(culprits, types.Culprit{
        //                         Target:    report.GetWorkPackageHash(),
        //                         Key:       G.Validator.Ed25519,
        //                         Signature: types.Ed25519Sign(G.Validator., []byte("Something")),
        //                 })
        //         }
        // }
        return culprits
}</span>

// issue dispute extrinsic
func (s *StateDB) AppendDisputes(J *types.JudgeBucket, W_hash common.Hash, old_guarantee types.Guarantee) error <span class="cov0" title="0">{
        true_count := J.GetTrueCount(W_hash)
        false_count := J.GetFalseCount(W_hash)

        if true_count+false_count &lt; types.ValidatorsSuperMajority </span><span class="cov0" title="0">{
                return fmt.Errorf("Not enough votes: true_count=%d, false_count=%d", true_count, false_count)
        }</span>

        <span class="cov0" title="0">if true_count &gt;= types.ValidatorsSuperMajority </span><span class="cov0" title="0">{
                if false_count == 0 </span><span class="cov0" title="0">{
                        return errors.New("Not Required")
                }</span>
                <span class="cov0" title="0">s.appendGoodSetDispute(J, W_hash)
                return nil</span>
        } else<span class="cov0" title="0"> if false_count &gt;= types.ValidatorsSuperMajority </span><span class="cov0" title="0">{
                s.appendBadSetDispute(J, W_hash, old_guarantee)
                return nil
        }</span> else<span class="cov0" title="0"> if true_count &gt;= types.WonkyTrueThreshold &amp;&amp; false_count &gt;= types.WonkyFalseThreshold </span><span class="cov0" title="0">{
                s.appendWonkySetDispute(J, W_hash)
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("No need to dispute")</span>
}

func (s *StateDB) appendGoodSetDispute(J *types.JudgeBucket, W_hash common.Hash) <span class="cov0" title="0">{
        true_votes := JudgementToVote(J.GetTrueJudgement(W_hash))
        faults := s.JudgementToFault(J.GetFalseJudgement(W_hash), W_hash)
        goodset_verdict := types.Verdict{
                Target: W_hash,
                Epoch:  s.GetSafrole().GetEpoch(),
        }

        for i, true_vote := range true_votes </span><span class="cov0" title="0">{
                goodset_verdict.Votes[i] = true_vote
        }</span>

        <span class="cov0" title="0">s.Block.Extrinsic.Disputes.Verdict = append(s.Block.Extrinsic.Disputes.Verdict, goodset_verdict)
        s.Block.Extrinsic.Disputes.Fault = append(s.Block.Extrinsic.Disputes.Fault, faults...)</span>
}

func (s *StateDB) appendBadSetDispute(J *types.JudgeBucket, W_hash common.Hash, old_guarantee types.Guarantee) <span class="cov0" title="0">{
        false_votes := JudgementToVote(J.GetFalseJudgement(W_hash))
        badset_verdict := types.Verdict{
                Target: W_hash,
                Epoch:  s.GetSafrole().GetEpoch(),
        }

        for i, false_vote := range false_votes </span><span class="cov0" title="0">{
                badset_verdict.Votes[i] = false_vote
        }</span>

        <span class="cov0" title="0">s.Block.Extrinsic.Disputes.Verdict = append(s.Block.Extrinsic.Disputes.Verdict, badset_verdict)
        culprits := s.JudgementToCulprit(old_guarantee)
        s.Block.Extrinsic.Disputes.Culprit = culprits</span>
}

func (s *StateDB) appendWonkySetDispute(J *types.JudgeBucket, W_hash common.Hash) <span class="cov0" title="0">{
        wonky_votes := JudgementToVote(J.GetWonkeyJudgement(W_hash))
        wonky_verdict := types.Verdict{
                Target: W_hash,
                Epoch:  s.GetSafrole().GetEpoch(),
        }

        true_c, false_c := 0, 0
        for i, wonky_vote := range wonky_votes </span><span class="cov0" title="0">{
                if wonky_vote.Voting </span><span class="cov0" title="0">{
                        if true_c &gt;= types.WonkyTrueThreshold </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">true_c++</span>
                } else<span class="cov0" title="0"> {
                        if false_c &gt;= types.WonkyFalseThreshold </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">false_c++</span>
                }
                <span class="cov0" title="0">wonky_verdict.Votes[i] = wonky_vote</span>
        }

        <span class="cov0" title="0">s.Block.Extrinsic.Disputes.Verdict = append(s.Block.Extrinsic.Disputes.Verdict, wonky_verdict)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package statedb

import "github.com/colorfulnotion/jam/types"

// Section 8.2 - Eq 85+86
/*
   func (s *StateDB) ApplyStateTransitionAuthorizations(guarantees []types.Guarantee) error {
        for c := uint16(0); c &lt; types.TotalCores; c++ {
                if len(guarantees) &gt; 0 {
                        // build m, holding the set of authorization hashes matching the core c in guarantees
                        m := make(map[common.Hash]bool)
                        hits := 0
                        for _, g := range guarantees {
                                if g.Report.CoreIndex == c {
                                        m[g.Report.AuthorizerHash] = true
                                        hits++
                                }
                        }
                        // only use m to update the pool with remove_guarantees_authhash if we have hits &gt; 0
                        if hits &gt; 0 {
                                s.JamState.AuthorizationsPool[c] = s.remove_guarantees_authhash(s.JamState.AuthorizationsPool[c], m)
                        }
                }
                // Eq 85 -- add
                for _, q := range s.JamState.AuthorizationQueue[c] {
                        s.JamState.AuthorizationsPool[c] = append(s.JamState.AuthorizationsPool[c], q)
                }
                // cap AuthorizationsPool length at O=types.MaxAuthorizationPoolItems
                if len(s.JamState.AuthorizationsPool[c]) &gt; types.MaxAuthorizationPoolItems {
                        s.JamState.AuthorizationsPool[c] = s.JamState.AuthorizationsPool[c][:types.MaxAuthorizationPoolItems]
                }
        }
        return nil
}
*/

func (s *StateDB) ApplyStateTransitionAuthorizations() error <span class="cov0" title="0">{
        // gp 0.5.0 eq 8.3 -- we do F function first to eliminate old authorizations
        s.RemoveOldAuthorizationFromReport()
        // gp 0.5.0 eq 8.2
        s.AddNewPoolFromQueue()
        return nil
}</span>

// gp 0.5.0 eq 8.2
func (s *StateDB) AddNewPoolFromQueue() <span class="cov0" title="0">{
        jam_state := s.GetJamState()
        time_slot := s.Block.TimeSlot()
        mod_time_slot := time_slot % types.MaxAuthorizationQueueItems
        for core_idx, pool := range jam_state.AuthorizationsPool </span><span class="cov0" title="0">{
                ready_queue := jam_state.AuthorizationQueue[core_idx][mod_time_slot]
                pool = append(pool, ready_queue)
                if len(pool) &gt; types.MaxAuthorizationPoolItems </span><span class="cov0" title="0">{
                        // if the pool is full, remove the oldest item
                        head := len(pool) - types.MaxAuthorizationPoolItems
                        pool = pool[head:]
                }</span>
                <span class="cov0" title="0">jam_state.AuthorizationsPool[core_idx] = pool</span>
        }
}

// gp 0.5.0 eq 8.3
func (s *StateDB) RemoveOldAuthorizationFromReport() <span class="cov0" title="0">{
        jam_state := s.GetJamState()
        for _, eg := range s.Block.Extrinsic.Guarantees </span><span class="cov0" title="0">{
                core_index := eg.Report.CoreIndex
                for i, pool := range jam_state.AuthorizationsPool[core_index] </span><span class="cov0" title="0">{
                        // remove the authorization from the pool if it is the same as the authorizer hash from the report
                        if pool == eg.Report.AuthorizerHash </span><span class="cov0" title="0">{
                                jam_state.AuthorizationsPool[core_index] = append(jam_state.AuthorizationsPool[core_index][:i], jam_state.AuthorizationsPool[core_index][i+1:]...)
                                break</span>
                        }
                }
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package statedb

import (
        "fmt"
        "log"
        "net/http"

        "github.com/go-echarts/go-echarts/v2/charts"
        "github.com/go-echarts/go-echarts/v2/components"
        "github.com/go-echarts/go-echarts/v2/opts"
        "github.com/go-echarts/go-echarts/v2/types"
)

type Block_draw struct {
        Hash      string
        Parent    string
        AuthorIdx int
        Timeslot  string
}

var (
        drawblocks = make(map[string]*Block_draw)
        edges      []opts.GraphLink
        graph      *charts.Graph
)

func AddDrawBlock(blockHash, parentHash string, authorIdx int, timeslot string) <span class="cov0" title="0">{
        if _, exists := drawblocks[blockHash]; !exists </span><span class="cov0" title="0">{
                drawblocks[blockHash] = &amp;Block_draw{
                        Hash:      blockHash,
                        Parent:    parentHash,
                        AuthorIdx: authorIdx,
                        Timeslot:  timeslot,
                }
                edges = append(edges, opts.GraphLink{Source: parentHash, Target: blockHash})
        }</span>

        <span class="cov0" title="0">if parentHash != "" &amp;&amp; !existsInDrawBlocks(parentHash) </span><span class="cov0" title="0">{
                drawblocks[parentHash] = &amp;Block_draw{Hash: parentHash}
        }</span>
}

func existsInDrawBlocks(hash string) bool <span class="cov0" title="0">{
        _, exists := drawblocks[hash]
        return exists
}</span>

func setupGraph() *charts.Graph <span class="cov0" title="0">{
        graph := charts.NewGraph()
        graph.SetGlobalOptions(
                charts.WithTitleOpts(opts.Title{
                        Title:    "Blockchain Fork Visualization",
                        Subtitle: "Dynamic representation of block forks",
                }),
                charts.WithTooltipOpts(opts.Tooltip{Show: opts.Bool(true)}),
        )

        nodes, links := getGraphData()
        graph.AddSeries("Blockchain", nodes, links).SetSeriesOptions(
                charts.WithGraphChartOpts(opts.GraphChart{
                        Force:  &amp;opts.GraphForce{Repulsion: 1000, Gravity: 0.3},
                        Layout: "force",
                        Roam:   opts.Bool(true),
                }),
                charts.WithLabelOpts(opts.Label{Show: opts.Bool(true), Position: "right", Formatter: "{b}"}),
        )
        return graph
}</span>

func getGraphData() ([]opts.GraphNode, []opts.GraphLink) <span class="cov0" title="0">{
        nodes := make([]opts.GraphNode, 0, len(drawblocks))
        links := make([]opts.GraphLink, 0, len(edges))

        for _, block := range drawblocks </span><span class="cov0" title="0">{
                nodes = append(nodes, opts.GraphNode{
                        Name: block.Hash,
                        Tooltip: &amp;opts.Tooltip{
                                Show:      opts.Bool(true),
                                Formatter: types.FuncStr(fmt.Sprintf("Block: %s,Author: %d,Timeslot: %s", block.Hash, block.AuthorIdx, block.Timeslot)),
                        },
                })
        }</span>
        <span class="cov0" title="0">for _, edge := range edges </span><span class="cov0" title="0">{
                links = append(links, opts.GraphLink{
                        Source: edge.Source,
                        Target: edge.Target,
                })
        }</span>
        <span class="cov0" title="0">return nodes, links</span>
}

func RunGraph() <span class="cov0" title="0">{
        http.HandleFunc("/", func(rw http.ResponseWriter, req *http.Request) </span><span class="cov0" title="0">{
                graph := setupGraph()
                page := components.NewPage()
                page.AddCharts(graph)
                page.Render(rw)
        }</span>)

        <span class="cov0" title="0">log.Println("Starting server at :3030")
        if err := http.ListenAndServe(":3030", nil); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package statedb

import (
        "bytes"
        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/jamerrors"
        "github.com/colorfulnotion/jam/types"
)

const CoreNum = types.TotalCores
const ValidatorNum = types.TotalValidators
const E = types.EpochLength

// full
// const CoreNum = 341
// const ValidatorNum = 1023
// const E = 600

// ==========Output=======
type DOutput struct {
        Ok *struct {
                OffenderMark []types.Ed25519Key `json:"offenders_mark"` // SEQUENCE OF Ed25519Key (ByteArray32 in disputes.asn)
        } `json:"ok,omitempty"`
        Err *string `json:"err,omitempty" ` // ErrorCode
}

/*
ErrDNotSortedWorkReports        No - Shawn to review        Not sorted work reports within a verdict
ErrDNotUniqueVotes        No - Shawn to review        Not unique votes within a verdict
ErrDNotSortedValidVerdicts        Yes        Not sorted, valid verdicts
ErrDNotHomogenousJudgements        No - Shawn to review        Not homogeneous judgements, but positive votes count is not correct
ErrDMissingCulpritsBadVerdict        No - Shawn to review        Missing culprits for bad verdict
ErrDSingleCulpritBadVerdict        No - Shawn to review        Single culprit for bad verdict
ErrDTwoCulpritsBadVerdictNotSorted        Yes        Two culprits for bad verdict, not sorted
ErrDAlreadyRecordedVerdict        No - Shawn to review        Report an already recorded verdict, with culprits
ErrDCulpritAlreadyInOffenders        No - Shawn to review        Culprit offender already in the offenders list
ErrDOffenderNotPresentVerdict        No - Shawn to review        Offender relative to a not present verdict
ErrDMissingFaultsGoodVerdict        No - Shawn to review        Missing faults for good verdict
ErrDTwoFaultOffendersGoodVerdict        No - Shawn to review        Two fault offenders for a good verdict, not sorted
ErrDAlreadyRecordedVerdictWithFaults        No - Shawn to review        Report an already recorded verdict, with faults
ErrDFaultOffenderInOffendersList        No - Shawn to review        Fault offender already in the offenders list
ErrDAuditorMarkedOffender        No - Shawn to review        Auditor marked as offender, but vote matches the verdict.
ErrDBadSignatureInVerdict        Yes        Bad signature within the verdict judgements
ErrDBadSignatureInCulprits        Yes        Bad signature within the culprits sequence
ErrDAgeTooOldInVerdicts        No - Shawn to review        Age too old for verdicts judgements
*/
type VerdictResult struct {
        WorkReportHash common.Hash
        PositveCount   int
}

func (j *JamState) IsValidateDispute(input *types.Dispute) ([]VerdictResult, error) <span class="cov8" title="1">{
        // gp 0.5.0 (10.3)
        for _, v := range input.Verdict </span><span class="cov8" title="1">{
                err := j.checkSignature(v)
                if err != nil </span><span class="cov8" title="1">{
                        return []VerdictResult{}, err
                }</span>
        }
        //gp 0.5.0 (10.7) v: v should index by the work report hash and no duplicates
        <span class="cov8" title="1">err := checkVerdicts(input.Verdict)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        //gp 0.5.0 (10.8) c: should be index by key and no duplicates
        <span class="cov8" title="1">err = checkCulprit(input.Culprit)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        //gp 0.5.0 (10.8) f: should be index by key and no duplicates
        <span class="cov8" title="1">err = checkFault(input.Fault)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        // gp 0.5.0 (10.5)
        <span class="cov8" title="1">for _, c := range input.Culprit </span><span class="cov8" title="1">{
                err := j.checkIfKeyOffend(c.Key)
                if err != nil &amp;&amp; err.Error() == "Already in the Offenders" </span><span class="cov8" title="1">{
                        return []VerdictResult{}, jamerrors.ErrDCulpritAlreadyInOffenders
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return []VerdictResult{}, err
                }</span>
        }
        // gp 0.5.0 (10.6)
        <span class="cov8" title="1">for _, f := range input.Fault </span><span class="cov8" title="1">{
                err := j.checkIfKeyOffend(f.Key)
                if err != nil &amp;&amp; err.Error() == "Already in the Offenders" </span><span class="cov8" title="1">{
                        return []VerdictResult{}, jamerrors.ErrDFaultOffenderInOffendersList
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return []VerdictResult{}, err
                }</span>
        }
        //gp 0.5.0 (10.9) v: work report hash should not be in the psi_g, psi_b, psi_w set
        <span class="cov8" title="1">err = checkWorkReportHash(input.Verdict, j.DisputesState.Psi_g, j.DisputesState.Psi_b, j.DisputesState.Psi_w)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        //gp 0.5.0 (10.10) v: the vote should be index by validator index and no duplicates
        <span class="cov8" title="1">err = checkVote(input.Verdict)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        //process the dispute
        //gp 0.5.0 (10.11, 12) r,v (r=&gt; report, v=&gt; sum of votes)
        /* only have 3 cases
        zero =&gt; bad
        1/3 =&gt; wonky
        2/3+1 =&gt; good
        */
        <span class="cov8" title="1">result := verdict2result(input.Verdict)
        //gp 0.5.0 (10.11, 12) r,v (r=&gt; report, v=&gt; sum of votes)
        state_prime := j.sortSet_Prime(result)
        //gp 0.5.0 (10.13)if the Verdict is good, always have a least one fault
        err = isFaultEnoughAndValid(state_prime, input.Fault)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        //gp 0.5.0 (10.14) eq 110 if the Verdict is bad, always have at least two culprit
        <span class="cov8" title="1">err = isCulpritEnoughAndValid(state_prime, input.Culprit)
        if err != nil </span><span class="cov8" title="1">{
                return []VerdictResult{}, err
        }</span>
        <span class="cov8" title="1">return result, nil</span>
}
func (j *JamState) NeedsOffendersMarker(d *types.Dispute) bool <span class="cov0" title="0">{
        if len(d.Culprit) == 0 &amp;&amp; len(d.Fault) == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// func (j *JamState) GetPsiBytes() ([]byte, error) {
//         // use scale to encode the Psi_state
//         //use json marshal to get the bytes
//         scale_bytes, err := json.Marshal(j.DisputesState)
//         if err != nil {
//                 return nil, err
//         }
//         return scale_bytes, nil

// }

func (j *JamState) GetOffenderMark(input types.Dispute) (types.OffenderMarker, error) <span class="cov0" title="0">{
        for _, v := range input.Verdict </span><span class="cov0" title="0">{
                err := j.checkSignature(v)
                if err != nil </span><span class="cov0" title="0">{
                        return types.OffenderMarker{}, err
                }</span>
        }

        <span class="cov0" title="0">for _, c := range input.Culprit </span><span class="cov0" title="0">{
                err := j.checkIfKeyOffend(c.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return types.OffenderMarker{}, err
                }</span>
        }
        //eq 102 f: the key shouldn't be in old offenders set
        <span class="cov0" title="0">for _, f := range input.Fault </span><span class="cov0" title="0">{
                err := j.checkIfKeyOffend(f.Key)
                if err != nil </span><span class="cov0" title="0">{
                        return types.OffenderMarker{}, err
                }</span>
        }
        //eq 103 v: v should index by the work report hash and no duplicates
        <span class="cov0" title="0">err := checkVerdicts(input.Verdict)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //eq 104 c: should be index by key and no duplicates
        <span class="cov0" title="0">err = checkCulprit(input.Culprit)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //eq 104 f: should be index by key and no duplicates
        <span class="cov0" title="0">err = checkFault(input.Fault)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //eq 105 v: work report hash should not be in the psi_g, psi_b, psi_w set
        <span class="cov0" title="0">err = checkWorkReportHash(input.Verdict, j.DisputesState.Psi_g, j.DisputesState.Psi_b, j.DisputesState.Psi_w)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //eq 106 v: the vote should be index by validator index and no duplicates
        <span class="cov0" title="0">err = checkVote(input.Verdict)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //process the dispute
        //eq 107, 108 r,v (r=&gt; report, v=&gt; sum of votes)
        /* only have 3 cases
        zero =&gt; bad
        1/3 =&gt; wonky
        2/3+1 =&gt; good
        */
        <span class="cov0" title="0">result := verdict2result(input.Verdict)
        //eq 107, 108 r,v (r=&gt; report, v=&gt; sum of votes)
        state_prime := j.sortSet_Prime(result)
        //eq 109 if the Verdict is good, always have a least one fault
        err = isFaultEnoughAndValid(state_prime, input.Fault)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //eq 110 if the Verdict is bad, always have at least two culprit
        <span class="cov0" title="0">err = isCulpritEnoughAndValid(state_prime, input.Culprit)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        <span class="cov0" title="0">o_out := processTypesOutput(result, input.Culprit, input.Fault)
        return o_out, nil</span>
}

func (j *JamState) ProcessDispute(result []VerdictResult, c []types.Culprit, f []types.Fault) <span class="cov0" title="0">{
        j.sortSet(result)
        //eq 10.15 start: clear old report in rho ,report and timeout
        j.updateOffender(c, f)
        j.clearReportRho(result)
}</span>

func (j *JamState) Disputes(input *types.Dispute) (types.OffenderMarker, error) <span class="cov0" title="0">{
        // Implement the function logic here
        // check the all input data are valid ,eq 98~106
        //eq 99 check the signature of the verdicts
        //eq 101 c: the key shouldn't be in old offenders set
        if !j.NeedsOffendersMarker(input) </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, nil
        }</span>

        <span class="cov0" title="0">o_out, err := j.GetOffenderMark(*input)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        <span class="cov0" title="0">result, err := j.IsValidateDispute(input)
        if err != nil </span><span class="cov0" title="0">{
                return types.OffenderMarker{}, err
        }</span>
        //state changing here
        <span class="cov0" title="0">j.ProcessDispute(result, input.Culprit, input.Fault)
        return o_out, nil</span>
}

// eq 99
// gp 0.5.0 (10.4)
func getPublicKey(K []types.Validator, Index uint32) types.Ed25519Key <span class="cov0" title="0">{
        return K[Index].Ed25519
}</span>

func (j *JamState) checkSignature(v types.Verdict) error <span class="cov8" title="1">{
        // check the signature
        if v.Epoch == j.SafroleState.Timeslot/E </span><span class="cov8" title="1">{
                // check the signature
                err := v.Verify(j.SafroleState.CurrValidators)
                if err != nil </span><span class="cov8" title="1">{
                        return jamerrors.ErrDBadSignatureInVerdict
                }</span>
        } else<span class="cov8" title="1"> if v.Epoch == j.SafroleState.Timeslot/E-1 </span><span class="cov8" title="1">{
                err := v.Verify(j.SafroleState.PrevValidators)
                if err != nil </span><span class="cov0" title="0">{
                        return jamerrors.ErrDBadSignatureInVerdict
                }</span>
        } else<span class="cov8" title="1"> {
                if debugAudit </span><span class="cov0" title="0">{
                        fmt.Printf("Verdict Error: the epoch of the verdict %v is invalid, current epoch %v\n", v.Epoch, j.SafroleState.Timeslot/E)
                }</span>
                <span class="cov8" title="1">return jamerrors.ErrDAgeTooOldInVerdicts</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// eq 101
// gp 0.5.0 (10.6)
func (j *JamState) checkIfKeyOffend(key types.Ed25519Key) error <span class="cov8" title="1">{
        for _, k := range j.DisputesState.Psi_o </span><span class="cov8" title="1">{
                if bytes.Equal(k.Bytes(), key.Bytes()) </span><span class="cov8" title="1">{
                        //drop the key
                        return fmt.Errorf("Already in the Offenders")
                }</span>
        }
        // check if the key is in the validator set
        <span class="cov8" title="1">for _, k := range j.SafroleState.CurrValidators </span><span class="cov8" title="1">{
                if bytes.Equal(k.Ed25519.Bytes(), key.Bytes()) </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">for _, k := range j.SafroleState.PrevValidators </span><span class="cov0" title="0">{
                if bytes.Equal(k.Ed25519.Bytes(), key.Bytes()) </span><span class="cov0" title="0">{
                        return nil
                }</span>
        }
        <span class="cov0" title="0">return fmt.Errorf("Already in the Offenders")</span>
}

// eq 103 v: v should index by the work report hash and no duplicates
// gp 0.5.0 (10.7)
func checkVerdicts(v []types.Verdict) error <span class="cov8" title="1">{

        for i, verdict := range v </span><span class="cov8" title="1">{
                // check duplicate
                for j, veverdict2 := range v </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if bytes.Equal(veverdict2.Target.Bytes(), verdict.Target.Bytes()) </span><span class="cov0" title="0">{
                                return jamerrors.ErrDNotSortedWorkReports
                        }</span>
                }
                // check index
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if bytes.Compare(v[i].Target.Bytes(), v[i-1].Target.Bytes()) &lt; 0 </span><span class="cov8" title="1">{
                        return jamerrors.ErrDNotSortedValidVerdicts
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// eq 104 c: should be index by key and no duplicates
// gp 0.5.0 (10.8)
func checkCulprit(c []types.Culprit) error <span class="cov8" title="1">{
        for i, culprit := range c </span><span class="cov8" title="1">{
                //check culprit signature is valid
                //verify the signature
                if !culprit.Verify() </span><span class="cov8" title="1">{
                        return jamerrors.ErrDBadSignatureInCulprits
                }</span>
                // check duplicate
                <span class="cov8" title="1">for j, c2 := range c </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if bytes.Equal(c2.Key[:], culprit.Key[:]) </span><span class="cov0" title="0">{
                                return jamerrors.ErrDTwoCulpritsBadVerdictNotSorted
                        }</span>
                }
                // check index
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if bytes.Compare(c[i].Key[:], c[i-1].Key[:]) &lt; 0 </span><span class="cov8" title="1">{
                        return jamerrors.ErrDTwoCulpritsBadVerdictNotSorted

                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// eq 104 f: should be index by key and no duplicates
// gp 0.5.0 (10.8)
func checkFault(f []types.Fault) error <span class="cov8" title="1">{
        for i, fault := range f </span><span class="cov8" title="1">{
                //check fault signature is valid
                // jam_guarantee concat the work report hash
                //verify the signature
                if !fault.Verify() </span><span class="cov0" title="0">{
                        return jamerrors.ErrDBadSignatureInVerdict
                }</span>
                // check duplicate
                <span class="cov8" title="1">for j, f2 := range f </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if bytes.Equal(f2.Key[:], fault.Key[:]) </span><span class="cov0" title="0">{
                                return jamerrors.ErrDTwoFaultOffendersGoodVerdict
                        }</span>
                }
                // check index
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if bytes.Compare(f[i].Key[:], f[i-1].Key[:]) &lt; 0 </span><span class="cov8" title="1">{
                        return jamerrors.ErrDTwoFaultOffendersGoodVerdict
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// eq 105 v: work report hash should not be in the psi_g, psi_b, psi_w set
// gp 0.5.0 (10.9)
func checkWorkReportHash(v []types.Verdict, psi_g [][]byte, psi_b [][]byte, psi_w [][]byte) error <span class="cov8" title="1">{
        for _, verdict := range v </span><span class="cov8" title="1">{
                if checkWorkReportHashInSet(verdict.Target.Bytes(), psi_g) </span><span class="cov0" title="0">{
                        return jamerrors.ErrDAlreadyRecordedVerdict
                }</span>
                <span class="cov8" title="1">if checkWorkReportHashInSet(verdict.Target.Bytes(), psi_b) </span><span class="cov8" title="1">{
                        if debugAudit </span><span class="cov0" title="0">{
                                fmt.Printf("Verdict Error: WorkReportHash %x already in psi_b\n", verdict.Target)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDAlreadyRecordedVerdict</span>
                }
                <span class="cov8" title="1">if checkWorkReportHashInSet(verdict.Target.Bytes(), psi_w) </span><span class="cov8" title="1">{
                        if debugAudit </span><span class="cov0" title="0">{
                                fmt.Printf("Verdict Error: WorkReportHash %x already in psi_w\n", verdict.Target)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDAlreadyRecordedVerdictWithFaults</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
func checkWorkReportHashInSet(hash []byte, set [][]byte) bool <span class="cov8" title="1">{
        for _, h := range set </span><span class="cov8" title="1">{
                if bytes.Equal(h, hash) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func checkVote(v []types.Verdict) error <span class="cov8" title="1">{
        for _, verdict := range v </span><span class="cov8" title="1">{
                vote_counter := 0
                for i, vote := range verdict.Votes </span><span class="cov8" title="1">{
                        // check duplicate
                        if vote.Voting </span><span class="cov8" title="1">{
                                vote_counter++
                        }</span>
                        <span class="cov8" title="1">for j, vote2 := range verdict.Votes </span><span class="cov8" title="1">{
                                if i == j </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if vote2.Index == vote.Index </span><span class="cov8" title="1">{
                                        if debugAudit </span><span class="cov0" title="0">{
                                                fmt.Printf("Vote Error: duplicate index %v in index %v\n", vote.Index, j)
                                        }</span>
                                        <span class="cov8" title="1">return jamerrors.ErrDNotUniqueVotes</span>
                                }
                        }
                        // check index
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if vote.Index &lt; verdict.Votes[i-1].Index </span><span class="cov8" title="1">{
                                if debugAudit </span><span class="cov0" title="0">{
                                        fmt.Printf("Vote Error: index %v should be bigger than %v\n", vote.Index, verdict.Votes[i-1].Index)
                                }</span>
                                <span class="cov8" title="1">return jamerrors.ErrDNotSortedWorkReports</span>
                        }
                }
                <span class="cov8" title="1">if vote_counter == 0 || vote_counter == types.ValidatorsSuperMajority || vote_counter == types.WonkyTrueThreshold </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        if debugAudit </span><span class="cov0" title="0">{
                                fmt.Printf("Vote Error: vote count %v is invalid\n", vote_counter)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDNotHomogenousJudgements</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// process the dispute
func verdict2result(v []types.Verdict) []VerdictResult <span class="cov8" title="1">{
        var result []VerdictResult
        for _, verdict := range v </span><span class="cov8" title="1">{
                // count the vote
                positiveCount := 0
                for _, vote := range verdict.Votes </span><span class="cov8" title="1">{
                        if vote.Voting </span><span class="cov8" title="1">{
                                positiveCount++
                        }</span>
                }
                <span class="cov8" title="1">result = append(result, VerdictResult{
                        WorkReportHash: verdict.Target,
                        PositveCount:   positiveCount,
                })</span>
                // for _, r := range result {
                //         fmt.Printf("WorkReportHash: %x, PositveCount: %v\n", r.WorkReportHash, r.PositveCount)
                // }

        }

        <span class="cov8" title="1">return result</span>
}
func (j *JamState) sortSet(VerdictResult []VerdictResult) <span class="cov0" title="0">{
        for _, v := range VerdictResult </span><span class="cov0" title="0">{
                if v.PositveCount == 0 </span><span class="cov0" title="0">{
                        //bad
                        j.DisputesState.Psi_b = append(j.DisputesState.Psi_b, v.WorkReportHash.Bytes())

                }</span> else<span class="cov0" title="0"> if v.PositveCount == ValidatorNum/3 </span><span class="cov0" title="0">{
                        //wonky
                        j.DisputesState.Psi_w = append(j.DisputesState.Psi_w, v.WorkReportHash.Bytes())
                }</span> else<span class="cov0" title="0"> if v.PositveCount == ValidatorNum*2/3+1 </span><span class="cov0" title="0">{
                        //good
                        j.DisputesState.Psi_g = append(j.DisputesState.Psi_g, v.WorkReportHash.Bytes())
                }</span>
        }
        <span class="cov0" title="0">j.DisputesState.Psi_b = sortByHash(j.DisputesState.Psi_b)
        j.DisputesState.Psi_w = sortByHash(j.DisputesState.Psi_w)
        j.DisputesState.Psi_g = sortByHash(j.DisputesState.Psi_g)</span>

}
func (j *JamState) sortSet_Prime(VerdictResult []VerdictResult) JamState <span class="cov8" title="1">{
        state_prime := JamState{}
        for _, v := range VerdictResult </span><span class="cov8" title="1">{
                if v.PositveCount == 0 </span><span class="cov8" title="1">{
                        //bad
                        state_prime.DisputesState.Psi_b = append(state_prime.DisputesState.Psi_b, v.WorkReportHash.Bytes())

                }</span> else<span class="cov8" title="1"> if v.PositveCount == ValidatorNum/3 </span><span class="cov8" title="1">{
                        //wonky
                        state_prime.DisputesState.Psi_w = append(state_prime.DisputesState.Psi_w, v.WorkReportHash.Bytes())
                }</span> else<span class="cov8" title="1"> if v.PositveCount == ValidatorNum*2/3+1 </span><span class="cov8" title="1">{
                        //good
                        state_prime.DisputesState.Psi_g = append(state_prime.DisputesState.Psi_g, v.WorkReportHash.Bytes())
                }</span>
        }
        <span class="cov8" title="1">state_prime.DisputesState.Psi_b = sortByHash(state_prime.DisputesState.Psi_b)
        state_prime.DisputesState.Psi_w = sortByHash(state_prime.DisputesState.Psi_w)
        state_prime.DisputesState.Psi_g = sortByHash(state_prime.DisputesState.Psi_g)
        return state_prime</span>
}
func (j *JamState) clearReportRho(V []VerdictResult) <span class="cov0" title="0">{

        for i := range j.AvailabilityAssignments </span><span class="cov0" title="0">{
                rhoo := j.AvailabilityAssignments[i]
                if rhoo == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">for _, h := range V </span><span class="cov0" title="0">{

                        wrHash := common.ComputeHash(rhoo.WorkReport.Bytes())
                        if bytes.Equal(wrHash, h.WorkReportHash.Bytes()) &amp;&amp; h.PositveCount &lt; ValidatorNum*2/3 </span><span class="cov0" title="0">{
                                // clear the old report
                                j.AvailabilityAssignments[i] = nil

                        }</span>
                }
        }

}

func (j *JamState) updateOffender(c []types.Culprit, f []types.Fault) <span class="cov0" title="0">{
        for _, c := range c </span><span class="cov0" title="0">{
                j.DisputesState.Psi_o = append(j.DisputesState.Psi_o, c.Key)
        }</span>
        <span class="cov0" title="0">for _, f := range f </span><span class="cov0" title="0">{
                j.DisputesState.Psi_o = append(j.DisputesState.Psi_o, f.Key)

        }</span>
        //sort the key
        <span class="cov0" title="0">j.DisputesState.Psi_o = sortByKey(j.DisputesState.Psi_o)</span>
}
func processTypesOutput(_verdictResult []VerdictResult, c []types.Culprit, f []types.Fault) types.OffenderMarker <span class="cov0" title="0">{
        var output2 types.OffenderMarker
        for _, culprit := range c </span><span class="cov0" title="0">{
                output2.OffenderKey = append(output2.OffenderKey, culprit.Key)
        }</span>
        <span class="cov0" title="0">for _, fault := range f </span><span class="cov0" title="0">{
                output2.OffenderKey = append(output2.OffenderKey, fault.Key)
        }</span>
        <span class="cov0" title="0">if output2.OffenderKey == nil </span><span class="cov0" title="0">{
                output2.OffenderKey = []types.Ed25519Key{}
        }</span>
        <span class="cov0" title="0">return output2</span>
}

func sortByHash(set [][]byte) [][]byte <span class="cov8" title="1">{
        for i := range set </span><span class="cov8" title="1">{
                for j := range set </span><span class="cov8" title="1">{
                        if bytes.Compare(set[i], set[j]) &lt; 0 </span><span class="cov0" title="0">{
                                set[i], set[j] = set[j], set[i]
                        }</span>
                }
        }
        <span class="cov8" title="1">return set</span>
}
func sortByKey(set []types.Ed25519Key) []types.Ed25519Key <span class="cov0" title="0">{
        for i := range set </span><span class="cov0" title="0">{
                for j := range set </span><span class="cov0" title="0">{
                        if bytes.Compare(set[i][:], set[j][:]) &lt; 0 </span><span class="cov0" title="0">{
                                set[i], set[j] = set[j], set[i]
                        }</span>
                }
        }
        <span class="cov0" title="0">return set</span>
}
func isFaultEnoughAndValid(state_prime JamState, f []types.Fault) error <span class="cov8" title="1">{
        counter := 0
        for _, s := range state_prime.DisputesState.Psi_g </span><span class="cov8" title="1">{
                for _, f := range f </span><span class="cov8" title="1">{
                        if bytes.Equal(s, f.Target.Bytes()) </span><span class="cov8" title="1">{
                                counter++
                        }</span>
                }
                <span class="cov8" title="1">if counter &lt; 1 </span><span class="cov8" title="1">{
                        return jamerrors.ErrDMissingFaultsGoodVerdict
                }</span>
        }
        <span class="cov8" title="1">found := false
        for _, f := range f </span><span class="cov8" title="1">{
                if f.Voting </span><span class="cov8" title="1">{
                        if debugAudit </span><span class="cov0" title="0">{
                                fmt.Printf("Fault Error: fault should be false, invalid key: %v\n", f.Key)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDAuditorMarkedOffender</span>
                }
                <span class="cov8" title="1">for _, s := range state_prime.DisputesState.Psi_g </span><span class="cov8" title="1">{
                        if bytes.Equal(s, f.Target.Bytes()) </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        return fmt.Errorf("Fault Error: work report hash %x should be in good set", f.Target)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
func isCulpritEnoughAndValid(state_prime JamState, c []types.Culprit) error <span class="cov8" title="1">{
        counter := 0
        for _, s := range state_prime.DisputesState.Psi_b </span><span class="cov8" title="1">{
                for _, c := range c </span><span class="cov8" title="1">{
                        if bytes.Equal(s, c.Target.Bytes()) </span><span class="cov8" title="1">{
                                counter++
                        }</span>
                }
                <span class="cov8" title="1">if counter == 0 </span><span class="cov8" title="1">{
                        return jamerrors.ErrDMissingCulpritsBadVerdict
                }</span>
                <span class="cov8" title="1">if counter &lt; 2 </span><span class="cov8" title="1">{
                        if debugA </span><span class="cov0" title="0">{
                                fmt.Printf("Culprit Error: work report hash %x in psi_b should have at least two culprit\n", s)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDSingleCulpritBadVerdict</span>
                }
        }
        <span class="cov8" title="1">found := false
        for _, c := range c </span><span class="cov8" title="1">{
                for _, s := range state_prime.DisputesState.Psi_b </span><span class="cov8" title="1">{
                        if bytes.Equal(s, c.Target.Bytes()) </span><span class="cov8" title="1">{
                                found = true
                        }</span>
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        if debugAudit </span><span class="cov0" title="0">{
                                fmt.Printf("Culprit Error: work report hash %x should be in bad set\n", c.Target)
                        }</span>
                        <span class="cov8" title="1">return jamerrors.ErrDOffenderNotPresentVerdict</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package statedb

import (
        "github.com/colorfulnotion/jam/bls"
        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

func (s *StateDB) Finalize(v types.ValidatorSecret) (blsSignature bls.Signature, finalizedEpoch bool, err error) <span class="cov0" title="0">{
        finalizedEpoch = false
        s.Finalized = true
        if s.Block.Header.EpochMark != nil </span><span class="cov0" title="0">{
                lastB := s.JamState.RecentBlocks[len(s.JamState.RecentBlocks)-1].B.Peaks
                bEncoding, err0 := types.Encode(lastB)
                if err0 != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">beefyBytes := append([]byte(types.X_B), common.Keccak256(bEncoding).Bytes()...)
                var blsSecretKey bls.SecretKey
                copy(blsSecretKey[:], v.BlsSecret[:])
                blsSignature, err = blsSecretKey.Sign(beefyBytes)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">return blsSignature, true, nil</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package statedb

import (
        "encoding/binary"
        "encoding/json"
        "fmt"

        //"io/ioutil"
        "os"
        //"path/filepath"
        "time"

        "github.com/colorfulnotion/jam/bandersnatch"
        "github.com/colorfulnotion/jam/bls"
        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/types"
)

// 6.4.1 Startup parameters

// CreateGenesisState generates the StateDB object and genesis statedb
func CreateGenesisState(sdb *storage.StateDBStorage, chainSpec types.ChainSpec, epochFirstSlot uint64, network string) (outfn string, err error) <span class="cov0" title="0">{
        statedb, err := newStateDB(sdb, common.Hash{})
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">validators := make(types.Validators, chainSpec.NumValidators)
        for i := uint32(0); i &lt; uint32(chainSpec.NumValidators); i++ </span><span class="cov0" title="0">{
                seed := make([]byte, 32)

                for j := 0; j &lt; 8; j++ </span><span class="cov0" title="0">{
                        binary.LittleEndian.PutUint32(seed[j*4:], i)
                }</span>

                <span class="cov0" title="0">v, err0 := InitValidatorSecret(seed, seed, seed, "")
                if err0 != nil </span><span class="cov0" title="0">{
                        return outfn, err0
                }</span>
                <span class="cov0" title="0">var vpub types.Validator
                copy(vpub.Bandersnatch[:], v.BandersnatchPub[:])
                copy(vpub.Ed25519[:], v.Ed25519Pub[:])
                copy(vpub.Bls[:], v.BlsPub[:])
                copy(vpub.Metadata[:], v.Metadata[:])
                validators[i] = vpub</span>
        }

        <span class="cov0" title="0">j := NewJamState()
        j.SafroleState.EpochFirstSlot = uint32(epochFirstSlot)
        j.SafroleState.Timeslot = 0
        if types.TimeUnitMode != "TimeStamp" </span><span class="cov0" title="0">{
                j.SafroleState.Timeslot = j.SafroleState.Timeslot / types.SecondsPerSlot
        }</span>

        <span class="cov0" title="0">vB := []byte{}
        for _, v := range validators </span><span class="cov0" title="0">{
                vB = append(vB, v.Bytes()...)
        }</span>
        <span class="cov0" title="0">j.SafroleState.PrevValidators = validators
        j.SafroleState.CurrValidators = validators
        j.SafroleState.NextValidators = validators
        j.SafroleState.DesignedValidators = validators

        /*
                The on-chain randomness is initialized after the genesis block construction.
                The first buffer entry is set as the Blake2b hash of the genesis block,
                each of the other entries is set as the Blake2b hash of the previous entry.
        */
        j.SafroleState.Entropy[0] = common.BytesToHash(common.ComputeHash(vB))                                //BLAKE2B hash of the genesis block#0
        j.SafroleState.Entropy[1] = common.BytesToHash(common.ComputeHash(j.SafroleState.Entropy[0].Bytes())) //BLAKE2B of Current
        j.SafroleState.Entropy[2] = common.BytesToHash(common.ComputeHash(j.SafroleState.Entropy[1].Bytes())) //BLAKE2B of EpochN1
        j.SafroleState.Entropy[3] = common.BytesToHash(common.ComputeHash(j.SafroleState.Entropy[2].Bytes())) //BLAKE2B of EpochN2
        j.SafroleState.TicketsOrKeys.Keys, _ = j.SafroleState.ChooseFallBackValidator()
        j.DisputesState = Psi_state{}

        // Setup Bootstrap Service for all 3 privileges
        j.PrivilegedServiceIndices.Kai_a = BootstrapServiceCode
        j.PrivilegedServiceIndices.Kai_v = BootstrapServiceCode
        j.PrivilegedServiceIndices.Kai_m = BootstrapServiceCode
        for i := 0; i &lt; types.TotalCores; i++ </span><span class="cov0" title="0">{
                j.AuthorizationsPool[i] = make([]common.Hash, types.MaxAuthorizationPoolItems)
                var temp [6]common.Hash
                j.AuthorizationQueue[i] = temp
                //j.AuthorizationQueue[i] = make([]common.Hash, types.MaxAuthorizationQueueItems)
        }</span>
        // setup the initial state of the accumulate state
        <span class="cov0" title="0">for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov0" title="0">{
                j.AccumulationQueue[i] = make([]types.AccumulationQueue, 0)
                j.AccumulationHistory[i] = types.AccumulationHistory{}
        }</span>

        <span class="cov0" title="0">statedb.JamState = j
        statedb.Block = nil

        // Load services into genesis state
        services := []types.TestService{
                {ServiceCode: BootstrapServiceCode, FileName: BootstrapServiceFile},
                // Add more services here as needed IF they are needed for Genesis
        }

        for _, service := range services </span><span class="cov0" title="0">{
                fn := common.GetFilePath(service.FileName)
                code, err0 := os.ReadFile(fn)
                if err0 != nil </span><span class="cov0" title="0">{
                        return outfn, err
                }</span>
                <span class="cov0" title="0">codeHash := common.Blake2Hash(code)
                bootstrapServiceAccount := types.ServiceAccount{
                        CodeHash:        codeHash,
                        Balance:         10000,
                        GasLimitG:       100,
                        GasLimitM:       100,
                        StorageSize:     uint64(81 + len(code) + 0), // a_l = ∑ 81+z per (h,z) + ∑ 32+s
                        NumStorageItems: 2*1 + 0,                    //a_i = 2⋅∣al∣+∣as∣
                }
                statedb.WriteServicePreimageBlob(service.ServiceCode, code)
                statedb.writeService(service.ServiceCode, &amp;bootstrapServiceAccount)</span>
        }

        <span class="cov0" title="0">statedb.StateRoot = statedb.UpdateTrieState()
        outfn = common.GetFilePath(fmt.Sprintf("chainspecs/state_snapshots/genesis-%s", network))
        types.SaveObject(outfn, statedb.JamState.Snapshot())

        trace := StateSnapshotRaw{
                StateRoot: statedb.StateRoot,
                KeyVals:   statedb.GetAllKeyValues(),
        }
        outfn = common.GetFilePath(fmt.Sprintf("chainspecs/traces/genesis-%s", network))
        types.SaveObject(outfn, trace)

        return</span>
}

func NewStateDBFromSnapshotRawFile(sdb *storage.StateDBStorage, filename string) (statedb *StateDB, err error) <span class="cov0" title="0">{
        fn := common.GetFilePath(filename)
        snapshotRawBytes, err := os.ReadFile(fn)
        if err != nil </span><span class="cov0" title="0">{
                return statedb, err
        }</span>
        <span class="cov0" title="0">var stateSnapshotRaw StateSnapshotRaw
        err = json.Unmarshal(snapshotRawBytes, &amp;stateSnapshotRaw)
        if err != nil </span><span class="cov0" title="0">{
                return statedb, err
        }</span>
        <span class="cov0" title="0">return NewStateDBFromSnapshotRaw(sdb, &amp;stateSnapshotRaw)</span>
}

func NewStateDBFromSnapshotRaw(sdb *storage.StateDBStorage, stateSnapshotRaw *StateSnapshotRaw) (statedb *StateDB, err error) <span class="cov0" title="0">{
        statedb, err = newStateDB(sdb, common.Hash{})
        if err != nil </span><span class="cov0" title="0">{
                return statedb, err
        }</span>
        <span class="cov0" title="0">statedb.Block = nil
        statedb.StateRoot = statedb.UpdateAllTrieStateRaw(*stateSnapshotRaw)
        statedb.JamState = NewJamState()
        statedb.RecoverJamState(statedb.StateRoot)

        // Because we have safrolestate as internal state, JamState is NOT enough.
        s := statedb.JamState
        s.SafroleState.NextEpochTicketsAccumulator = s.SafroleStateGamma.GammaA      // γa: Ticket accumulator for the next epoch (epoch N+1) DONE
        s.SafroleState.TicketsVerifierKey = s.SafroleStateGamma.GammaZ               // γz: Epoch’s root, a Bandersnatch ring root composed with one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        s.SafroleState.TicketsOrKeys = s.SafroleStateGamma.GammaS                    // γs: Current epoch’s slot-sealer series (epoch N)
        s.SafroleState.NextValidators = types.Validators(s.SafroleStateGamma.GammaK) // γk: Next epoch’s validators (epoch N+1)
        // fmt.Printf("GammaK: %x\n", types.Validators(s.SafroleStateGamma.GammaK))
        // what about GammaK?
        //fmt.Printf("JS: %s\n", statedb.JamState.String())
        //fmt.Printf("Safrole State: %s\n", statedb.JamState.SafroleState.String())

        return statedb, nil</span>
}

// The current time expressed in seconds after the start of the Jam Common Era. See section 4.4
func computeJCETime(unixTimestamp int64) uint32 <span class="cov0" title="0">{
        // Define the start of the Jam Common Era
        jceStart := time.Date(2024, time.January, 1, 12, 0, 0, 0, time.UTC)

        // Convert the Unix timestamp to a Time object
        currentTime := time.Unix(unixTimestamp, 0).UTC()

        // Calculate the difference in seconds
        diff := currentTime.Sub(jceStart)
        return uint32(diff.Seconds())
}</span>

// Function to convert JCETime back to the original Unix timestamp
func JCETimeToUnixTimestamp(jceTime uint32) int64 <span class="cov0" title="0">{
        // Define the start of the Jam Common Era
        jceStart := time.Date(2024, time.January, 1, 12, 0, 0, 0, time.UTC)

        // Add the JCE time (in seconds) to the start time
        originalTime := jceStart.Add(time.Duration(jceTime) * time.Second)
        return originalTime.Unix()
}</span>

func NewEpoch0Timestamp() uint32 <span class="cov0" title="0">{
        now := time.Now().Unix()
        second_per_epoch := types.SecondsPerEpoch // types.EpochLength
        if types.TimeUnitMode != "TimeStamp" </span><span class="cov0" title="0">{
                now = common.ComputeJCETime(now, true)
        }</span>
        // epoch0Timestamp := uint64(6 * ((now + 12 + types.SecondsPerSlot) / 6))
        // FOR JAM TESTNET:
        // second_per_epoch := uint64(types.SecondsPerSlot * types.EpochLength)
        // USE THIS for generating public traces with a full E for the first epoch
        <span class="cov0" title="0">waitTime := int64(second_per_epoch) - now%int64(second_per_epoch)
        epoch0Timestamp := uint64(now) + uint64(waitTime)
        if types.TimeSavingMode &amp;&amp; !(waitTime &lt; 5) </span><span class="cov0" title="0">{
                fmt.Printf("===Time Saving Mode===\n")
                AddTime := (time.Duration(-waitTime) + 5) * time.Second
                fmt.Printf("AddTime: %v\n", AddTime)
                common.AddJamStart(AddTime)
                fmt.Printf("JCE Start Time: %v\n", common.JceStart)
                now := time.Now().Unix()
                if types.TimeUnitMode != "TimeStamp" </span><span class="cov0" title="0">{
                        now = common.ComputeJCETime(now, true)
                }</span>
                <span class="cov0" title="0">waitTime = int64(second_per_epoch) - now%int64(second_per_epoch)
                epoch0Timestamp = uint64(now) + uint64(waitTime)</span>
        }

        <span class="cov0" title="0">fmt.Printf("!!!NewGenesisConfig epoch0Timestamp: %v. Wait:%v Sec \n", epoch0Timestamp, uint64(waitTime))
        return uint32(epoch0Timestamp)</span>
}

func InitValidator(bandersnatch_seed, ed25519_seed, bls_seed []byte, metadata string) (types.Validator, error) <span class="cov0" title="0">{
        validator := types.Validator{}
        banderSnatch_pub, _, err := bandersnatch.InitBanderSnatchKey(bandersnatch_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validator, fmt.Errorf("Failed to init BanderSnatch Key")
        }</span>
        <span class="cov0" title="0">ed25519_pub, _, err := types.InitEd25519Key(ed25519_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validator, fmt.Errorf("Failed to init Ed25519 Key")
        }</span>
        <span class="cov0" title="0">bls_pub, _, err := bls.InitBLSKey(bls_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validator, fmt.Errorf("Failed to init BanderSnatch Key")
        }</span>

        <span class="cov0" title="0">validator.Ed25519 = ed25519_pub
        copy(validator.Bandersnatch[:], banderSnatch_pub.Bytes())
        copy(validator.Metadata[:], []byte(metadata))
        copy(validator.Bls[:], bls_pub.Bytes())
        return validator, nil</span>
}

func InitValidatorSecret(bandersnatch_seed, ed25519_seed, bls_seed []byte, metadata string) (types.ValidatorSecret, error) <span class="cov0" title="0">{
        validatorSecret := types.ValidatorSecret{}
        banderSnatch_pub, banderSnatch_priv, err := bandersnatch.InitBanderSnatchKey(bandersnatch_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validatorSecret, fmt.Errorf("Failed to init BanderSnatch Key")
        }</span>
        <span class="cov0" title="0">ed25519_pub, ed25519_priv, err := types.InitEd25519Key(ed25519_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validatorSecret, fmt.Errorf("Failed to init Ed25519 Key")
        }</span>
        <span class="cov0" title="0">bls_pub, bls_priv, err := bls.InitBLSKey(bls_seed)
        if err != nil </span><span class="cov0" title="0">{
                return validatorSecret, fmt.Errorf("Failed to init BLS Key")
        }</span>

        <span class="cov0" title="0">copy(validatorSecret.Ed25519Secret[:], ed25519_priv[:])
        validatorSecret.Ed25519Pub = ed25519_pub

        validatorSecret.BandersnatchSecret = banderSnatch_priv.Bytes()
        validatorSecret.BandersnatchPub = types.BandersnatchKey(banderSnatch_pub)

        copy(validatorSecret.BlsSecret[:], bls_priv.Bytes())
        copy(validatorSecret.BlsPub[:], bls_pub.Bytes())

        copy(validatorSecret.Metadata[:], []byte(metadata))
        return validatorSecret, nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package statedb

import (
        "fmt"
        "sort"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/jamerrors"
        "github.com/colorfulnotion/jam/types"
)

// chapter 11

// v0.5 eq 11.42 - the rho state transition function
func (j *JamState) ProcessGuarantees(guarantees []types.Guarantee) <span class="cov8" title="1">{
        for _, guarantee := range guarantees </span><span class="cov8" title="1">{
                if guarantee.Report.CoreIndex &gt;= types.TotalCores </span><span class="cov0" title="0">{
                        fmt.Printf("ProcessGuarantees: invalid core index %v\n", guarantee.Report.CoreIndex)
                        continue</span>
                }
                <span class="cov8" title="1">if j.AvailabilityAssignments[int(guarantee.Report.CoreIndex)] == nil </span><span class="cov8" title="1">{
                        j.SetRhoByWorkReport(guarantee.Report.CoreIndex, guarantee.Report, j.SafroleState.GetTimeSlot())
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("ProcessGuarantees Success on Core %v\n", guarantee.Report.CoreIndex)
                        }</span>
                }
        }
}

// setRhoByWorkReport sets the Rho state for a specific core with a WorkReport and timeslot
func (state *JamState) SetRhoByWorkReport(core uint16, w types.WorkReport, t uint32) <span class="cov8" title="1">{
        state.AvailabilityAssignments[int(core)] = &amp;Rho_state{
                WorkReport: w,
                Timeslot:   t,
        }
}</span>

// this function is the strictest one, is for the verification after the state transition before the state gets updated by extrinsic guarantees
func (s *StateDB) Verify_Guarantees() error <span class="cov8" title="1">{
        // v0.5 eq 11.23
        err := CheckSorting_EGs(s.Block.Extrinsic.Guarantees)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">for _, guarantee := range s.Block.Extrinsic.Guarantees </span><span class="cov8" title="1">{
                err = s.Verify_Guarantee(guarantee)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        // v0.5 eq 11.31
        <span class="cov8" title="1">err = s.checkLength() // not sure if this is correct behavior
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // for recent history and extrinsics in the block, so it should be here
        <span class="cov8" title="1">for _, guarantee := range s.Block.Extrinsic.Guarantees </span><span class="cov8" title="1">{
                // v0.5 eq 11.38
                err = s.checkRecentWorkPackage(guarantee, s.Block.Extrinsic.Guarantees)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">err := s.checkPrereq(guarantee, s.Block.Extrinsic.Guarantees)
                if err != nil </span><span class="cov8" title="1">{
                        return err // INSTEAD of jamerrors.ErrGDependencyMissing
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// this function will accept one guarantee at a time, it will be used by make block to make sure which guarantee should be included in the block
func (s *StateDB) Verify_Guarantee_MakeBlock(guarantee types.Guarantee) error <span class="cov0" title="0">{
        max_core := types.TotalCores - 1
        if guarantee.Report.CoreIndex &gt; uint16(max_core) </span><span class="cov0" title="0">{
                return jamerrors.ErrGBadCoreIndex
        }</span>
        <span class="cov0" title="0">max_validator := types.TotalValidators - 1
        for _, g := range guarantee.Signatures </span><span class="cov0" title="0">{
                if g.ValidatorIndex &gt; uint16(max_validator) </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadValidatorIndex
                }</span>
        }
        <span class="cov0" title="0">if len(guarantee.Signatures) &lt; 2 </span><span class="cov0" title="0">{
                return jamerrors.ErrGInsufficientGuarantees
        }</span>
        <span class="cov0" title="0">err := s.checkServicesExist(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // v0.5 eq 11.24 - check index
        <span class="cov0" title="0">err = CheckSorting_EG(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err // CHECK: instead of jamerrors.ErrGDuplicateGuarantors
        }</span>

        // v0.5 eq 11.25 - check signature, core assign check,C_v ...
        <span class="cov0" title="0">if !s.IsPreviousValidators(guarantee.Slot) </span><span class="cov0" title="0">{
                CurrV := s.JamState.SafroleState.CurrValidators
                err = guarantee.Verify(CurrV) // errBadSignature
                if err != nil </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadSignature
                }</span>
        } else<span class="cov0" title="0"> {
                PrevV := s.JamState.SafroleState.PrevValidators
                err = guarantee.Verify(PrevV) // errBadSignature
                if err != nil </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadSignature
                }</span>
        }
        // v0.5 eq 11.25 - The signing validators must be assigned to the core in G or G*
        // custom function for make block
        <span class="cov0" title="0">err = s.areValidatorsAssignedToCore_MakeBlock(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Verify_Guarantee error MakeBlock: %v\n", err)
                return err // CHECK: instead of jamerrors.ErrGWrongAssignment
        }</span>
        <span class="cov0" title="0">j := s.JamState
        // v0.5 eq 11.28
        if s.Block != nil </span><span class="cov0" title="0">{
                err = j.checkReportTimeOut(guarantee, s.Block.TimeSlot())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // v.05 eq 11.29 - check gas
        <span class="cov0" title="0">err = s.checkGas(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err // CHECK: instead of jamerrors.ErrGWorkReportGasTooHigh
        }</span>

        // v0.5 eq 11.33
        <span class="cov0" title="0">err = s.checkTimeSlotHeader(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // v0.5 eq 11.34
        <span class="cov0" title="0">err = s.checkRecentBlock(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // v0.5 eq 11.38
        <span class="cov0" title="0">err = s.checkAnyPrereq(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // v0.5 eq 11.39
        // err = s.checkAncestorSetA(guarantee)
        // if err != nil {
        //         return err
        // }
        // v0.5 eq 11.41 - check code hash
        <span class="cov0" title="0">err = s.checkCodeHash(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// this function accepts multiple guarantees at a time, it will be used by make block for dropping the invalid guarantees
// after the first picking the valid guarantees, it will be used by remaining guarantees to make sure which guarantee should be included in the block
// there are some verification need to be check with other guarantees, so it should be used after the first picking
func (s *StateDB) Verify_Guarantees_MakeBlock(EGs []types.Guarantee) ([]types.Guarantee, error, bool) <span class="cov0" title="0">{
        // v0.5 eq 11.23 - check index
        var valid bool
        err := CheckSorting_EGs(EGs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err, false
        }</span>
        <span class="cov0" title="0">for i, guarantee := range EGs </span><span class="cov0" title="0">{
                // v0.5 eq 11.24  - check index
                err := CheckSorting_EG(guarantee)
                if err != nil </span><span class="cov0" title="0">{
                        EGs = append(EGs[:i], EGs[i+1:]...)
                        valid = false
                }</span>
                // TODO: Shawn to re-enable this
                //v0.5 eq 11.38
                <span class="cov0" title="0">err = s.checkPrereq(guarantee, EGs)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Verify_Guarantees_MakeBlock error: %v\n", err)
                        EGs = append(EGs[:i], EGs[i+1:]...)
                        valid = false
                }</span>
                // v0.4.5 eq 155
                <span class="cov0" title="0">err = s.checkRecentWorkPackage(guarantee, EGs)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Verify_Guarantees_MakeBlock error: %v\n", err)
                        EGs = append(EGs[:i], EGs[i+1:]...)
                        valid = false
                }</span>
        }
        <span class="cov0" title="0">if valid </span><span class="cov0" title="0">{
                return EGs, nil, true
        }</span> else<span class="cov0" title="0"> {
                return EGs, nil, false
        }</span>
}

// this function will be used by the state transition function in the single guarantee verification
// it will be called by Verify_Guarantees
func (s *StateDB) Verify_Guarantee(guarantee types.Guarantee) error <span class="cov8" title="1">{

        // // for shawn
        err := s.VerifyGuarantee_Basic(guarantee)
        // err = j.CheckReportPendingOnCore(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // for stanley
        <span class="cov8" title="1">err = s.VerifyGuarantee_RecentHistory(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *StateDB) VerifyGuarantee_Basic(guarantee types.Guarantee) error <span class="cov8" title="1">{

        err := s.checkServicesExist(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">max_core := types.TotalCores - 1
        if guarantee.Report.CoreIndex &gt; uint16(max_core) </span><span class="cov8" title="1">{
                return jamerrors.ErrGBadCoreIndex
        }</span>
        <span class="cov8" title="1">max_validator := types.TotalValidators - 1
        for _, g := range guarantee.Signatures </span><span class="cov8" title="1">{
                if g.ValidatorIndex &gt; uint16(max_validator) </span><span class="cov8" title="1">{
                        return jamerrors.ErrGBadValidatorIndex
                }</span>
        }
        <span class="cov8" title="1">if len(guarantee.Signatures) &lt; 2 </span><span class="cov8" title="1">{
                return jamerrors.ErrGInsufficientGuarantees
        }</span>

        // v0.5 eq 11.24
        <span class="cov8" title="1">err = CheckSorting_EG(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return jamerrors.ErrGDuplicateGuarantors
        }</span>

        // v0.5 eq 11.25 - check signature, core assign check,C_v ...
        <span class="cov8" title="1">CurrV := s.JamState.SafroleState.CurrValidators
        PrevV := s.JamState.SafroleState.PrevValidators
        if !s.IsPreviousValidators(guarantee.Slot) </span><span class="cov8" title="1">{
                err = guarantee.Verify(CurrV) // errBadSignature
                if err != nil </span><span class="cov8" title="1">{
                        return jamerrors.ErrGBadSignature
                }</span>
        } else<span class="cov8" title="1"> {
                err = guarantee.Verify(PrevV) // errBadSignature
                if err != nil </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadSignature
                }</span>
        }

        // v0.5 eq 11.25 - The signing validators must be assigned to the core in G or G*
        <span class="cov8" title="1">err = s.areValidatorsAssignedToCore(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">j := s.JamState
        // v0.5 eq 11.28
        err = j.checkReportPendingOnCore(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // v0.5 eq 11.28
        <span class="cov8" title="1">if s.Block != nil </span><span class="cov8" title="1">{
                err = j.checkReportTimeOut(guarantee, s.Block.TimeSlot())
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        // v.05 eq 11.29 - check gas
        <span class="cov8" title="1">err = s.checkGas(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        // v0.5 eq 11.33 g.Report.RefineContext.LookupAnchorSlot doesn't have a value
        <span class="cov8" title="1">err = s.checkTimeSlotHeader(guarantee)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // v0.5 eq 11.41 - check code hash
        <span class="cov8" title="1">err = s.checkCodeHash(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>

}

func (s *StateDB) VerifyGuarantee_RecentHistory(guarantee types.Guarantee) error <span class="cov8" title="1">{

        // v0.4.5 eq 147 recent restory
        err := s.checkRecentBlock(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // v0.4.5 eq 152
        // beefy root have fucking problem
        <span class="cov8" title="1">err = s.checkAnyPrereq(guarantee)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        //TODO 149
        // err = s.checkAncestorSetA(guarantee)
        // if err != nil {
        //         return err
        // }
        <span class="cov8" title="1">return nil</span>
}

// this function will be used when a validator receive a block
func (s *StateDB) ValidateGuarantees(guarantees []types.Guarantee) error <span class="cov0" title="0">{
        for _, guarantee := range guarantees </span><span class="cov0" title="0">{
                err := s.Verify_Guarantee_MakeBlock(guarantee)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("ValidateGuarantees error: %v\n", err)
                }</span>
        }
        <span class="cov0" title="0">_, err, valid := s.Verify_Guarantees_MakeBlock(guarantees)
        if err != nil || !valid </span><span class="cov0" title="0">{
                fmt.Printf("ValidateGuarantees error: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// v0.5 eq 11.23 - this function will be used by make block
func SortByCoreIndex(guarantees []types.Guarantee) <span class="cov0" title="0">{
        // sort guarantees by core index
        sort.Slice(guarantees, func(i, j int) bool </span><span class="cov0" title="0">{
                return guarantees[i].Report.CoreIndex &lt; guarantees[j].Report.CoreIndex
        }</span>)

}

// v0.5 eq 11.23  - this function will be used by verify the block
func CheckCoreIndex(guarantees []types.Guarantee, new types.Guarantee) error <span class="cov0" title="0">{
        // check core index is correct
        core := make(map[uint16]bool)
        for _, guarantee := range guarantees </span><span class="cov0" title="0">{
                if guarantee.Report.CoreIndex &gt; types.TotalCores </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadCoreIndex
                }</span>
                <span class="cov0" title="0">core[guarantee.Report.CoreIndex] = true</span>
        }
        <span class="cov0" title="0">if core[new.Report.CoreIndex] </span><span class="cov0" title="0">{
                return jamerrors.ErrGBadCoreIndex // CHECK: not quite "coreindextoo big"
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// v0.5 eq 11.23 - this function will be used by verify the block
func CheckSorting_EGs(guarantees []types.Guarantee) error <span class="cov8" title="1">{
        //check SortByCoreIndex is correct
        for i := 0; i &lt; len(guarantees)-1; i++ </span><span class="cov8" title="1">{
                if guarantees[i].Report.CoreIndex &gt;= guarantees[i+1].Report.CoreIndex </span><span class="cov8" title="1">{
                        return jamerrors.ErrGOutOfOrderGuarantee
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.25 - The signing validators must be assigned to the core in G or G*
func (s *StateDB) areValidatorsAssignedToCore(guarantee types.Guarantee) error <span class="cov8" title="1">{
        assignment_idx := s.GetTimeslot() / types.ValidatorCoreRotationPeriod
        previous_assignment_idx := assignment_idx - 1
        previous_assignment_slot := previous_assignment_idx * types.ValidatorCoreRotationPeriod
        if guarantee.Slot &lt; previous_assignment_slot </span><span class="cov8" title="1">{
                return jamerrors.ErrGReportEpochBeforeLast
        }</span>
        <span class="cov8" title="1">timeSlotPeriod := s.GetTimeslot() / types.ValidatorCoreRotationPeriod
        reportTime := guarantee.Slot / types.ValidatorCoreRotationPeriod
        for _, g := range guarantee.Signatures </span><span class="cov8" title="1">{
                find_and_correct := false
                if timeSlotPeriod != reportTime </span><span class="cov8" title="1">{
                        for i, assignment := range s.PreviousGuarantorAssignments </span><span class="cov8" title="1">{
                                if uint16(i) == g.ValidatorIndex &amp;&amp; assignment.CoreIndex == guarantee.Report.CoreIndex </span><span class="cov8" title="1">{
                                        find_and_correct = true
                                        break</span>
                                }
                        }
                } else<span class="cov8" title="1"> {
                        for i, assignment := range s.GuarantorAssignments </span><span class="cov8" title="1">{
                                if uint16(i) == g.ValidatorIndex &amp;&amp; assignment.CoreIndex == guarantee.Report.CoreIndex </span><span class="cov8" title="1">{
                                        find_and_correct = true
                                        break</span>
                                }
                        }
                }
                // REVIEW
                <span class="cov8" title="1">if !find_and_correct </span><span class="cov8" title="1">{
                        if debugG </span><span class="cov0" title="0">{
                                fmt.Printf("%s\n", guarantee.String())
                                s.GuarantorsAssignmentsPrint()
                                if timeSlotPeriod != reportTime </span><span class="cov0" title="0">{
                                        fmt.Printf("We are using prev core assignment\n")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("We are using curr core assignment\n")
                                }</span>
                        }
                        <span class="cov8" title="1">return jamerrors.ErrGWrongAssignment</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.25 - The signing validators must be assigned to the core in G or G*
func (s *StateDB) areValidatorsAssignedToCore_MakeBlock(guarantee types.Guarantee) error <span class="cov0" title="0">{
        ts := s.Block.TimeSlot()
        assignment_idx := ts / types.ValidatorCoreRotationPeriod
        previous_assignment_idx := assignment_idx - 1
        previous_assignment_slot := previous_assignment_idx * types.ValidatorCoreRotationPeriod
        if guarantee.Slot &lt; previous_assignment_slot </span><span class="cov0" title="0">{
                return jamerrors.ErrGReportEpochBeforeLast
        }</span>
        <span class="cov0" title="0">timeSlotPeriod := s.Block.TimeSlot() / types.ValidatorCoreRotationPeriod
        reportTime := guarantee.Slot / types.ValidatorCoreRotationPeriod
        shift_bool := s.Block.Header.EpochMark != nil
        prev_assignment, curr_assignment := s.CaculateAssignments(shift_bool)
        for _, g := range guarantee.Signatures </span><span class="cov0" title="0">{
                find_and_correct := false
                if timeSlotPeriod != reportTime </span><span class="cov0" title="0">{
                        for i, assignment := range prev_assignment </span><span class="cov0" title="0">{
                                if uint16(i) == g.ValidatorIndex &amp;&amp; assignment.CoreIndex == guarantee.Report.CoreIndex </span><span class="cov0" title="0">{
                                        find_and_correct = true
                                        break</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        for i, assignment := range curr_assignment </span><span class="cov0" title="0">{
                                if uint16(i) == g.ValidatorIndex &amp;&amp; assignment.CoreIndex == guarantee.Report.CoreIndex </span><span class="cov0" title="0">{
                                        find_and_correct = true
                                        break</span>
                                }
                        }
                }
                <span class="cov0" title="0">if !find_and_correct </span><span class="cov0" title="0">{
                        if debugG </span><span class="cov0" title="0">{
                                fmt.Printf("%s\n", guarantee.String())
                                s.GuarantorsAssignmentsPrint()
                                if timeSlotPeriod != reportTime </span><span class="cov0" title="0">{
                                        fmt.Printf("We are using prev core assignment\n")
                                }</span> else<span class="cov0" title="0"> {
                                        fmt.Printf("We are using curr core assignment\n")
                                }</span>
                        }
                        <span class="cov0" title="0">return jamerrors.ErrGWrongAssignment</span>
                }

        }
        <span class="cov0" title="0">return nil</span>
}

// v0.5 eq 11.24 - sort the guarantee by validator index
func Sort_by_validator_index(g types.Guarantee) <span class="cov0" title="0">{
        sort.Slice(g.Signatures, func(i, j int) bool </span><span class="cov0" title="0">{
                return g.Signatures[i].ValidatorIndex &lt; g.Signatures[j].ValidatorIndex
        }</span>)
}

// v0.5 eq 11.24 check the guarantee is sorted by validator index or not
func CheckSorting_EG(g types.Guarantee) error <span class="cov8" title="1">{
        // check sort_by_validator_index is correct
        for i := 0; i &lt; len(g.Signatures)-1; i++ </span><span class="cov8" title="1">{
                if g.Signatures[i].ValidatorIndex &gt;= g.Signatures[i+1].ValidatorIndex </span><span class="cov8" title="1">{
                        return jamerrors.ErrGDuplicateGuarantors
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.27
func (s *StateDB) getWorkReport() []types.WorkReport <span class="cov0" title="0">{
        w := []types.WorkReport{}

        if s.Block != nil </span><span class="cov0" title="0">{
                for _, guarantee := range s.Block.Extrinsic.Guarantees </span><span class="cov0" title="0">{
                        w = append(w, guarantee.Report)
                }</span>
        }
        <span class="cov0" title="0">return w</span>
}

// v0.5 eq 11.28 - check pending report
func (j *JamState) checkReportTimeOut(g types.Guarantee, ts uint32) error <span class="cov8" title="1">{
        if g.Slot &gt; ts </span><span class="cov8" title="1">{
                return jamerrors.ErrGFutureReportSlot
        }</span>
        <span class="cov8" title="1">if j.AvailabilityAssignments[int(g.Report.CoreIndex)] == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">timeoutbool := ts &gt;= (j.AvailabilityAssignments[int(g.Report.CoreIndex)].Timeslot)+uint32(types.UnavailableWorkReplacementPeriod)
        if timeoutbool </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov8" title="1"> {
                return jamerrors.ErrGCoreEngaged
        }</span>
}

// v0.5 eq 11.28
func (j *JamState) checkReportPendingOnCore(g types.Guarantee) error <span class="cov8" title="1">{

        authorizations_pool := j.AuthorizationsPool[int(g.Report.CoreIndex)]
        find := false
        if len(authorizations_pool) == 0 </span><span class="cov8" title="1">{
                return jamerrors.ErrGCoreWithoutAuthorizer
        }</span>
        <span class="cov8" title="1">for _, authrization := range authorizations_pool </span><span class="cov8" title="1">{
                if authrization == g.Report.AuthorizerHash </span><span class="cov8" title="1">{
                        find = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !find </span><span class="cov8" title="1">{
                return jamerrors.ErrGCoreUnexpectedAuthorizer
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (j *JamState) CheckInvalidCoreIndex() <span class="cov0" title="0">{
        problem := false
        for i, rho := range j.AvailabilityAssignments </span><span class="cov0" title="0">{
                if rho != nil &amp;&amp; rho.WorkReport.CoreIndex != uint16(i) </span><span class="cov0" title="0">{
                        problem = true
                }</span>
        }
        // Core 0 : receiving megatron report; Core 1 : receiving fib+trib report
        <span class="cov0" title="0">if problem </span><span class="cov0" title="0">{
                for i, rho := range j.AvailabilityAssignments </span><span class="cov0" title="0">{
                        fmt.Printf("[Node] CheckInvalidCoreIndex i=%d rho: (WorkReportHash:%v) CoreIndex: %d WorkReport: %v\n",
                                i, rho.WorkReport.Hash(), rho.WorkReport.CoreIndex, rho.WorkReport.String())
                }</span>
                <span class="cov0" title="0">fmt.Printf("CheckInvalidCoreIndex: FAILURE\n")
                panic(1111)</span>
        } else<span class="cov0" title="0"> if debug </span><span class="cov0" title="0">{
                fmt.Printf("CheckInvalidCoreIndex: success\n")
        }</span>

}

func (s *StateDB) checkServicesExist(g types.Guarantee) error <span class="cov8" title="1">{
        for _, result := range g.Report.Results </span><span class="cov8" title="1">{
                // check if serviceID exists
                _, ok, err := s.GetService(result.ServiceID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                        return jamerrors.ErrGBadServiceID
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.29
func (s *StateDB) checkGas(g types.Guarantee) error <span class="cov8" title="1">{
        sum_rg := uint64(0)
        for _, results := range g.Report.Results </span><span class="cov8" title="1">{
                sum_rg += results.Gas
        }</span>
        // current gas allocation is unlimited
        <span class="cov8" title="1">if sum_rg &lt;= types.AccumulationGasAllocation </span><span class="cov8" title="1">{
                for _, results := range g.Report.Results </span><span class="cov8" title="1">{
                        serviceID := results.ServiceID
                        if service, ok, err := s.GetService(serviceID); ok &amp;&amp; err == nil </span><span class="cov8" title="1">{
                                gas_limitG := service.GasLimitG
                                if results.Gas &gt;= gas_limitG </span><span class="cov8" title="1">{
                                        return nil
                                }</span> else<span class="cov8" title="1"> {
                                        return jamerrors.ErrGServiceItemTooLow
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">if debugG </span><span class="cov0" title="0">{
                fmt.Printf("sum_rg %d\n", sum_rg)
        }</span>
        <span class="cov8" title="1">return jamerrors.ErrGWorkReportGasTooHigh</span>
}

// v0.5 eq 11.30
func (s *StateDB) getRefineContext() []types.RefineContext <span class="cov0" title="0">{
        x := []types.RefineContext{}
        w := s.getWorkReport()
        for _, report := range w </span><span class="cov0" title="0">{
                x = append(x, report.RefineContext)
        }</span>
        <span class="cov0" title="0">return x</span>
}

// v0.5 eq 11.30
func (s *StateDB) getAvailibleSpecHash() []common.Hash <span class="cov0" title="0">{
        p := []common.Hash{}
        w := s.getWorkReport()
        for _, report := range w </span><span class="cov0" title="0">{
                p = append(p, report.AvailabilitySpec.WorkPackageHash)
        }</span>
        <span class="cov0" title="0">return p</span>
}

// v0.5 eq 11.31
func (s *StateDB) checkLength() error <span class="cov8" title="1">{
        p_w := make(map[common.Hash]common.Hash)
        for _, eg := range s.Block.Extrinsic.Guarantees </span><span class="cov8" title="1">{
                if _, exists := p_w[eg.Report.GetWorkPackageHash()]; exists </span><span class="cov8" title="1">{
                        return jamerrors.ErrGDuplicatePackageTwoReports
                }</span>
                <span class="cov8" title="1">p_w[eg.Report.GetWorkPackageHash()] = eg.Report.AvailabilitySpec.WorkPackageHash</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.32
// TODO:stanley
func (s *StateDB) checkRecentBlock(g types.Guarantee) error <span class="cov8" title="1">{
        refine := g.Report.RefineContext
        anchor := true // CHECK -- I think this should be false
        if refine.Anchor != (common.Hash{}) </span><span class="cov8" title="1">{
                for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                        if block.HeaderHash == refine.Anchor </span><span class="cov8" title="1">{
                                anchor = true
                                break</span>
                        } else<span class="cov8" title="1"> {
                                anchor = false
                        }</span>
                }
        }
        <span class="cov8" title="1">if !anchor </span><span class="cov8" title="1">{
                if debugG </span><span class="cov0" title="0">{
                        fmt.Printf("anchor not in recent blocks refine.Anchor: %v\n", refine.Anchor)
                }</span>
                <span class="cov8" title="1">return jamerrors.ErrGAnchorNotRecent</span>
        }

        <span class="cov8" title="1">stateroot := true // CHECK
        if refine.StateRoot != (common.Hash{}) </span><span class="cov8" title="1">{
                for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                        if block.StateRoot != refine.StateRoot </span><span class="cov8" title="1">{
                                stateroot = false
                        }</span> else<span class="cov8" title="1"> {
                                stateroot = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if !stateroot </span><span class="cov8" title="1">{
                // CHECK
                if debugG </span><span class="cov0" title="0">{
                        fmt.Printf("state root not in recent blocks refine.StateRoot: %v\n", refine.StateRoot)
                }</span>
                <span class="cov8" title="1">return jamerrors.ErrGBadStateRoot</span>
        }
        <span class="cov8" title="1">beefyroot := true
        if refine.BeefyRoot != (common.Hash{}) </span><span class="cov8" title="1">{
                // fmt.Printf("refine.BeefyRoot %v\n", refine.BeefyRoot)
                for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                        mmr := block.B
                        superPeak := mmr.SuperPeak()
                        // fmt.Printf("superPeak %v\n", superPeak)
                        if *superPeak != refine.BeefyRoot </span><span class="cov8" title="1">{
                                beefyroot = false
                        }</span> else<span class="cov8" title="1"> {
                                beefyroot = true
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if !beefyroot </span><span class="cov8" title="1">{
                return jamerrors.ErrGBadBeefyMMRRoot
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.33
func (s *StateDB) checkTimeSlotHeader(g types.Guarantee) error <span class="cov8" title="1">{
        var valid_anchor uint32
        valid_anchor = s.Block.TimeSlot() - types.LookupAnchorMaxAge
        if types.LookupAnchorMaxAge &gt; s.Block.TimeSlot() </span><span class="cov8" title="1">{
                valid_anchor = 0
        }</span>
        <span class="cov8" title="1">if g.Report.RefineContext.LookupAnchorSlot &gt;= valid_anchor </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("lookup anchor slot %d before last %d\n", g.Report.RefineContext.LookupAnchorSlot, valid_anchor)
                return jamerrors.ErrGReportEpochBeforeLast
        }</span>
}

// TODO: v0.5 eq 11.34
// TODO:stanley
func (s *StateDB) checkAncestorSetA(g types.Guarantee) error <span class="cov0" title="0">{
        // ancestor set A
        refine := g.Report.RefineContext
        // x_t := refine.Anchor.timeslot
        timeslot := refine.LookupAnchorSlot
        // A means ancestor set
        ancestorSet := s.AncestorSet
        includeTimeSlot := false
        storeTimeSlot := make([]uint32, 0)
        for _, header := range ancestorSet </span><span class="cov0" title="0">{
                storeTimeSlot = append(storeTimeSlot, header.Slot)
                if header.Slot == timeslot </span><span class="cov0" title="0">{
                        includeTimeSlot = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !includeTimeSlot </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] timeslot %d not in ancestor set %d\n", s.Id, timeslot, storeTimeSlot)
                fmt.Printf("Ancestor Set didn't include the current timeslot\n")
                // TODO: REVIEW Non-standard error
                return fmt.Errorf("ancestor set didn't include the current timeslot")
        }</span>

        // Check if the ancestor set includes the anchor
        <span class="cov0" title="0">includeWorkPackageHash := false
        currentWorkPackage := refine.LookupAnchor
        storeWorkPackageHash := make([]common.Hash, 0)
        if currentWorkPackage != (common.Hash{}) </span><span class="cov0" title="0">{
                for _, header := range ancestorSet </span><span class="cov0" title="0">{
                        headerBytes, err := header.Bytes()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("In checkAncestorSetA header.Bytes error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">headerHash := common.Hash(common.ComputeHash(headerBytes))
                        storeWorkPackageHash = append(storeWorkPackageHash, headerHash)
                        if headerHash == currentWorkPackage </span><span class="cov0" title="0">{
                                includeWorkPackageHash = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !includeWorkPackageHash </span><span class="cov0" title="0">{
                        fmt.Printf("work package hash %v not in ancestor set %v\n", currentWorkPackage, storeWorkPackageHash)
                        fmt.Printf("Ancestor Set didn't include the current work package hash\n")
                        // TODO: REVIEW non-standard error
                        return fmt.Errorf("ancestor set didn't include the current work package hash")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// TODO: v0.5 eq 11.35
func (s *StateDB) getPrereqFromAccumulationQueue() []common.Hash <span class="cov0" title="0">{
        result := []common.Hash{}
        fmt.Printf("s.JamState.AccumulationQueue %v\n", s.JamState.AccumulationQueue)
        for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov0" title="0">{
                for _, queues := range s.JamState.AccumulationQueue[i] </span><span class="cov0" title="0">{
                        for _, workreport := range queues.WorkReports </span><span class="cov0" title="0">{
                                if len(workreport.RefineContext.Prerequisites) != 0 </span><span class="cov0" title="0">{
                                        result = append(result, workreport.RefineContext.Prerequisites...)
                                }</span>
                        }
                }
        }
        <span class="cov0" title="0">return result</span>
}

// TODO: v0.5 eq 11.36
func (s *StateDB) getPrereqFromRho() []common.Hash <span class="cov8" title="1">{
        result := []common.Hash{}
        for _, rho := range s.JamState.AvailabilityAssignments </span><span class="cov8" title="1">{
                if rho != nil &amp;&amp; len(rho.WorkReport.RefineContext.Prerequisites) != 0 </span><span class="cov0" title="0">{
                        result = append(result, rho.WorkReport.RefineContext.Prerequisites...)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// v0.5 eq 11.37
// v0.5.2 eq 11.39
// TODO:stanley ∀ p ∈ 𝒑, p ∉ ⋃{keys(x𝒑) | x ∈ β} ∪ ⋃{x | x ∈ accumulated} ∪ 𝒒 ∪ 𝒂
func (s *StateDB) checkAnyPrereq(g types.Guarantee) error <span class="cov8" title="1">{
        // prereqSetFromQueue := make(map[common.Hash]struct{})
        // for _, hash := range s.getPrereqFromAccumulationQueue() {
        //         prereqSetFromQueue[hash] = struct{}{}
        // }
        workPackageHash := g.Report.AvailabilitySpec.WorkPackageHash
        if workPackageHash == (common.Hash{}) </span><span class="cov0" title="0">{
                // TODO: REVIEW non-standard error
                return fmt.Errorf("invalid work package hash")
        }</span>
        // _, exists := prereqSetFromQueue[workPackageHash]
        // if exists {
        //         fmt.Printf("invalid prerequisite work package(from queue), core %v, package %v", g.Report.CoreIndex, g.Report.GetWorkPackageHash())
        //         return jamerrors.ErrGDuplicatePackageRecentHistory
        // }
        <span class="cov8" title="1">for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                if len(block.Reported) != 0 </span><span class="cov8" title="1">{
                        for _, segmentRootLookup := range block.Reported </span><span class="cov8" title="1">{
                                if segmentRootLookup.WorkPackageHash == workPackageHash </span><span class="cov8" title="1">{
                                        return jamerrors.ErrGDuplicatePackageRecentHistory
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">prereqSetFromAccumulationHistory := make(map[common.Hash]struct{})
        for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov8" title="1">{
                for _, hash := range s.JamState.AccumulationHistory[i].WorkPackageHash </span><span class="cov0" title="0">{
                        prereqSetFromAccumulationHistory[hash] = struct{}{}
                }</span>
        }
        <span class="cov8" title="1">_, exists := prereqSetFromAccumulationHistory[workPackageHash]
        if exists </span><span class="cov0" title="0">{
                // TODO: REVIEW non-standard error
                return fmt.Errorf("invalid prerequisite work package(from accumulation history), core %v, package %v", g.Report.CoreIndex, g.Report.GetWorkPackageHash())
        }</span>

        // 𝒒:Means the workPackageHash should not be in the ready work package set
        <span class="cov8" title="1">accumulateWorkPackage := s.AvailableWorkReport
        readyWorkPackagesHashes := s.GetReadyQueue(accumulateWorkPackage)
        readyWorkPackagesHashMap := make(map[common.Hash]struct{})
        for _, hash := range readyWorkPackagesHashes </span><span class="cov0" title="0">{
                readyWorkPackagesHashMap[hash] = struct{}{}
        }</span>
        <span class="cov8" title="1">_, exists = readyWorkPackagesHashMap[workPackageHash]
        if exists </span><span class="cov0" title="0">{
                // TODO: REVIEW non-standard error
                return fmt.Errorf("invalid prerequisite work package(from ready work package), core %v, package %v", g.Report.CoreIndex, g.Report.GetWorkPackageHash())
        }</span>

        // 𝒂:This is a collection of "assigned" work packages.
        <span class="cov8" title="1">prereqSetFromRho := make(map[common.Hash]struct{})
        for _, hash := range s.getPrereqFromRho() </span><span class="cov0" title="0">{
                prereqSetFromRho[hash] = struct{}{}
        }</span>
        <span class="cov8" title="1">_, exists = prereqSetFromRho[workPackageHash]
        if exists </span><span class="cov0" title="0">{
                // TODO: REVIEW non-standard error
                return fmt.Errorf("invalid prerequisite work package(from rho), core %v, package %v", g.Report.CoreIndex, g.Report.GetWorkPackageHash())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.38

// this function is for the making block
func (s *StateDB) checkPrereq(g types.Guarantee, EGs []types.Guarantee) error <span class="cov8" title="1">{
        prereqSet := make(map[common.Hash]struct{})
        p := []common.Hash{}
        if len(g.Report.RefineContext.Prerequisites) != 0 </span><span class="cov8" title="1">{
                p = append(p, g.Report.RefineContext.Prerequisites...)
        }</span>
        <span class="cov8" title="1">for _, lookupItem := range g.Report.SegmentRootLookup </span><span class="cov8" title="1">{
                p = append(p, lookupItem.WorkPackageHash)
        }</span>

        <span class="cov8" title="1">for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                for _, segmentRootLookup := range block.Reported </span><span class="cov8" title="1">{
                        prereqSet[segmentRootLookup.WorkPackageHash] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">for _, guarantee := range EGs </span><span class="cov8" title="1">{
                workPackageHash := guarantee.Report.AvailabilitySpec.WorkPackageHash
                prereqSet[workPackageHash] = struct{}{}
        }</span>

        <span class="cov8" title="1">if len(p) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, hash := range p </span><span class="cov8" title="1">{
                exists := false
                for key := range prereqSet </span><span class="cov8" title="1">{
                        if hash == key </span><span class="cov8" title="1">{
                                exists = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !exists </span><span class="cov8" title="1">{
                        return jamerrors.ErrGDependencyMissing
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.39
func getPresentBlock(s *StateDB) types.SegmentRootLookup <span class="cov8" title="1">{
        p := types.SegmentRootLookup{}
        for _, block := range s.JamState.RecentBlocks </span><span class="cov8" title="1">{
                for _, lookupItem := range block.Reported </span><span class="cov8" title="1">{
                        tmeItem := types.SegmentRootLookupItem{
                                WorkPackageHash: lookupItem.WorkPackageHash,
                                SegmentRoot:     lookupItem.SegmentRoot,
                        }
                        p = append(p, tmeItem)
                }</span>
        }
        <span class="cov8" title="1">return p</span>
}

// v0.5 eq 11.40
// v0.5.2 eq 11.42
// TODO:stanley
func (s *StateDB) checkRecentWorkPackage(g types.Guarantee, egs []types.Guarantee) error <span class="cov8" title="1">{
        currentSegmentRootLookUp := g.Report.SegmentRootLookup
        if len(currentSegmentRootLookUp) == 0 </span><span class="cov8" title="1">{
                // fmt.Printf("Error currentSegmentRootLookUp is nil, must have segmentRootLookup into it!\n")
                return nil
        }</span>

        // Combine the present block and the recent blocks
        <span class="cov8" title="1">presentBlockSegmentRootLookup := getPresentBlock(s)
        if len(s.JamState.RecentBlocks) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("Error s.JamState.RecentBlocks is nil, must have recentblock into it!\n")
                return nil
        }</span>
        // for _, block := range s.JamState.RecentBlocks {
        //         for _, segmentRootLookupItem := range block.Reported {
        //                 tmpsegmentRootLookupItem := types.SegmentRootLookupItem{
        //                         WorkPackageHash: segmentRootLookupItem.WorkPackageHash,
        //                         SegmentRoot:     segmentRootLookupItem.SegmentRoot,
        //                 }
        //                 presentBlockSegmentRootLookup = append(presentBlockSegmentRootLookup, tmpsegmentRootLookupItem)
        //         }
        // }
        <span class="cov8" title="1">if debugG </span><span class="cov0" title="0">{
                fmt.Printf("presentBlockSegmentRootLookup: %v\n", presentBlockSegmentRootLookup)
                fmt.Printf("currentSegmentRootLookUp: %v\n", currentSegmentRootLookUp)
        }</span>
        // Check presentBlockHash2Hash include currentHash2Hash or not
        <span class="cov8" title="1">segmentLookUpIncluded := make([]bool, len(currentSegmentRootLookUp))
        for i, currentSegmentRootLookup := range currentSegmentRootLookUp </span><span class="cov8" title="1">{
                for _, segmentRootLookup := range presentBlockSegmentRootLookup </span><span class="cov8" title="1">{
                        if segmentRootLookup.WorkPackageHash == currentSegmentRootLookup.WorkPackageHash </span><span class="cov8" title="1">{
                                if segmentRootLookup.SegmentRoot != currentSegmentRootLookup.SegmentRoot </span><span class="cov8" title="1">{
                                        return jamerrors.ErrGSegmentRootLookupInvalidUnexpectedValue
                                }</span> else<span class="cov8" title="1"> {
                                        segmentLookUpIncluded[i] = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">segmentLookUpIncluded[i] = false</span>
                }
        }
        <span class="cov8" title="1">for _, guarantee := range egs </span><span class="cov8" title="1">{
                wp_hash := guarantee.Report.AvailabilitySpec.WorkPackageHash
                segment_root := guarantee.Report.AvailabilitySpec.ExportedSegmentRoot
                for i, lookup := range currentSegmentRootLookUp </span><span class="cov8" title="1">{
                        if wp_hash == lookup.WorkPackageHash </span><span class="cov8" title="1">{
                                if segment_root != lookup.SegmentRoot </span><span class="cov0" title="0">{
                                        return jamerrors.ErrGSegmentRootLookupInvalidUnexpectedValue
                                }</span> else<span class="cov8" title="1"> {
                                        segmentLookUpIncluded[i] = true
                                }</span>
                        }
                }
        }

        // Check if all the segmentRootLookup are included
        <span class="cov8" title="1">for _, included := range segmentLookUpIncluded </span><span class="cov8" title="1">{
                if !included </span><span class="cov8" title="1">{
                        return jamerrors.ErrGSegmentRootLookupInvalidNotRecentBlocks
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// v0.5 eq 11.41
func (s *StateDB) checkCodeHash(g types.Guarantee) error <span class="cov8" title="1">{
        //prior_trie := s.CopyTrieState(s.StateRoot)
        for _, result := range g.Report.Results </span><span class="cov8" title="1">{
                serviceID := result.ServiceID
                codeHash := result.CodeHash
                service, ok, err := s.GetService(serviceID)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                        return jamerrors.ErrGBadCodeHash
                }</span>
                <span class="cov8" title="1">if codeHash != service.CodeHash </span><span class="cov8" title="1">{
                        return jamerrors.ErrGBadCodeHash
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *StateDB) IsPreviousValidators(eg_timeslot uint32) bool <span class="cov8" title="1">{
        curr_timeslot := s.GetTimeslot()
        assignment_idx := curr_timeslot / types.ValidatorCoreRotationPeriod
        previous_assignment_idx := assignment_idx - 1
        eg_assignment_idx := eg_timeslot / types.ValidatorCoreRotationPeriod
        if eg_assignment_idx == curr_timeslot </span><span class="cov0" title="0">{
                return false
        }</span> else<span class="cov8" title="1"> if eg_assignment_idx == previous_assignment_idx </span><span class="cov8" title="1">{
                if eg_timeslot/types.EpochLength+1 == curr_timeslot/types.EpochLength </span><span class="cov8" title="1">{
                        return true
                }</span> else<span class="cov0" title="0"> {
                        return false
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package statedb

import (
        "encoding/json"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/trie"
        "github.com/colorfulnotion/jam/types"
)

// C2
type RecentBlocks []Beta_state

type Beta_state struct {
        HeaderHash common.Hash             `json:"header_hash"`
        B          trie.MMR                `json:"mmr"`
        StateRoot  common.Hash             `json:"state_root"`
        Reported   types.SegmentRootLookup `json:"report"` // Use the custom type
}

func (b *Beta_state) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                HeaderHash common.Hash             `json:"header_hash"`
                B          trie.MMR                `json:"mmr"`
                StateRoot  common.Hash             `json:"state_root"`
                Report     types.SegmentRootLookup `json:"reported"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.HeaderHash = s.HeaderHash
        b.B = s.B
        b.StateRoot = s.StateRoot
        b.Reported = s.Report
        return nil</span>
}

func (b Beta_state) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(struct {
                HeaderHash common.Hash                   `json:"header_hash"`
                B          trie.MMR                      `json:"mmr"`
                StateRoot  common.Hash                   `json:"state_root"`
                Report     []types.SegmentRootLookupItem `json:"reported"`
        }{
                HeaderHash: b.HeaderHash,
                B:          b.B,
                StateRoot:  b.StateRoot,
                Report:     b.Reported,
        })
}</span>

// Recent History : see Section 7
func (s *StateDB) ApplyStateRecentHistory(blk *types.Block, accumulationRoot *common.Hash) <span class="cov0" title="0">{
        // Eq 83 n
        // Eq 83 n.p -- aggregate all the workpackagehashes of the guarantees
        reported := []types.SegmentRootLookupItem{}
        for _, g := range blk.Guarantees() </span><span class="cov0" title="0">{
                temReported := types.SegmentRootLookupItem{
                        WorkPackageHash: g.Report.AvailabilitySpec.WorkPackageHash,
                        SegmentRoot:     g.Report.AvailabilitySpec.ExportedSegmentRoot,
                }
                reported = append(reported, temReported)
        }</span>

        <span class="cov0" title="0">preRecentBlocks := s.JamState.RecentBlocks
        if len(preRecentBlocks) &gt; 0 </span><span class="cov0" title="0">{
                preRecentBlocks[len(preRecentBlocks)-1].StateRoot = s.StateRoot // ****
        }</span>

        // Eq 83 n.b
        <span class="cov0" title="0">mmr := trie.NewMMR()
        if len(preRecentBlocks) &gt; 0 </span><span class="cov0" title="0">{
                mmr.Peaks = preRecentBlocks[len(preRecentBlocks)-1].B.Peaks
        }</span>
        <span class="cov0" title="0">mmr.Append(accumulationRoot)
        n := Beta_state{
                Reported:   reported,          // p
                HeaderHash: blk.Header.Hash(), // h
                B:          *mmr,              // b
                StateRoot:  common.Hash{},     // this will become the POSTERIOR stateroot in the NEXT update, updated via **** above
        }

        // Eq 84 β' ≡ β† ++ n (last H=types.RecentHistorySize)
        postRecentBlocks := append(preRecentBlocks, n)
        if len(postRecentBlocks) &gt; types.RecentHistorySize </span><span class="cov0" title="0">{
                postRecentBlocks = postRecentBlocks[1 : types.RecentHistorySize+1]
        }</span>
        <span class="cov0" title="0">s.JamState.RecentBlocks = postRecentBlocks</span>
        // return
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package statedb

import (
        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

// v0.5.0 (11.18)
func Rotation(c []uint32, n uint32) []uint32 <span class="cov8" title="1">{
        result := make([]uint32, len(c))
        for i, x := range c </span><span class="cov8" title="1">{
                result[i] = (x + n) % types.TotalCores
        }</span>
        <span class="cov8" title="1">return result</span>
}

// v0.5.0 (11.19)
func Permute(e common.Hash, t uint32) []uint32 <span class="cov8" title="1">{
        cores := make([]uint32, types.TotalValidators)
        for i := 0; i &lt; types.TotalValidators; i++ </span><span class="cov8" title="1">{
                cores[i] = uint32(types.TotalCores * i / types.TotalValidators)
        }</span>
        <span class="cov8" title="1">cores = ShuffleFromHash(cores, e)
        uint16Cores := make([]uint32, len(cores))
        for i, x := range cores </span><span class="cov8" title="1">{
                uint16Cores[i] = uint32(x)
        }</span>
        <span class="cov8" title="1">return Rotation(uint16Cores, (t%types.EpochLength)/types.ValidatorCoreRotationPeriod)</span>
}

// v0.5.0 (11.20) + (11.21)
// RotateGuarantors computes GuarantorAssignments and PreviousGuarantorAssignments based
// on SafroleState (a) Entropy[2] or Entropy[3] and (b) the current Timeslot.
func (s *StateDB) RotateGuarantors() <span class="cov8" title="1">{
        // uses (a) entropy[2] and timesslot to update s.GuarantorAssignments
        assignments := make([]types.GuarantorAssignment, 0)
        entropy := s.JamState.SafroleState.Entropy[2]
        t := s.JamState.SafroleState.Timeslot
        //fmt.Printf("[N%d] t=%d RotateGuarantors before rototation s.PreviousGuarantorAssignments=%x | s.GuarantorAssignments=%x\n", s.Id, t, s.PreviousGuarantorAssignments, s.GuarantorAssignments)
        cores := Permute(entropy, t)
        for i, kappa := range s.JamState.SafroleState.CurrValidators </span><span class="cov8" title="1">{
                assignments = append(assignments, types.GuarantorAssignment{
                        CoreIndex: uint16(cores[i]),
                        Validator: kappa,
                })
        }</span>
        <span class="cov8" title="1">s.GuarantorAssignments = make([]types.GuarantorAssignment, len(assignments))
        copy(s.GuarantorAssignments, assignments)

        assignments = make([]types.GuarantorAssignment, 0)
        t = s.JamState.SafroleState.Timeslot - types.ValidatorCoreRotationPeriod
        if (s.JamState.SafroleState.Timeslot-types.ValidatorCoreRotationPeriod)/types.EpochLength == s.JamState.SafroleState.Timeslot/types.EpochLength </span><span class="cov8" title="1">{
                cores := Permute(s.JamState.SafroleState.Entropy[2], t)
                for i, kappa := range s.JamState.SafroleState.CurrValidators </span><span class="cov8" title="1">{
                        assignments = append(assignments, types.GuarantorAssignment{
                                CoreIndex: uint16(cores[i]),
                                Validator: kappa,
                        })
                }</span>
        } else<span class="cov8" title="1"> {
                cores := Permute(s.JamState.SafroleState.Entropy[3], t)
                if len(s.JamState.SafroleState.PrevValidators) == 0 </span><span class="cov0" title="0">{
                        panic("PrevValidators is empty")</span>
                }
                <span class="cov8" title="1">for i, lambda := range s.JamState.SafroleState.PrevValidators </span><span class="cov8" title="1">{
                        assignments = append(assignments, types.GuarantorAssignment{
                                CoreIndex: uint16(cores[i]),
                                Validator: lambda,
                        })
                }</span>
        }
        <span class="cov8" title="1">s.PreviousGuarantorAssignments = make([]types.GuarantorAssignment, len(assignments))
        copy(s.PreviousGuarantorAssignments, assignments)</span>
        //fmt.Printf("[N%d] t=%d RotateGuarantors after rototation s.PreviousGuarantorAssignments=%x | s.GuarantorAssignments=%x\n", s.Id, t, s.PreviousGuarantorAssignments, s.GuarantorAssignments)

}

// this function are using the timeslot from block header and the entropy from safrole state(shift if needed). To Calculate the guarantor assignments
func (s *StateDB) CaculateAssignments(shift_bool bool) (PreviousGuarantorAssignments []types.GuarantorAssignment, GuarantorAssignments []types.GuarantorAssignment) <span class="cov0" title="0">{

        // uses (a) entropy[2] and timesslot to update s.GuarantorAssignments
        assignments := make([]types.GuarantorAssignment, 0)
        entropy := s.JamState.SafroleState.Entropy[2]
        if shift_bool </span><span class="cov0" title="0">{
                entropy = s.JamState.SafroleState.Entropy[1]
        }</span>
        <span class="cov0" title="0">t := s.Block.Header.Slot
        //fmt.Printf("[N%d] t=%d RotateGuarantors before rototation s.PreviousGuarantorAssignments=%x | s.GuarantorAssignments=%x\n", s.Id, t, s.PreviousGuarantorAssignments, s.GuarantorAssignments)
        cores := Permute(entropy, t)
        for i, kappa := range s.JamState.SafroleState.CurrValidators </span><span class="cov0" title="0">{
                assignments = append(assignments, types.GuarantorAssignment{
                        CoreIndex: uint16(cores[i]),
                        Validator: kappa,
                })
        }</span>

        <span class="cov0" title="0">prev_assignments := make([]types.GuarantorAssignment, 0)
        t = s.Block.Header.Slot - types.ValidatorCoreRotationPeriod
        prev_using_entropy := 2
        if shift_bool </span><span class="cov0" title="0">{
                prev_using_entropy = 1
        }</span>
        <span class="cov0" title="0">if (s.JamState.SafroleState.Timeslot-types.ValidatorCoreRotationPeriod)/types.EpochLength == s.JamState.SafroleState.Timeslot/types.EpochLength </span><span class="cov0" title="0">{
                cores := Permute(s.JamState.SafroleState.Entropy[prev_using_entropy], t)
                for i, kappa := range s.JamState.SafroleState.CurrValidators </span><span class="cov0" title="0">{
                        prev_assignments = append(prev_assignments, types.GuarantorAssignment{
                                CoreIndex: uint16(cores[i]),
                                Validator: kappa,
                        })
                }</span>
        } else<span class="cov0" title="0"> {
                cores := Permute(s.JamState.SafroleState.Entropy[prev_using_entropy+1], t)
                for i, lambda := range s.JamState.SafroleState.PrevValidators </span><span class="cov0" title="0">{
                        prev_assignments = append(prev_assignments, types.GuarantorAssignment{
                                CoreIndex: uint16(cores[i]),
                                Validator: lambda,
                        })
                }</span>
        }
        <span class="cov0" title="0">return prev_assignments, assignments</span>

}

func (s *StateDB) GuarantorsAssignmentsPrint() <span class="cov0" title="0">{
        sf := s.GetSafrole()
        fmt.Printf("CurrGuarantorAssignments:\n")
        for _, v := range s.GuarantorAssignments </span><span class="cov0" title="0">{
                validator_index := sf.GetCurrValidatorIndex(v.Validator.Ed25519)
                if validator_index == -1 </span><span class="cov0" title="0">{
                        fmt.Printf("Validator not found for %v\n", v.Validator.Ed25519)
                        continue</span>
                }
                <span class="cov0" title="0">core_index := v.CoreIndex
                fmt.Printf("CoreIndex: %v =&gt; Validator: %v, key: %v\n", core_index, validator_index, v.Validator.Ed25519)</span>
        }
        <span class="cov0" title="0">fmt.Printf("PrevGuarantorAssignments:\n")
        if (s.JamState.SafroleState.Timeslot-types.ValidatorCoreRotationPeriod)/types.EpochLength == s.JamState.SafroleState.Timeslot/types.EpochLength </span><span class="cov0" title="0">{
                fmt.Printf("using entropy[2]\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("using entropy[3]\n")
        }</span>
        <span class="cov0" title="0">if len(s.PreviousGuarantorAssignments) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("PreviousGuarantorAssignments is empty\n")
        }</span>
        <span class="cov0" title="0">for _, v := range s.PreviousGuarantorAssignments </span><span class="cov0" title="0">{
                validator_index := sf.GetCurrValidatorIndex(v.Validator.Ed25519)
                if (s.JamState.SafroleState.Timeslot-types.ValidatorCoreRotationPeriod)/types.EpochLength &lt; s.JamState.SafroleState.Timeslot/types.EpochLength </span><span class="cov0" title="0">{
                        validator_index = sf.GetPrevValidatorIndex(v.Validator.Ed25519)
                }</span>
                <span class="cov0" title="0">if validator_index == -1 </span><span class="cov0" title="0">{
                        fmt.Printf("Validator not found for %v\n", v.Validator.Ed25519)
                        continue</span>
                }
                <span class="cov0" title="0">core_index := v.CoreIndex
                fmt.Printf("CoreIndex: %v =&gt; Validator: %v, key: %v\n", core_index, validator_index, v.Validator.Ed25519)</span>
        }
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package statedb

import (
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/bandersnatch"
        "github.com/colorfulnotion/jam/types"

        "encoding/json"
        "errors"
        "sort"
        "sync"
        "time"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/jamerrors"
)

type SafroleHeader struct {
        ParentHash         common.Hash
        PriorStateRoot     common.Hash
        ExtrinsicHash      common.Hash
        TimeSlot           uint32
        EpochMark          *types.EpochMark
        WinningTicketsMark []*types.TicketBody
        VerdictsMarkers    *types.VerdictMarker
        OffenderMarkers    *types.OffenderMarker
        BlockAuthorKey     uint16
        VRFSignature       []byte
        BlockSeal          []byte
}

type SafroleAccumulator struct {
        Id      common.Hash `json:"id"`
        Attempt int         `json:"attempt"`
}

// 6.1 protocol configuration
type SInput struct {
        Slot       uint32         `json:"slot"`
        Entropy    common.Hash    `json:"entropy"`
        Extrinsics []types.Ticket `json:"extrinsic"`
}

// Bytes serializes the SafroleBasicState to a byte slice
func (s *SafroleBasicState) Bytes() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(s)
}</span>

func SafroleBasicStateFromBytes(data []byte) (SafroleBasicState, error) <span class="cov0" title="0">{
        var sb SafroleBasicState
        err := json.Unmarshal(data, &amp;sb)
        return sb, err
}</span>

func (s *SafroleState) GetNextRingCommitment() ([]byte, error) <span class="cov0" title="0">{
        ringsetBytes := s.GetRingSet("Next")
        if len(ringsetBytes) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Not ready yet")
        }</span>
        <span class="cov0" title="0">nextRingCommitment, err := bandersnatch.GetRingCommitment(ringsetBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return nextRingCommitment, err</span>
}

func (s *SafroleState) GetSafroleBasicState() SafroleBasicState <span class="cov0" title="0">{
        nextRingCommitment, _ := s.GetNextRingCommitment()
        return SafroleBasicState{
                GammaK: []types.Validator(s.NextValidators),
                GammaA: s.NextEpochTicketsAccumulator,
                GammaS: s.TicketsOrKeys,
                GammaZ: nextRingCommitment,
        }
}</span>

func (s *SafroleState) GetNextN2() common.Hash <span class="cov0" title="0">{
        _, currphase := s.EpochAndPhase(uint32(s.Timeslot))
        if currphase == types.EpochLength-1 </span><span class="cov0" title="0">{
                return s.Entropy[1]
        }</span>
        <span class="cov0" title="0">return s.Entropy[2]</span>
}

// Extrinsic is submitted by authorities, which are added to Safrole State in TicketsAccumulator if valid
type Extrinsic struct {
        Attempt   uint8                                 `json:"attempt"`
        Signature [types.ExtrinsicSignatureInBytes]byte `json:"signature"`
}

// 6.5.3. Ticket Envelope
type TicketEnvelope struct {
        Id            common.Hash                           //not part of the official TicketEnvelope struct
        Attempt       uint8                                 //Index associated to the ticket.
        Extra         []byte                                //additional data for user-defined applications.
        RingSignature [types.ExtrinsicSignatureInBytes]byte //ring signature of the envelope data (attempt &amp; extra)
}

type Entropy [types.EntropySize]common.Hash

type SafroleState struct {
        Id             uint16 `json:"Id"`
        EpochFirstSlot uint32 `json:"EpochFirstSlot"`

        Timeslot uint32 `json:"timeslot"`

        Entropy Entropy `json:"entropy"`

        // 4 authorities[pre, curr, next, designed]
        PrevValidators     types.Validators `json:"prev_validators"`
        CurrValidators     types.Validators `json:"curr_validators"`
        NextValidators     types.Validators `json:"next_validators"`
        DesignedValidators types.Validators `json:"designed_validators"`

        // Accumulator of tickets, modified with Extrinsics to hold ORDERED array of Tickets
        NextEpochTicketsAccumulator []types.TicketBody `json:"next_tickets_accumulator"` //gamma_a
        TicketsOrKeys               TicketsOrKeys      `json:"tickets_or_keys"`

        // []bandersnatch.ValidatorKeySet
        TicketsVerifierKey []byte `json:"tickets_verifier_key"`
}

func NewSafroleState() *SafroleState <span class="cov8" title="1">{
        return &amp;SafroleState{
                Id: 9999,
                // Timeslot:           uint32(common.ComputeCurrentJCETime()),
                Timeslot: common.ComputeTimeUnit(types.TimeUnitMode),

                Entropy:            Entropy{},
                PrevValidators:     []types.Validator{},
                CurrValidators:     []types.Validator{},
                NextValidators:     []types.Validator{},
                DesignedValidators: []types.Validator{},
                TicketsOrKeys:      TicketsOrKeys{},
                TicketsVerifierKey: []byte{},
        }
}</span>

func VerifyEpochMarker(epochMark *types.EpochMark) (bool, error) <span class="cov0" title="0">{
        //STUB
        return true, nil
}</span>

func (s *SafroleState) GenerateEpochMarker() *types.EpochMark <span class="cov0" title="0">{
        var nextValidators [6]common.Hash
        for i, v := range s.NextValidators </span><span class="cov0" title="0">{
                nextValidators[i] = v.GetBandersnatchKey().Hash()
        }</span>
        //fmt.Printf("nextValidators Len=%v\n", nextValidators)
        <span class="cov0" title="0">return &amp;types.EpochMark{ // see https://graypaper.fluffylabs.dev/#/911af30/0e72030e7203
                Entropy:        s.Entropy[0], // this is eta1' = eta0
                TicketsEntropy: s.Entropy[1], // this is eta2' = eta1
                Validators:     nextValidators,
        }</span>
}

func VerifyWinningMarker(winning_marker [types.EpochLength]*types.TicketBody, expected_marker []*types.TicketBody) (bool, error) <span class="cov0" title="0">{
        // Check if both slices have the same length
        if len(winning_marker) != len(expected_marker) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("length mismatch: winning_marker has %d elements, expected_marker has %d elements", len(winning_marker), len(expected_marker))
        }</span>

        <span class="cov0" title="0">for i := range winning_marker </span><span class="cov0" title="0">{
                if winning_marker[i].Id != expected_marker[i].Id || winning_marker[i].Attempt != expected_marker[i].Attempt </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}

func (s *SafroleState) InTicketAccumulator(ticketID common.Hash) bool <span class="cov0" title="0">{
        for _, t := range s.NextEpochTicketsAccumulator </span><span class="cov0" title="0">{
                if t.Id == ticketID </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// func (s *SafroleState) GenerateWinningMarker() (*types.TicketsMark, error) {
func (s *SafroleState) GenerateWinningMarker() ([]*types.TicketBody, error) <span class="cov0" title="0">{
        tickets := s.NextEpochTicketsAccumulator
        if len(tickets) != types.EpochLength </span><span class="cov0" title="0">{
                //accumulator should keep exactly EpochLength ticket
                return nil, fmt.Errorf("Invalid Ticket size")
        }</span>
        <span class="cov0" title="0">outsidein_tickets := s.computeTicketSlotBinding(tickets)
        return outsidein_tickets, nil</span>
}

type SOutput struct {
        Ok *struct {
                EpochMark   *types.EpochMark   `json:"epoch_mark"`
                TicketsMark *types.TicketsMark `json:"tickets_mark"`
        } `json:"ok,omitempty"`
        Err *string `json:"err,omitempty" ` // ErrorCode
}

// StateDB STF Errors
const (
        errEpochFirstSlotNotMet                = "Fail: EpochFirst not met"
        errExtrinsicWithMoreTicketsThanAllowed = "Fail: Submit an extrinsic with more tickets than allowed."
        errInvalidWinningMarker                = "Fail: Invalid winning marker"
)

type ClaimData struct {
        Slot             uint32 `json:"slot"`
        AuthorityIndex   uint32 `json:"authority_index"`
        RandomnessSource []byte `json:"randomness_source"`
}

func ComputeEpochAndPhase(ts, Epoch0Timestamp uint32) (currentEpoch uint32, currentPhase uint32) <span class="cov0" title="0">{

        if types.TimeUnitMode == "TimeStamp" </span><span class="cov0" title="0">{
                if ts &lt; Epoch0Timestamp || ts == 0xFFFFFFFF </span><span class="cov0" title="0">{
                        currentEpoch = 0
                        currentPhase = 0
                        return currentEpoch, currentPhase
                }</span>
        } else<span class="cov0" title="0"> if types.TimeUnitMode == "TimeSlot" </span><span class="cov0" title="0">{
                if ts &lt; Epoch0Timestamp/types.SecondsPerSlot </span><span class="cov0" title="0">{
                        currentEpoch = 0
                        currentPhase = 0
                        return currentEpoch, currentPhase
                }</span> else<span class="cov0" title="0"> {
                        currentEpoch = (ts - Epoch0Timestamp/types.SecondsPerSlot) / types.EpochLength
                        currentPhase = (ts - Epoch0Timestamp/types.SecondsPerSlot) % types.EpochLength
                        return currentEpoch, currentPhase
                }</span>
        } else<span class="cov0" title="0"> if types.TimeUnitMode == "JAM" </span><span class="cov0" title="0">{
                if ts &lt; Epoch0Timestamp/types.SecondsPerSlot </span><span class="cov0" title="0">{
                        currentEpoch = 0
                        currentPhase = 0
                        return currentEpoch, currentPhase
                }</span>
                <span class="cov0" title="0">currentEpoch = ts / types.EpochLength
                currentPhase = ts % types.EpochLength
                return currentEpoch, currentPhase</span>

        } else<span class="cov0" title="0"> {
                return 0, 0
        }</span>

        <span class="cov0" title="0">return 0, 0</span>
}

func (s *SafroleState) EpochAndPhase(ts uint32) (currentEpoch int32, currentPhase uint32) <span class="cov8" title="1">{
        if types.TimeUnitMode == "TimeStamp" </span><span class="cov0" title="0">{
                if ts &lt; s.EpochFirstSlot </span><span class="cov0" title="0">{
                        currentEpoch = -1
                        currentPhase = 0
                        return
                }</span>
                <span class="cov0" title="0">currentEpoch = int32((ts - s.EpochFirstSlot) / (types.SecondsPerSlot * types.EpochLength)) // eg. / 60
                currentPhase = ((ts - s.EpochFirstSlot) % (types.SecondsPerSlot * types.EpochLength)) / types.SecondsPerSlot
                return</span>
        } else<span class="cov8" title="1"> if types.TimeUnitMode == "TimeSlot" </span><span class="cov0" title="0">{
                realEpochFirstSlot := s.EpochFirstSlot / uint32(types.SecondsPerSlot)
                if ts &lt; realEpochFirstSlot </span><span class="cov0" title="0">{
                        currentEpoch = -1
                        currentPhase = 0
                        return
                }</span>
                <span class="cov0" title="0">currentEpoch = int32((ts - realEpochFirstSlot) / types.EpochLength) // eg. / 60
                currentPhase = ((ts - realEpochFirstSlot) % types.EpochLength)
                return</span>
        } else<span class="cov8" title="1"> if types.TimeUnitMode == "JAM" </span><span class="cov8" title="1">{
                realEpochFirstSlot := s.EpochFirstSlot / uint32(types.SecondsPerSlot)
                if ts &lt; realEpochFirstSlot </span><span class="cov0" title="0">{
                        currentEpoch = -1
                        currentPhase = 0
                        return
                }</span>

                <span class="cov8" title="1">currentEpoch = int32(ts / types.EpochLength) // eg. / 60
                currentPhase = ts % types.EpochLength
                return</span>
        } else<span class="cov0" title="0"> {
                return -1, 0
        }</span>

}

func (s *SafroleState) IsNewEpoch(currCJE uint32) bool <span class="cov0" title="0">{
        prevEpoch, _ := s.EpochAndPhase(uint32(s.Timeslot))
        currEpoch, _ := s.EpochAndPhase(currCJE)
        return currEpoch &gt; prevEpoch
}</span>

// used for detecting the end of submission period
func (s *SafroleState) IseWinningMarkerNeeded(currCJE uint32) bool <span class="cov0" title="0">{
        prevEpoch, prevPhase := s.EpochAndPhase(uint32(s.Timeslot))
        currEpoch, currPhase := s.EpochAndPhase(currCJE)
        if currEpoch == prevEpoch &amp;&amp; prevPhase &lt; types.TicketSubmissionEndSlot &amp;&amp; types.TicketSubmissionEndSlot &lt;= currPhase &amp;&amp; len(s.NextEpochTicketsAccumulator) == types.EpochLength </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (s *SafroleState) IsTicketSubmissionClosed(currJCE uint32) bool <span class="cov8" title="1">{
        _, currPhase := s.EpochAndPhase(currJCE)
        if currPhase &gt;= types.TicketSubmissionEndSlot </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func CalculateEpochAndPhase(currentTimeslot, priorTimeslot uint32) (currentEpoch, priorEpoch, currentPhase, priorPhase uint32) <span class="cov0" title="0">{
        currentEpoch = currentTimeslot / types.EpochLength
        currentPhase = currentTimeslot % types.EpochLength
        priorEpoch = priorTimeslot / types.EpochLength
        priorPhase = priorTimeslot % types.EpochLength
        return
}</span>

func (s *SafroleState) GetFreshRandomness(vrfSig []byte) (common.Hash, error) <span class="cov0" title="0">{
        fresh_randomness, err := bandersnatch.VRFSignedOutput(vrfSig)
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, err
        }</span>
        <span class="cov0" title="0">return common.BytesToHash(fresh_randomness), nil</span>
}

func (s *SafroleState) ComputeCurrRandomness(fresh_randomness common.Hash) common.Hash <span class="cov0" title="0">{
        // η0 Entropy[0] CURRENT randomness accumulator (see sec 6.10).
        // randomness_buffer[0] = BLAKE2(CONCAT(randomness_buffer[0], fresh_randomness));
        randomness_buffer0 := s.Entropy[0].Bytes()

        // Compute BLAKE2 hash of the combined data
        new_randomness := common.Blake2Hash(append(randomness_buffer0, fresh_randomness.Bytes()...))
        return new_randomness
}</span>

// 6.5.1. Ticket Identifier (Primary Method)
// ticketSealVRFInput constructs the input for VRF based on target epoch randomness and attempt.
func (s *SafroleState) ticketSealVRFInput(targetEpochRandomness common.Hash, attempt uint8) []byte <span class="cov8" title="1">{
        // Concatenate sassafrasTicketSeal, targetEpochRandomness, and attemptBytes
        ticket_vrf_input := append(append([]byte(types.X_T), targetEpochRandomness.Bytes()...), []byte{byte(attempt &amp; 0xF)}...)
        return ticket_vrf_input
}</span>

func (s *SafroleState) computeTicketID(authority_secret_key bandersnatch.BanderSnatchSecret, ticket_vrf_input []byte) (common.Hash, error) <span class="cov0" title="0">{
        //ticket_id := bandersnatch.VRFOutput(authority_secret_key, ticket_vrf_input)
        auxData := []byte{}
        ticket_id, err := bandersnatch.VRFOutput(authority_secret_key, ticket_vrf_input, auxData)
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, fmt.Errorf("signTicket failed")
        }</span>
        <span class="cov0" title="0">return common.BytesToHash(ticket_id), nil</span>
}

func (s *SafroleState) EntropyToBytes() []byte <span class="cov0" title="0">{
        var entropyBytes []byte
        for _, hash := range s.Entropy </span><span class="cov0" title="0">{
                entropyBytes = append(entropyBytes, hash.Bytes()...)
        }</span>
        <span class="cov0" title="0">return entropyBytes</span>
}

func EntropyFromBytes(data []byte) ([]common.Hash, error) <span class="cov0" title="0">{
        if len(data)%32 != 0 || len(data)/32 != 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid data length for entropy")
        }</span>
        <span class="cov0" title="0">entropy := make([]common.Hash, 4)
        for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                entropy[i] = common.BytesToHash(data[i*32 : (i+1)*32])
        }</span>
        <span class="cov0" title="0">return entropy, nil</span>
}

func (s *SafroleState) SetEntropyFromBytes(data []byte) error <span class="cov0" title="0">{
        if len(data)%32 != 0 || len(data)/32 != 4 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid data length for entropy")
        }</span>
        <span class="cov0" title="0">entropy, err := EntropyFromBytes(data)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; 4; i++ </span><span class="cov0" title="0">{
                s.Entropy[i] = entropy[i]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *SafroleState) GetCurrEpochFirst() uint32 <span class="cov0" title="0">{
        return s.EpochFirstSlot
}</span>

func (s *SafroleState) GetNextEpochFirst() uint32 <span class="cov0" title="0">{
        nextEpochFirstSlot := s.EpochFirstSlot + types.EpochLength*types.SecondsPerSlot
        return nextEpochFirstSlot
}</span>

func (s *SafroleState) GetTimeSlot() uint32 <span class="cov8" title="1">{
        return uint32(s.Timeslot)
}</span>

func (s *SafroleState) GetEpochValidatorAndRandomness(phase string) ([]types.Validator, common.Hash) <span class="cov0" title="0">{
        var validatorSet []types.Validator
        var target_randomness common.Hash
        switch phase </span>{
        case "Pre":<span class="cov0" title="0"> //N-1
                validatorSet = s.PrevValidators</span>
        case "Curr":<span class="cov0" title="0"> //N
                validatorSet = s.CurrValidators</span>
        case "Next":<span class="cov0" title="0"> //N+1
                validatorSet = s.NextValidators</span>
        case "Designed":<span class="cov0" title="0"> //N+2
                validatorSet = s.DesignedValidators</span>
        }
        <span class="cov0" title="0">return validatorSet, target_randomness</span>
}

func (s *SafroleState) GetValidatorData(phase string) (validatorsData []byte) <span class="cov0" title="0">{
        // 4 authorities[pre, curr, next, designed]
        var validatorSet []types.Validator
        switch phase </span>{
        case "Pre":<span class="cov0" title="0"> //N-1
                validatorSet = s.PrevValidators</span>
        case "Curr":<span class="cov0" title="0"> //N
                validatorSet = s.CurrValidators</span>
        case "Next":<span class="cov0" title="0"> //N+1
                validatorSet = s.NextValidators</span>
        case "Designed":<span class="cov0" title="0"> //N+2
                validatorSet = s.DesignedValidators</span>
        }
        <span class="cov0" title="0">for _, v := range validatorSet </span><span class="cov0" title="0">{
                validatorsData = append(validatorsData, v.Bytes()...)
        }</span>
        <span class="cov0" title="0">return validatorsData</span>
}

func (s *SafroleState) GetCurrValidatorIndex(key types.Ed25519Key) int <span class="cov0" title="0">{
        for i, v := range s.CurrValidators </span><span class="cov0" title="0">{
                if v.Ed25519 == key </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        // If not found, return -1
        <span class="cov0" title="0">return -1</span>
}

func (s *SafroleState) GetPrevValidatorIndex(key types.Ed25519Key) int <span class="cov0" title="0">{
        for i, v := range s.PrevValidators </span><span class="cov0" title="0">{
                if v.Ed25519 == key </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        // If not found, return -1
        <span class="cov0" title="0">return -1</span>
}

func (s *SafroleState) GetCurrValidator(index int) types.Validator <span class="cov0" title="0">{
        return s.CurrValidators[index]
}</span>

func (s *SafroleState) SetValidatorData(validatorsData []byte, phase string) error <span class="cov0" title="0">{
        // Calculate the expected length for each validator data
        const validatorLength = 32 + 32 + 144 + 128

        // Check if validatorsData length is a multiple of validatorLength
        if len(validatorsData)%validatorLength != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid validatorsData length: expected a multiple of %d, got %d", validatorLength, len(validatorsData))
        }</span>

        <span class="cov0" title="0">var validatorSet []types.Validator
        for offset := 0; offset &lt; len(validatorsData); offset += validatorLength </span><span class="cov0" title="0">{
                validator, err := types.ValidatorFromBytes(validatorsData[offset : offset+validatorLength])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">validatorSet = append(validatorSet, validator)</span>
        }

        <span class="cov0" title="0">switch phase </span>{
        case "Pre":<span class="cov0" title="0"> // N-1
                s.PrevValidators = validatorSet</span>
        case "Curr":<span class="cov0" title="0"> // N
                s.CurrValidators = validatorSet</span>
        case "Next":<span class="cov0" title="0"> // N+1
                s.NextValidators = validatorSet</span>
        case "Designed":<span class="cov0" title="0"> // N+2
                s.DesignedValidators = validatorSet</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unknown phase: %s", phase)</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (s *SafroleState) GetRingSet(phase string) (ringsetBytes []byte) <span class="cov8" title="1">{
        var validatorSet []types.Validator
        // 4 authorities[pre, curr, next, designed]
        switch phase </span>{
        case "Pre":<span class="cov0" title="0"> //N-1
                validatorSet = s.PrevValidators</span>
        case "Curr":<span class="cov0" title="0"> //N
                validatorSet = s.CurrValidators</span>
        case "Next":<span class="cov8" title="1"> //N+1
                validatorSet = s.NextValidators</span>
        case "Designed":<span class="cov0" title="0"> //N+2
                validatorSet = s.DesignedValidators</span>
        }
        <span class="cov8" title="1">pubkeys := []bandersnatch.BanderSnatchKey{}
        for _, v := range validatorSet </span><span class="cov8" title="1">{
                pubkey := bandersnatch.BanderSnatchKey(common.ConvertToSlice(v.Bandersnatch))
                pubkeys = append(pubkeys, pubkey)
        }</span>
        <span class="cov8" title="1">ringsetBytes = bandersnatch.InitRingSet(pubkeys)
        return ringsetBytes</span>
}

func (s *SafroleState) GenerateTickets(secret bandersnatch.BanderSnatchSecret, usedEntropy common.Hash) []types.Ticket <span class="cov0" title="0">{
        tickets := make([]types.Ticket, types.TicketEntriesPerValidator) // Pre-allocate space for tickets
        var wg sync.WaitGroup
        var mu sync.Mutex // To synchronize access to the tickets slice

        start := time.Now()
        for attempt := uint8(0); attempt &lt; types.TicketEntriesPerValidator; attempt++ </span><span class="cov0" title="0">{
                wg.Add(1)

                // Launch a goroutine for each attempt
                go func(attempt uint8) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        entropy := usedEntropy
                        ticket, err := s.generateTicket(secret, entropy, attempt)

                        if err == nil </span><span class="cov0" title="0">{
                                if debug </span><span class="cov0" title="0">{
                                        fmt.Printf("[N%d] Generated ticket %d: %v\n", s.Id, attempt, entropy)
                                }</span>
                                // Lock to safely append to tickets
                                <span class="cov0" title="0">mu.Lock()
                                tickets[attempt] = ticket // Store the ticket at the index of the attempt
                                mu.Unlock()</span>
                        } else<span class="cov0" title="0"> {
                                fmt.Printf("Error generating ticket for attempt %d: %v\n", attempt, err)
                        }</span>
                }(attempt) // Pass the attempt variable to avoid closure capture issues
        }

        <span class="cov0" title="0">wg.Wait() // Wait for all goroutines to finish

        elapsed := time.Since(start).Microseconds()
        if trace &amp;&amp; elapsed &gt; 1000000 </span><span class="cov0" title="0">{ // OPTIMIZED generateTicket
                fmt.Printf(" --- GenerateTickets took %d ms\n", elapsed/1000)
        }</span>

        <span class="cov0" title="0">return tickets</span>
}

func (s *SafroleState) generateTicket(secret bandersnatch.BanderSnatchSecret, targetEpochRandomness common.Hash, attempt uint8) (types.Ticket, error) <span class="cov0" title="0">{
        ticket_vrf_input := s.ticketSealVRFInput(targetEpochRandomness, attempt)
        //RingVrfSign(privateKey, ringsetBytes, vrfInputData, auxData []byte)
        //During epoch N, each authority scheduled for epoch N+2 constructs a set of tickets which may be eligible (6.5.2) for on-chain submission.
        auxData := []byte{}
        if len(s.NextValidators) == 0 </span><span class="cov0" title="0">{
                return types.Ticket{}, fmt.Errorf("No validators in NextValidators")
        }</span>
        <span class="cov0" title="0">ringsetBytes := s.GetRingSet("Next")
        //fmt.Printf("generateTicket secrete=%x, ringsetBytes=%x, ticket_vrf_input=%x, auxData=%x\n", secret, ringsetBytes, ticket_vrf_input, auxData)
        //RingVrfSign(privateKeys[proverIdx], ringSet, vrfInputData, auxData)
        signature, _, err := bandersnatch.RingVrfSign(secret, ringsetBytes, ticket_vrf_input, auxData) // ??
        if err != nil </span><span class="cov0" title="0">{
                return types.Ticket{}, fmt.Errorf("signTicket failed")
        }</span>
        <span class="cov0" title="0">var signatureArray [types.ExtrinsicSignatureInBytes]byte
        copy(signatureArray[:], signature)
        ticket := types.Ticket{
                Attempt:   uint8(attempt),
                Signature: signatureArray,
        }
        return ticket, nil</span>
}

func (s *SafroleState) ValidateProposedTicket(t *types.Ticket, shifted bool) (common.Hash, error) <span class="cov8" title="1">{
        if t.Attempt &gt;= types.TicketEntriesPerValidator </span><span class="cov0" title="0">{
                return common.Hash{}, jamerrors.ErrTBadTicketAttemptNumber
        }</span>

        //step 0: derive ticketVRFInput
        <span class="cov8" title="1">entroptIdx := 2
        targetEpochRandomness := s.Entropy[entroptIdx]
        isTicketSubmissionClosed := s.IsTicketSubmissionClosed(uint32(s.Timeslot))

        if isTicketSubmissionClosed || shifted </span><span class="cov0" title="0">{
                entroptIdx = 1
                targetEpochRandomness = s.Entropy[entroptIdx]
                ticketVRFInput := s.ticketSealVRFInput(targetEpochRandomness, t.Attempt)

                //step 1: verify envelope's VRFSignature using ring verifier
                //RingVrfVerify(ringsetBytes, signature, vrfInputData, auxData []byte)
                ringsetBytes := s.GetRingSet("Next")
                ticket_id, err := bandersnatch.RingVrfVerify(ringsetBytes, t.Signature[:], ticketVRFInput, []byte{})
                if err == nil </span><span class="cov0" title="0">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("[N%d] ValidateProposed Ticket Succ (SubmissionClosed - using η%v:%v) TicketID=%x\n", s.Id, entroptIdx, targetEpochRandomness, ticket_id)
                        }</span>
                        <span class="cov0" title="0">return common.BytesToHash(ticket_id), nil</span>
                }
        } else<span class="cov8" title="1"> {
                ticketVRFInput := s.ticketSealVRFInput(targetEpochRandomness, t.Attempt)
                //step 1: verify envelope's VRFSignature using ring verifier
                //RingVrfVerify(ringsetBytes, signature, vrfInputData, auxData []byte)
                ringsetBytes := s.GetRingSet("Next")
                ticket_id, err := bandersnatch.RingVrfVerify(ringsetBytes, t.Signature[:], ticketVRFInput, []byte{})
                if err == nil </span><span class="cov8" title="1">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("[N%d] ValidateProposed Ticket Succ (Regular - using η%v:%v) TicketID=%x\n", s.Id, entroptIdx, targetEpochRandomness, ticket_id)
                        }</span>
                        <span class="cov8" title="1">return common.BytesToHash(ticket_id), nil</span>
                }
        }

        <span class="cov8" title="1">ticketID, _ := t.TicketID()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] ValidateProposed Ticket Fail (using n%v:%v) TicketID=%v\nη0:%v\nη1:%v\nη2:%v\nη3:%v\n(SubmissionClosed=%v)\n", s.Id, entroptIdx, targetEpochRandomness, ticketID, s.Entropy[0], s.Entropy[1], s.Entropy[2], s.Entropy[3], isTicketSubmissionClosed)
        }</span>
        <span class="cov8" title="1">return common.Hash{}, jamerrors.ErrTBadRingProof</span>
}

func (s *SafroleState) ValidateIncomingTicket(t *types.Ticket) (common.Hash, int, error) <span class="cov0" title="0">{
        if t.Attempt &gt;= types.TicketEntriesPerValidator </span><span class="cov0" title="0">{
                return common.Hash{}, -1, fmt.Errorf(errExtrinsicWithMoreTicketsThanAllowed)
        }</span>
        <span class="cov0" title="0">for i := 1; i &lt; 3; i++ </span><span class="cov0" title="0">{
                targetEpochRandomness := s.Entropy[i]
                ticketVRFInput := s.ticketSealVRFInput(targetEpochRandomness, t.Attempt)
                //step 1: verify envelope's VRFSignature using ring verifier
                //RingVrfVerify(ringsetBytes, signature, vrfInputData, auxData []byte)
                ringsetBytes := s.GetRingSet("Next")
                ticket_id, err := bandersnatch.RingVrfVerify(ringsetBytes, t.Signature[:], ticketVRFInput, []byte{})
                if err == nil </span><span class="cov0" title="0">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("[N%d] ValidateIncoming Ticket Succ (using η%v:%v) TicketID=%x\n", s.Id, i, targetEpochRandomness, ticket_id)
                        }</span>
                        <span class="cov0" title="0">return common.BytesToHash(ticket_id), i, nil</span>
                }
        }
        //ticketID, _ := t.TicketID()
        //fmt.Printf("[N%d] ValidateIncoming Ticket Fail TicketID=%v\nη0:%v\nη1:%v\nη2:%v\nη3:%v\n", s.Id, ticketID, s.Entropy[0], s.Entropy[1], s.Entropy[2], s.Entropy[3])

        <span class="cov0" title="0">return common.Hash{}, -1, jamerrors.ErrTBadRingProof</span>
}

func compareTickets(a, b common.Hash) int <span class="cov8" title="1">{
        aBytes := a.Bytes()
        bBytes := b.Bytes()
        for i := 0; i &lt; len(aBytes); i++ </span><span class="cov8" title="1">{
                if aBytes[i] &lt; bBytes[i] </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if aBytes[i] &gt; bBytes[i] </span><span class="cov8" title="1">{
                        return 1
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// computeTicketSlotBinding has logic for assigning tickets to slots
func (s *SafroleState) computeTicketSlotBinding(inp []types.TicketBody) []*types.TicketBody <span class="cov0" title="0">{
        i := 0
        tickets := make([]*types.TicketBody, 0, types.EpochLength)
        for i &lt; len(inp)/2 </span><span class="cov0" title="0">{ //MK: check this line, was s.TicketsAccumulator/2
                tickets = append(tickets, &amp;inp[i])
                tickets = append(tickets, &amp;inp[types.EpochLength-1-i])
                i++
        }</span>
        <span class="cov0" title="0">return tickets</span>
}

func (s *SafroleState) SignPrimary(authority_secret_key bandersnatch.BanderSnatchSecret, unsignHeader []byte, attempt uint8) ([]byte, []byte, error) <span class="cov0" title="0">{
        sealVRFInput := s.ticketSealVRFInput(s.Entropy[3], attempt)

        blockSeal, inner_vrfOutput, err := s.SignBlockSeal(authority_secret_key, sealVRFInput, unsignHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Fallback BlockSeal ERR=%v", err)
        }</span>
        // use inner_vrfOutput to to generate fresh randomness
        <span class="cov0" title="0">entropyVRFInput := computeEntropyVRFInput(common.BytesToHash(inner_vrfOutput))
        fresh_VRFSignature, freshRandomness, err := bandersnatch.IetfVrfSign(authority_secret_key, entropyVRFInput, []byte{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("H_v ERR=%v", err)
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("SignPrimary unsignHeader(len=%v)=%x, blockSeal=%x, fresh_VRFSignature=%x, freshRandomness=%x\n", len(unsignHeader), unsignHeader, blockSeal, fresh_VRFSignature, freshRandomness)
        }</span>
        <span class="cov0" title="0">return blockSeal, fresh_VRFSignature, nil</span>
}

func (s *SafroleState) ConvertBanderSnatchSecret(authority_secret_key []byte) (bandersnatch.BanderSnatchSecret, error) <span class="cov0" title="0">{
        //TODO: figure out a plan to standardize between bandersnatch package and types
        return bandersnatch.BytesToBanderSnatchSecret(authority_secret_key)
}</span>

// 6.8.1 Primary Method for legit ticket - is it bare VRF here???
func (s *SafroleState) SignFallBack(authority_secret_key bandersnatch.BanderSnatchSecret, unsignHeader []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        sealVRFInput := fallbackSealVRFInput(s.Entropy[3]) // the context
        blockSeal, inner_vrfOutput, err := s.SignBlockSeal(authority_secret_key, sealVRFInput, unsignHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Fallback BlockSeal ERR=%v", err)
        }</span>
        // use inner_vrfOutput to to generate fresh randomness
        <span class="cov0" title="0">entropyVRFInput := computeEntropyVRFInput(common.BytesToHash(inner_vrfOutput))
        fresh_VRFSignature, freshRandomness, err := bandersnatch.IetfVrfSign(authority_secret_key, entropyVRFInput, []byte{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("H_v ERR=%v", err)
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("SignFallBack unsignHeader(len=%v)=%x, blockSeal=%x, fresh_VRFSignature=%x, freshRandomness=%x\n", len(unsignHeader), unsignHeader, blockSeal, fresh_VRFSignature, freshRandomness)
        }</span>
        <span class="cov0" title="0">return blockSeal, fresh_VRFSignature, nil</span>
}

func (s *SafroleState) SignBlockSeal(authority_secret_key bandersnatch.BanderSnatchSecret, sealVRFInput []byte, unsignHeader []byte) ([]byte, []byte, error) <span class="cov0" title="0">{
        //IetfVrfSign(privateKey PrivateKey, vrfInputData, auxData []byte)
        ietfSig, inner_vrfOutput, err := bandersnatch.IetfVrfSign(authority_secret_key, sealVRFInput, unsignHeader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("IetfVrfSign ERR=%v", err)
        }</span>
        <span class="cov0" title="0">return ietfSig, inner_vrfOutput, err</span>
}

// 6.8.2. Secondary Method
func computeEntropyVRFInput(inner_vrfOutput common.Hash) []byte <span class="cov0" title="0">{
        entropyPrefix := []byte(types.X_E)
        entropyVRFInput := append(entropyPrefix, inner_vrfOutput.Bytes()...)
        return entropyVRFInput
}</span>

func fallbackSealVRFInput(targetRandomness common.Hash) []byte <span class="cov0" title="0">{
        sealPrefix := []byte(types.X_F)
        sealVRFInput := append(sealPrefix, targetRandomness.Bytes()...)
        return sealVRFInput
}</span>

func (s *SafroleState) GetRelativeSlotIndex(slot_index uint32) (uint32, error) <span class="cov0" title="0">{
        //relative slot index = slot - epoch_first_slot
        relativeSlotIndex := slot_index - s.EpochFirstSlot
        return relativeSlotIndex, nil
}</span>

func (s *SafroleState) GetAuthorIndex(authorkey common.Hash, phase string) (uint16, error) <span class="cov0" title="0">{
        var validatorSet []types.Validator
        // Select the appropriate set of validators based on the phase
        switch phase </span>{
        case "Pre":<span class="cov0" title="0"> // N-1
                if len(s.PrevValidators) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("PrevValidators is empty")
                }</span>
                <span class="cov0" title="0">validatorSet = s.PrevValidators</span>
        case "Curr":<span class="cov0" title="0"> // N
                if len(s.CurrValidators) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("CurrValidators is empty")
                }</span>
                <span class="cov0" title="0">validatorSet = s.CurrValidators</span>
        case "Next":<span class="cov0" title="0"> // N+1
                if len(s.NextValidators) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("NextValidators is empty")
                }</span>
                <span class="cov0" title="0">validatorSet = s.NextValidators</span>
        case "Designed":<span class="cov0" title="0"> // N+2
                validatorSet = s.DesignedValidators
                if len(validatorSet) == 0 </span><span class="cov0" title="0">{
                        return 0, errors.New("DesignedValidators is empty")
                }</span>
        default:<span class="cov0" title="0">
                return 0, errors.New("invalid phase")</span>
        }

        <span class="cov0" title="0">for authorIdx, v := range validatorSet </span><span class="cov0" title="0">{
                if common.Hash(v.GetBandersnatchKey()) == authorkey </span><span class="cov0" title="0">{
                        return uint16(authorIdx), nil
                }</span>
        }
        <span class="cov0" title="0">return 0, errors.New("author key not found")</span>
}

// shawn modified, align gp
// eq 70
// computeAuthorityIndex computes the authority index for claiming an orphan slot
func (s *SafroleState) computeFallbackAuthorityIndex(targetRandomness common.Hash, relativeSlotIndex uint32, validatorsLen int) (uint32, error) <span class="cov0" title="0">{
        // Concatenate target_randomness and relative_slot_index
        encodedRelativeSlotIndex, err := types.Encode(relativeSlotIndex)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">hashInput := append(targetRandomness.Bytes(), encodedRelativeSlotIndex...)

        // Compute BLAKE2 hash
        hash := common.ComputeHash(hashInput)

        // Extract the first 4 bytes of the hash to compute the index
        indexBytes := hash[:4]
        index, _, err := types.Decode(indexBytes, reflect.TypeOf(uint32(0))) //Check, shawn use the codec here
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        //fmt.Printf("targetRandomness=%x, relativeSlotIndex=%v, indexBytes=%x, priv_index=%v. (authLen=%v)", targetRandomness, relativeSlotIndex, indexBytes, index, len(s.Authorities))
        // transform the index to uint32
        <span class="cov0" title="0">indexUint32, ok := index.(uint32)
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to convert index to uint32")
        }</span>
        <span class="cov0" title="0">return indexUint32 % uint32(validatorsLen), nil</span>
}

// Fallback is using the perspective of right now
func (s *SafroleState) GetFallbackValidator(slot_index uint32) common.Hash <span class="cov0" title="0">{
        // fallback validator has been updated at eq 68
        //fmt.Printf("GetFallbackValidator safrolestate: %s\n", s.String())
        return s.TicketsOrKeys.Keys[slot_index]
}</span>

func (state *SafroleState) String() string <span class="cov0" title="0">{
        // Marshal the JamState into indented JSON
        jsonBytes, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "failedmarshaling"
        }</span>
        // Return the JSON as a string
        <span class="cov0" title="0">return string(jsonBytes)</span>
}

func (s *SafroleState) GetPrimaryWinningTicket(slot_index uint32) common.Hash <span class="cov0" title="0">{
        t_or_k := s.TicketsOrKeys
        winning_tickets := t_or_k.Tickets
        _, currPhase := s.EpochAndPhase(slot_index)
        selected_ticket := winning_tickets[currPhase]
        return selected_ticket.Id
}</span>

func (s *SafroleState) CheckEpochType() string <span class="cov0" title="0">{
        t_or_k := s.TicketsOrKeys
        if len(t_or_k.Tickets) &gt; 0 </span><span class="cov0" title="0">{
                return "primary"
        }</span> else<span class="cov0" title="0"> {
                return "fallback"
        }</span>
}

func (s *SafroleState) GetBindedAttempt(targetJCE uint32) (uint8, error) <span class="cov0" title="0">{
        _, currPhase := s.EpochAndPhase(targetJCE)
        t_or_k := s.TicketsOrKeys
        if len(t_or_k.Tickets) == types.EpochLength </span><span class="cov0" title="0">{
                winning_ticket := (t_or_k.Tickets)[currPhase]
                return uint8(winning_ticket.Attempt), nil
        }</span>
        <span class="cov0" title="0">return 0, fmt.Errorf("Shouldn't be fallback")</span>
}

// eq 59
func (s *SafroleState) IsAuthorizedBuilder(slot_index uint32, bandersnatchPub common.Hash, ticketIDs []common.Hash) bool <span class="cov0" title="0">{

        currEpoch, currPhase := s.EpochAndPhase(slot_index)
        //TicketsOrKeys
        t_or_k := s.TicketsOrKeys

        if len(t_or_k.Tickets) == types.EpochLength </span><span class="cov0" title="0">{
                winning_ticket_id := s.GetPrimaryWinningTicket(slot_index)
                for _, ticketID := range ticketIDs </span><span class="cov0" title="0">{
                        if ticketID == winning_ticket_id </span><span class="cov0" title="0">{
                                if debug </span><span class="cov0" title="0">{
                                        fmt.Printf("[N%v] [AUTHORIZED] (%v, %v) slot_index=%v primary validator=%v\n", s.Id, currEpoch, currPhase, slot_index, bandersnatchPub)
                                }</span>
                                <span class="cov0" title="0">return true</span>
                        }
                }
                <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                        fmt.Printf("[N%v] [UNAUTHORIZED] (%v, %v) slot_index=%v primary validator=%v\n", s.Id, currEpoch, currPhase, slot_index, bandersnatchPub)
                }</span>
        } else<span class="cov0" title="0"> {

                //fallback mode
                fallback_validator := s.GetFallbackValidator(currPhase)
                if fallback_validator == bandersnatchPub </span><span class="cov0" title="0">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("[N%v] [AUTHORIZED] (%v, %v) slot_index=%v fallback validator=%v\n", s.Id, currEpoch, currPhase, slot_index, bandersnatchPub)
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

func (s *SafroleState) CheckTimeSlotReady() (uint32, bool) <span class="cov0" title="0">{
        // timeslot mark
        // currJCE := common.ComputeCurrentJCETime()
        currJCE := common.ComputeTimeUnit(types.TimeUnitMode)
        prevEpoch, prevPhase := s.EpochAndPhase(s.GetTimeSlot())
        currEpoch, currPhase := s.EpochAndPhase(currJCE)
        if debug </span><span class="cov0" title="0">{
                if prevEpoch != currEpoch || currPhase != prevPhase </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] CheckTimeSlotReady PREV [%d] %d %d Curr [%d] %d %d\n", s.Id, s.GetTimeSlot(), prevEpoch, prevPhase, currJCE, currEpoch, currPhase)
                }</span>
        }
        <span class="cov0" title="0">if currEpoch &gt; prevEpoch </span><span class="cov0" title="0">{
                return currJCE, true
        }</span> else<span class="cov0" title="0"> if currEpoch == prevEpoch &amp;&amp; currPhase &gt; prevPhase </span><span class="cov0" title="0">{
                // normal case
                return currJCE, true
        }</span>
        <span class="cov0" title="0">return currJCE, false</span>
}

func (s *SafroleState) CheckFirstPhaseReady() (isReady bool) <span class="cov0" title="0">{
        // timeslot mark
        currJCE := common.ComputeRealCurrentJCETime(types.TimeUnitMode)

        if currJCE &lt; s.EpochFirstSlot*types.SecondsPerSlot </span><span class="cov0" title="0">{
                // fmt.Printf("Not ready currJCE: %v &lt; s.EpochFirstSlot %v\n", currJCE, s.EpochFirstSlot*types.SecondsPerSlot)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

func cloneSafroleState(original SafroleState) SafroleState <span class="cov8" title="1">{
        copied := SafroleState{
                Id:                          original.Id,
                EpochFirstSlot:              original.EpochFirstSlot,
                Timeslot:                    original.Timeslot,
                Entropy:                     original.Entropy,
                PrevValidators:              make([]types.Validator, len(original.PrevValidators)),
                CurrValidators:              make([]types.Validator, len(original.CurrValidators)),
                NextValidators:              make([]types.Validator, len(original.NextValidators)),
                DesignedValidators:          make([]types.Validator, len(original.DesignedValidators)),
                NextEpochTicketsAccumulator: make([]types.TicketBody, len(original.NextEpochTicketsAccumulator)),
                TicketsOrKeys:               original.TicketsOrKeys,
                TicketsVerifierKey:          make([]byte, len(original.TicketsVerifierKey)),
        }

        // Copy each field individually
        copy(copied.PrevValidators, original.PrevValidators)
        copy(copied.CurrValidators, original.CurrValidators)
        copy(copied.NextValidators, original.NextValidators)
        copy(copied.DesignedValidators, original.DesignedValidators)
        copy(copied.NextEpochTicketsAccumulator, original.NextEpochTicketsAccumulator)
        copy(copied.TicketsVerifierKey, original.TicketsVerifierKey)

        return copied
}</span>

// Function to copy a State struct
func (original *SafroleState) Copy() *SafroleState <span class="cov0" title="0">{
        // Create a new instance of SafroleState
        copyState := &amp;SafroleState{
                Id:                          original.Id,
                EpochFirstSlot:              original.EpochFirstSlot,
                Timeslot:                    original.Timeslot,
                Entropy:                     original.Entropy,
                PrevValidators:              make([]types.Validator, len(original.PrevValidators)),
                CurrValidators:              make([]types.Validator, len(original.CurrValidators)),
                NextValidators:              make([]types.Validator, len(original.NextValidators)),
                DesignedValidators:          make([]types.Validator, len(original.DesignedValidators)),
                NextEpochTicketsAccumulator: make([]types.TicketBody, len(original.NextEpochTicketsAccumulator)),
                TicketsOrKeys:               original.TicketsOrKeys, // Assuming this has value semantics
                TicketsVerifierKey:          make([]byte, len(original.TicketsVerifierKey)),
        }

        // Copy the PrevValidators slice
        copy(copyState.PrevValidators, original.PrevValidators)
        copy(copyState.CurrValidators, original.CurrValidators)
        copy(copyState.NextValidators, original.NextValidators)
        copy(copyState.DesignedValidators, original.DesignedValidators)
        copy(copyState.NextEpochTicketsAccumulator, original.NextEpochTicketsAccumulator)
        // Copy the TicketsVerifierKey slice
        copy(copyState.TicketsVerifierKey, original.TicketsVerifierKey)

        return copyState
}</span>

func (s *SafroleState) GetEpoch() uint32 <span class="cov0" title="0">{
        //todo
        return 0
}</span>

// statefrole_stf is the function to be tested
func (s *SafroleState) ApplyStateTransitionTickets(tickets []types.Ticket, targetJCE uint32, header types.BlockHeader) (SafroleState, error) <span class="cov0" title="0">{
        prevEpoch, _ := s.EpochAndPhase(uint32(s.Timeslot))
        currEpoch, _ := s.EpochAndPhase(targetJCE)
        err := s.ValidateSaforle(tickets, targetJCE, header)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("ValidateSaforle ERR %v\n", err)
                return *s, err
        }</span>
        <span class="cov0" title="0">s2 := cloneSafroleState(*s)
        // tally existing ticketIDs
        ticketIDs := make(map[common.Hash]uint8)
        for _, a := range s.NextEpochTicketsAccumulator </span><span class="cov0" title="0">{
                //fmt.Printf("[N%d] ticketID? %d =&gt; %s\n", s.Id, i, a.Id.String())
                ticketIDs[a.Id] = a.Attempt
        }</span>

        // Process Extrinsic Tickets
        //fmt.Printf("Current Slot: %d =&gt; Input Slot: %d \n", s.Timeslot, targetJCE)
        <span class="cov0" title="0">fresh_randomness, err := s.GetFreshRandomness(header.EntropySource[:])
        if err != nil </span><span class="cov0" title="0">{

                fmt.Printf("GetFreshRandomness ERR %v (len=%d)", err, len(header.EntropySource[:]))
                return s2, fmt.Errorf("GetFreshRandomness %v", err)
        }</span>
        // in the tail slot with a full set of tickets
        <span class="cov0" title="0">if prevEpoch &lt; currEpoch </span><span class="cov0" title="0">{ //MK check EpochNumSlots-1 ?
                //TODO this is Winning ticket elgible. Check if header has marker, if yes, verify it
                if debug </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] ApplyStateTransitionTickets: Winning Tickets %d\n", s2.Id, len(s2.NextEpochTicketsAccumulator))
                }</span>
                // eq 68 primary mode
                <span class="cov0" title="0">if len(s2.NextEpochTicketsAccumulator) == types.EpochLength </span><span class="cov0" title="0">{
                        winning_tickets, err := s2.GenerateWinningMarker()
                        if err != nil </span><span class="cov0" title="0">{
                                return s2, fmt.Errorf("Get Winning Tickets Failed: %v", err)
                        }</span>
                        <span class="cov0" title="0">expected_tickets := s.computeTicketSlotBinding(s2.NextEpochTicketsAccumulator)
                        verified, err := VerifyWinningMarker([types.EpochLength]*types.TicketBody(winning_tickets), expected_tickets)
                        if !verified || err != nil </span><span class="cov0" title="0">{
                                return s2, fmt.Errorf("VerifyWinningMarker Failed:%s", err)
                        }</span>
                        // do something to set this marker
                        <span class="cov0" title="0">ticketsOrKeys := TicketsOrKeys{
                                Tickets: winning_tickets,
                        }
                        s2.TicketsOrKeys = ticketsOrKeys
                        s2.NextEpochTicketsAccumulator = make([]types.TicketBody, 0)</span>
                } else<span class="cov0" title="0"> { // eq 68 fallback mode
                        chosenkeys, err := s.ChooseFallBackValidator()
                        if err != nil </span><span class="cov0" title="0">{
                                return s2, fmt.Errorf("ChooseFallBackValidator %v", err)
                        }</span>
                        <span class="cov0" title="0">ticketsOrKeys := TicketsOrKeys{
                                Keys: chosenkeys,
                        }
                        s2.TicketsOrKeys = ticketsOrKeys</span>
                }

        }
        // entropy phasing eq 67 &amp; 57
        <span class="cov0" title="0">new_entropy_0 := s.ComputeCurrRandomness(fresh_randomness)
        isShifted := false
        if currEpoch &gt; prevEpoch </span><span class="cov0" title="0">{
                // New Epoch
                s2.PhasingEntropyAndValidator(s, new_entropy_0)
                isShifted = true
        }</span> else<span class="cov0" title="0"> {
                // Epoch in progress
                s2.StableEntropy(s, new_entropy_0)
        }</span>

        <span class="cov0" title="0">var wg sync.WaitGroup
        ticketMutex := &amp;sync.Mutex{}
        errCh := make(chan error, len(tickets))
        // Iterate over tickets in parallel
        for _, e := range tickets </span><span class="cov0" title="0">{
                wg.Add(1)

                go func(e types.Ticket) </span><span class="cov0" title="0">{
                        defer wg.Done()

                        // Validate the ticket in parallel
                        ticket_id, err := s.ValidateProposedTicket(&amp;e, isShifted)
                        if err != nil </span><span class="cov0" title="0">{
                                errCh &lt;- jamerrors.ErrTBadRingProof
                                return
                        }</span>

                        // Protect access to shared resources (map) with a mutex
                        <span class="cov0" title="0">ticketMutex.Lock()
                        defer ticketMutex.Unlock()

                        _, exists := ticketIDs[ticket_id]
                        if exists </span><span class="cov0" title="0">{
                                if debug </span><span class="cov0" title="0">{
                                        fmt.Printf("DETECTED Resubmit %v\n", ticket_id)
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        // If the ticket is valid, add it to the accumulator
                        <span class="cov0" title="0">s2.PutTicketInAccumulator(ticket_id, e.Attempt)</span>
                }(e)
        }

        // Wait for all goroutines to finish
        <span class="cov0" title="0">wg.Wait()

        // Sort and trim tickets
        s2.SortAndTrimTickets()

        s2.Timeslot = targetJCE

        return s2, nil</span>
}

// this function is for validate the block input is correct or not
// should use the s3
func (s *SafroleState) ValidateSaforle(tickets []types.Ticket, targetJCE uint32, header types.BlockHeader) error <span class="cov8" title="1">{
        prevEpoch, _ := s.EpochAndPhase(uint32(s.Timeslot))
        currEpoch, currPhase := s.EpochAndPhase(targetJCE)
        s2 := cloneSafroleState(*s) // CHECK: why cloning here?
        if currPhase &gt;= types.TicketSubmissionEndSlot &amp;&amp; len(tickets) &gt; 0 </span><span class="cov8" title="1">{
                return jamerrors.ErrTEpochLotteryOver
        }</span>
        <span class="cov8" title="1">if s.Timeslot &gt;= targetJCE </span><span class="cov8" title="1">{
                // fmt.Printf("currEpoch=%d, prevEpoch=%d, currPhase=%d, prevPhase=%d\n", currEpoch, prevEpoch, currPhase, prevPhase)
                return jamerrors.ErrTTimeslotNotMonotonic
        }</span>
        <span class="cov8" title="1">new_entropy_0 := common.Hash{} // use empty hash as entropy 0, since it's not useful in validation
        isShifted := false
        if currEpoch &gt; prevEpoch </span><span class="cov8" title="1">{
                // New Epoch
                isShifted = true
        }</span> else<span class="cov8" title="1"> {
                // Epoch in progress
                s2.StableEntropy(s, new_entropy_0)
        }</span>
        <span class="cov8" title="1">ticketBodies := make([]types.TicketBody, 0) // n
        for _, t := range tickets </span><span class="cov8" title="1">{
                if t.Attempt &gt;= types.TicketEntriesPerValidator </span><span class="cov8" title="1">{
                        return jamerrors.ErrTBadTicketAttemptNumber
                }</span>
                <span class="cov8" title="1">ticket_id, err := s2.ValidateProposedTicket(&amp;t, isShifted)
                if err != nil </span><span class="cov8" title="1">{
                        return jamerrors.ErrTBadRingProof
                }</span>
                <span class="cov8" title="1">ticketBodies = append(ticketBodies, types.TicketBody{
                        Id:      ticket_id,
                        Attempt: t.Attempt,
                })
                for _, a := range s2.NextEpochTicketsAccumulator </span><span class="cov8" title="1">{
                        if ticket_id == a.Id </span><span class="cov8" title="1">{
                                return jamerrors.ErrTTicketAlreadyInState
                        }</span>
                }
        }
        // check ticketBodies sorted by Id
        // use bytes to compare
        <span class="cov8" title="1">for i, a := range ticketBodies </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; compareTickets(a.Id, ticketBodies[i-1].Id) &lt; 0 </span><span class="cov8" title="1">{
                        return jamerrors.ErrTTicketsBadOrder
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s2 *SafroleState) PhasingEntropyAndValidator(s *SafroleState, new_entropy_0 common.Hash) <span class="cov0" title="0">{
        s2.PrevValidators = s2.CurrValidators
        s2.CurrValidators = s2.NextValidators
        if types.GetValidatorsLength(s2.NextValidators) == 0 </span><span class="cov0" title="0">{
                panic("no NextValidators")</span>
        }
        <span class="cov0" title="0">s2.NextValidators = s2.DesignedValidators
        if types.GetValidatorsLength(s2.DesignedValidators) == 0 </span><span class="cov0" title="0">{
                panic("no DesignedValidators")</span>
        }
        <span class="cov0" title="0">prev_n0 := s2.Entropy[0]
        s2.Entropy[1] = s.Entropy[0]
        s2.Entropy[2] = s.Entropy[1]
        s2.Entropy[3] = s.Entropy[2]
        s2.Entropy[0] = new_entropy_0
        s2.NextEpochTicketsAccumulator = s2.NextEpochTicketsAccumulator[0:0]
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] ApplyStateTransitionTickets: ENTROPY shifted new epoch\nη0:%v\nη1:%v\nη2:%v\nη3:%v\nη0:%v (original)\n", s2.Id, s2.Entropy[0], s2.Entropy[1], s2.Entropy[2], s2.Entropy[3], prev_n0)
        }</span>
}

func (s2 *SafroleState) StableEntropy(s *SafroleState, new_entropy_0 common.Hash) <span class="cov8" title="1">{
        s2.Entropy[0] = new_entropy_0
        s2.Entropy[1] = s.Entropy[1]
        s2.Entropy[2] = s.Entropy[2]
        s2.Entropy[3] = s.Entropy[3]
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] ApplyStateTransitionTickets: ENTROPY norm\nη1:%v\nη2:%v\nη3:%v\n", s2.Id, s2.Entropy[1], s2.Entropy[2], s2.Entropy[3])
        }</span>
}

func (s2 *SafroleState) PutTicketInAccumulator(tickeID common.Hash, attempt uint8) <span class="cov0" title="0">{
        newa := types.TicketBody{
                Id:      tickeID,
                Attempt: attempt,
        }
        s2.NextEpochTicketsAccumulator = append(s2.NextEpochTicketsAccumulator, newa)
}</span>

func (s *SafroleState) SortAndTrimTickets() <span class="cov0" title="0">{
        // Sort tickets using compareTickets
        sort.SliceStable(s.NextEpochTicketsAccumulator, func(i, j int) bool </span><span class="cov0" title="0">{
                return compareTickets(s.NextEpochTicketsAccumulator[i].Id, s.NextEpochTicketsAccumulator[j].Id) &lt; 0
        }</span>)

        // Drop useless tickets
        <span class="cov0" title="0">if len(s.NextEpochTicketsAccumulator) &gt; types.EpochLength </span><span class="cov0" title="0">{
                s.NextEpochTicketsAccumulator = s.NextEpochTicketsAccumulator[0:types.EpochLength]
        }</span>
}

func (s *SafroleState) ChooseFallBackValidator() ([]common.Hash, error) <span class="cov0" title="0">{
        // get the bandersnatch keys of the validators
        banderkeys := make([]common.Hash, 0)
        for _, v := range s.CurrValidators </span><span class="cov0" title="0">{
                banderkeys = append(banderkeys, common.Hash(v.GetBandersnatchKey()))
        }</span>
        <span class="cov0" title="0">chosenkeys := make([]common.Hash, 0)
        for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov0" title="0">{
                // get the authority index
                authority_idx, err := s.computeFallbackAuthorityIndex(s.Entropy[2], uint32(i), len(s.CurrValidators))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">chosenkeys = append(chosenkeys, banderkeys[authority_idx])</span>
        }
        <span class="cov0" title="0">return chosenkeys, nil</span>

}

func (E *Extrinsic) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var s struct {
                Attempt   uint8  `json:"attempt"`
                Signature string `json:"signature"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">E.Attempt = s.Attempt
        sig := common.FromHex(s.Signature)
        if len(sig) != types.ExtrinsicSignatureInBytes </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature length")
        }</span>
        <span class="cov0" title="0">copy(E.Signature[:], sig)
        return nil</span>
}

func (E Extrinsic) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        sig := common.HexString(E.Signature[:])
        return json.Marshal(struct {
                Attempt   uint8  `json:"attempt"`
                Signature string `json:"signature"`
        }{
                Attempt:   E.Attempt,
                Signature: sig,
        })
}</span>

type SafroleStateCodec struct {
        Tau           uint32             `json:"tau"`
        Eta           Entropy            `json:"eta"`
        Lambda        types.Validators   `json:"lambda"`
        Kappa         types.Validators   `json:"kappa"`
        GammaK        types.Validators   `json:"gamma_k"`
        Iota          types.Validators   `json:"iota"`
        GammaA        []types.TicketBody `json:"gamma_a"`
        GammaS        TicketsOrKeys      `json:"gamma_s"`
        GammaZ        [144]byte          `json:"gamma_z"`
        PostOffenders []types.Ed25519Key `json:"post_offenders"`
}

func (s *SafroleState) SafroleStateCodec() SafroleStateCodec <span class="cov0" title="0">{

        return SafroleStateCodec{
                Tau:    s.Timeslot,
                Eta:    s.Entropy,
                Lambda: s.PrevValidators,
                Kappa:  s.CurrValidators,
                GammaK: s.NextValidators,
                Iota:   s.DesignedValidators,
                GammaA: s.NextEpochTicketsAccumulator,
                GammaS: s.TicketsOrKeys,
                GammaZ: [144]byte(s.TicketsVerifierKey),
        }
}</span>

func (a *SafroleStateCodec) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Tau    uint32             `json:"tau"`
                Eta    Entropy            `json:"eta"`
                Lambda types.Validators   `json:"lambda"`
                Kappa  types.Validators   `json:"kappa"`
                GammaK types.Validators   `json:"gamma_k"`
                Iota   types.Validators   `json:"iota"`
                GammaA []types.TicketBody `json:"gamma_a"`
                GammaS TicketsOrKeys      `json:"gamma_s"`
                GammaZ string             `json:"gamma_z"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a.Tau = s.Tau
        a.Eta = s.Eta
        a.Lambda = s.Lambda
        a.Kappa = s.Kappa
        a.GammaK = s.GammaK
        a.Iota = s.Iota
        a.GammaA = s.GammaA
        a.GammaS = s.GammaS
        copy(a.GammaZ[:], common.FromHex(s.GammaZ))

        return nil</span>
}

func (a *SafroleStateCodec) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                Tau    uint32             `json:"tau"`
                Eta    Entropy            `json:"eta"`
                Lambda types.Validators   `json:"lambda"`
                Kappa  types.Validators   `json:"kappa"`
                GammaK types.Validators   `json:"gamma_k"`
                Iota   types.Validators   `json:"iota"`
                GammaA []types.TicketBody `json:"gamma_a"`
                GammaS TicketsOrKeys      `json:"gamma_s"`
                GammaZ string             `json:"gamma_z"`
        }{
                Tau:    a.Tau,
                Eta:    a.Eta,
                Lambda: a.Lambda,
                Kappa:  a.Kappa,
                GammaK: a.GammaK,
                Iota:   a.Iota,
                GammaA: a.GammaA,
                GammaS: a.GammaS,
                GammaZ: common.HexString(a.GammaZ[:]),
        })
}</span>
func SortTicketsById(tickets []types.Ticket) <span class="cov0" title="0">{
        sort.SliceStable(tickets, func(i, j int) bool </span><span class="cov0" title="0">{
                a_id, _ := tickets[i].TicketID()
                b_id, _ := tickets[j].TicketID()
                return compareTickets(a_id, b_id) &lt; 0
        }</span>)
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package statedb

import (
        "encoding/binary"
        "github.com/colorfulnotion/jam/common"
)

// FisherYatesShuffle performs the Fisher-Yates shuffle on a slice of integers.
func FisherYatesShuffle(s []uint32, r []uint32) []uint32 <span class="cov8" title="1">{
        if len(s) &gt; 0 </span><span class="cov8" title="1">{
                l := uint32(len(s))
                index := r[0] % l
                head := s[index]

                // Create a copy of the slice
                sPost := append([]uint32(nil), s...)
                sPost[index] = s[l-1]

                // Recursive call with updated slice and remaining `r`
                return append([]uint32{head}, FisherYatesShuffle(sPost[:l-1], r[1:])...)
        }</span>
        <span class="cov8" title="1">return []uint32{}</span>
}

// NumericSequenceFromHash generates a deterministic numeric sequence from a 32-byte hash.
func NumericSequenceFromHash(h [32]byte, l uint32) []uint32 <span class="cov8" title="1">{
        result := make([]uint32, l)
        bytes := make([]byte, 4)
        for i := uint32(0); i &lt; l; i++ </span><span class="cov8" title="1">{
                offset := (4 * i) % 32
                binary.LittleEndian.PutUint32(bytes, uint32(i&gt;&gt;3)) // i/8
                hash := common.Blake2Hash(append(h[:], bytes...)).Bytes()
                result[i] = binary.LittleEndian.Uint32(hash[offset : offset+4])
        }</span>

        <span class="cov8" title="1">return result</span>
}

// ShuffleFromHash performs the Fisher-Yates shuffle based on a hash value.
func ShuffleFromHash(sequence []uint32, hash common.Hash) []uint32 <span class="cov8" title="1">{
        randomSequence := NumericSequenceFromHash(hash, uint32(len(sequence)))
        return FisherYatesShuffle(sequence, randomSequence)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package statedb

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

type AvailabilityAssignments [types.TotalCores]*Rho_state

type JamState struct {
        AuthorizationsPool       [types.TotalCores][]common.Hash              `json:"authorizations_pool"` // alpha The core αuthorizations pool. α eq 85
        AuthorizationQueue       types.AuthorizationQueue                     `json:"authorization_queue"` // phi - The authorization queue  φ eq 85
        RecentBlocks             RecentBlocks                                 `json:"beefy_pool"`          // beta - The core βeefy pool. β eq 81
        SafroleStateGamma        SafroleBasicState                            `json:"safrole_state_gamma"` // gamma - SafroleBasicState γ eq 48
        SafroleState             *SafroleState                                `json:"safrole"`
        AvailabilityAssignments  AvailabilityAssignments                      `json:"availability_assignments"`    // rho - AvailabilityAssignments ρ eq 118
        DisputesState            Psi_state                                    `json:"disputes_state"`              // psi - Disputes ψ eq 97
        PrivilegedServiceIndices types.Kai_state                              `json:"privileged_services_indices"` // kai - The privileged service indices. χ eq 96
        ValidatorStatistics      ValidatorStatistics                          `json:"pi"`                          // pi The validator statistics. π eq 171
        AccumulationQueue        [types.EpochLength][]types.AccumulationQueue `json:"accumulate_queue"`            // theta - The accumulation queue  θ eq 164
        AccumulationHistory      [types.EpochLength]types.AccumulationHistory `json:"accumulate_history"`          // xi - The accumulation history  ξ eq 162
}

type ValidatorStatistics struct {
        Current [types.TotalValidators]Pi_state `json:"current"`
        Last    [types.TotalValidators]Pi_state `json:"last"`
}

type ValidatorStatisticsInternal [2][types.TotalValidators]Pi_state

func (v *ValidatorStatistics) Encode() []byte <span class="cov0" title="0">{
        statsInternal := ValidatorStatisticsInternal{}
        statsInternal[0] = v.Current
        statsInternal[1] = v.Last
        encoded, err := types.Encode(statsInternal)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

func (v *ValidatorStatistics) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        decoded, dataLen, err := types.Decode(data, reflect.TypeOf(ValidatorStatisticsInternal{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov0" title="0">statsInternal := decoded.(ValidatorStatisticsInternal)
        recoveredStats := ValidatorStatistics{}
        recoveredStats.Current = statsInternal[0]
        recoveredStats.Last = statsInternal[1]

        return &amp;recoveredStats, dataLen</span>
}

/*
ReadyState                    [types.EpochLength][]Ready
AccumulatedHistory       [types.EpochLength]map[common.Hash]common.Hash // work-report hash to segment-root dictionary

type Ready struct { //AccumulationQueue
WorkReport       types.WorkReport
WorkPackageHashs []common.Hash
}
*/
func (b *Beta_state) MMR_Bytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := json.Marshal(b.B)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error serializing MMR", err)
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// Types for Psi
type Psi_state struct {
        Psi_g [][]byte           `json:"good"`      // SEQUENCE OF WorkReportHash (ByteArray32 in disputes.asn)
        Psi_b [][]byte           `json:"bad"`       // SEQUENCE OF WorkReportHash (ByteArray32 in disputes.asn)
        Psi_w [][]byte           `json:"wonky"`     // SEQUENCE OF WorkReportHash (ByteArray32 in disputes.asn)
        Psi_o []types.Ed25519Key `json:"offenders"` // SEQUENCE OF Ed25519Key (ByteArray32 in disputes.asn)
}

// Types for Rho
type Rho_state struct {
        WorkReport types.WorkReport `json:"report"`
        Timeslot   uint32           `json:"timeout"`
}

// Types for Gamma
type TicketsOrKeys struct {
        Tickets []*types.TicketBody `json:"tickets,omitempty"`
        Keys    []common.Hash       `json:"keys,omitempty"` //BandersnatchKey
}

type CTicketsOrKeys struct {
        Tickets *types.TicketsMark              `json:"tickets,omitempty"`
        Keys    *[types.EpochLength]common.Hash `json:"keys,omitempty"`
}

func (t TicketsOrKeys) TicketLen() int <span class="cov0" title="0">{
        if t.Tickets != nil </span><span class="cov0" title="0">{
                return len(t.Tickets)
        }</span>
        <span class="cov0" title="0">return 0</span>
}

type GammaK []types.Validator
type GammaZ []byte

type SafroleBasicState struct {
        GammaK GammaK             `json:"gamma_k"` // γk: Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        GammaZ GammaZ             `json:"gamma_z"` // γz: Epoch’s root, a Bandersnatch ring root composed with one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        GammaS TicketsOrKeys      `json:"gamma_s"` // γs: Current epoch’s slot-sealer series (epoch N)
        GammaA []types.TicketBody `json:"gamma_a"` // γa: Ticket accumulator for the next epoch (epoch N+1)
}

func (sbs SafroleBasicState) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                GammaK GammaK             `json:"gamma_k"`
                GammaZ string             `json:"gamma_z"`
                GammaS TicketsOrKeys      `json:"gamma_s"`
                GammaA []types.TicketBody `json:"gamma_a"`
        }{
                GammaK: sbs.GammaK,
                GammaZ: common.HexString(sbs.GammaZ),
                GammaS: sbs.GammaS,
                GammaA: sbs.GammaA,
        })
}</span>

func (sbs *SafroleBasicState) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                GammaK GammaK             `json:"gamma_k"`
                GammaZ string             `json:"gamma_z"`
                GammaS TicketsOrKeys      `json:"gamma_s"`
                GammaA []types.TicketBody `json:"gamma_a"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sbs.GammaK = s.GammaK
        sbs.GammaZ = common.FromHex(s.GammaZ)
        sbs.GammaS = s.GammaS
        sbs.GammaA = s.GammaA
        return nil</span>
}

// Types for Pi
type Pi_state struct {
        BlocksProduced         uint32 `json:"blocks"`          // The number of blocks produced by the validator.
        TicketsIntroduced      uint32 `json:"tickets"`         // The number of tickets introduced by the validator.
        PreimagesIntroduced    uint32 `json:"pre_images"`      // The number of preimages introduced by the validator.
        OctetsIntroduced       uint32 `json:"pre_images_size"` // The total number of octets across all preimages introduced by the validator.
        ReportsGuaranteed      uint32 `json:"guarantees"`      // The number of reports guaranteed by the validator.
        AvailabilityAssurances uint32 `json:"assurances"`      // The number of availability assurances made by the validator.
}

func NewJamState() *JamState <span class="cov8" title="1">{
        return &amp;JamState{
                //AvailabilityAssignments:  make([types.TotalCores]*Rho_state),
                SafroleState: NewSafroleState(),
        }
}</span>

// Copy creates a deep copy of the JamState struct
func (original *JamState) Copy() *JamState <span class="cov0" title="0">{
        copyState := &amp;JamState{
                AuthorizationsPool:       original.AuthorizationsPool,
                RecentBlocks:             original.RecentBlocks,
                SafroleStateGamma:        original.SafroleStateGamma,
                DisputesState:            original.DisputesState,
                PrivilegedServiceIndices: original.PrivilegedServiceIndices,
                ValidatorStatistics:      original.ValidatorStatistics,
                SafroleState:             original.SafroleState.Copy(),
                //AvailabilityAssignments:  make([types.TotalCores]*Rho_state),
                AuthorizationQueue:  original.AuthorizationQueue,
                AccumulationQueue:   original.AccumulationQueue,
                AccumulationHistory: original.AccumulationHistory,
        }

        for i, rhoState := range original.AvailabilityAssignments </span><span class="cov0" title="0">{
                if rhoState != nil </span><span class="cov0" title="0">{
                        copyState.AvailabilityAssignments[i] = &amp;Rho_state{
                                WorkReport: rhoState.WorkReport,
                                Timeslot:   rhoState.Timeslot,
                        }
                }</span>
        }

        <span class="cov0" title="0">return copyState</span>
}

// clearRhoByCore clears the Rho state for a specific core
func (state *JamState) String() string <span class="cov0" title="0">{
        // Marshal the JamState into indented JSON
        jsonBytes, err := json.MarshalIndent(state, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return "failedmarshaling"
        }</span>
        // Return the JSON as a string
        <span class="cov0" title="0">return string(jsonBytes)</span>
}

func (n *JamState) ResetTallyStatistics() <span class="cov0" title="0">{

        copy(n.ValidatorStatistics.Last[:], n.ValidatorStatistics.Current[:])
        n.ValidatorStatistics.Current = [types.TotalValidators]Pi_state{
                {BlocksProduced: 0, TicketsIntroduced: 0, PreimagesIntroduced: 0, OctetsIntroduced: 0, ReportsGuaranteed: 0, AvailabilityAssurances: 0},
        }
}</span>

// tallyStatistics updates the statistics for validators based on their activities.
func (n *JamState) tallyStatistics(validatorIndex uint32, activity string, cnt uint32) <span class="cov0" title="0">{
        // Update the statistics for the validator based on the activity

        switch activity </span>{
        case "blocks":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].BlocksProduced += cnt</span>
        case "tickets":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].TicketsIntroduced += cnt</span>
        case "preimages":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].PreimagesIntroduced += cnt</span>
        case "octets":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].OctetsIntroduced += cnt</span>
        case "reports":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].ReportsGuaranteed += cnt</span>
        case "assurances":<span class="cov0" title="0">
                n.ValidatorStatistics.Current[validatorIndex].AvailabilityAssurances += cnt</span>
        default:<span class="cov0" title="0">
                fmt.Println("Unknown activity:", activity)</span>
        }
}

func (j *JamState) newPartialState() *types.PartialState <span class="cov0" title="0">{
        return &amp;types.PartialState{
                D:                  make(map[uint32]*types.ServiceAccount),
                UpcomingValidators: j.SafroleState.DesignedValidators,
                QueueWorkReport:    j.AuthorizationQueue,
                PrivilegedState:    j.PrivilegedServiceIndices,
        }
}</span>

func (j *JamState) GetValidatorStats() string <span class="cov0" title="0">{
        out := ""
        for i := 0; i &lt; types.TotalValidators; i++ </span><span class="cov0" title="0">{
                v := ""
                pi := j.ValidatorStatistics.Current[i]
                if pi.BlocksProduced &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("b=%d", pi.BlocksProduced)
                }</span>
                <span class="cov0" title="0">if pi.TicketsIntroduced &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("|t=%d", pi.TicketsIntroduced)
                }</span>
                <span class="cov0" title="0">if pi.PreimagesIntroduced &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("|p=%d", pi.PreimagesIntroduced)
                }</span>
                <span class="cov0" title="0">if pi.OctetsIntroduced &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("|o=%d", pi.OctetsIntroduced)
                }</span>
                <span class="cov0" title="0">if pi.ReportsGuaranteed &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("|r=%d", pi.ReportsGuaranteed)
                }</span>
                <span class="cov0" title="0">if pi.AvailabilityAssurances &gt; 0 </span><span class="cov0" title="0">{
                        v += fmt.Sprintf("|a=%d", pi.AvailabilityAssurances)
                }</span>
                <span class="cov0" title="0">if len(v) &gt; 0 </span><span class="cov0" title="0">{
                        out += fmt.Sprintf("%d:[%s] ", i, v)
                }</span>
        }
        <span class="cov0" title="0">return out</span>

}

func (a *Psi_state) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Psi_g []string `json:"good"`
                Psi_b []string `json:"bad"`
                Psi_w []string `json:"wonky"`
                Psi_o []string `json:"offenders"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">for _, v := range s.Psi_g </span><span class="cov8" title="1">{
                a.Psi_g = append(a.Psi_g, common.FromHex(v))
        }</span>
        <span class="cov8" title="1">for _, v := range s.Psi_b </span><span class="cov8" title="1">{
                a.Psi_b = append(a.Psi_b, common.FromHex(v))
        }</span>
        <span class="cov8" title="1">for _, v := range s.Psi_w </span><span class="cov8" title="1">{
                a.Psi_w = append(a.Psi_w, common.FromHex(v))
        }</span>
        <span class="cov8" title="1">for _, v := range s.Psi_o </span><span class="cov8" title="1">{
                a.Psi_o = append(a.Psi_o, types.Ed25519Key(common.FromHex(v)))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (a Psi_state) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        psi_g := []string{}
        for _, v := range a.Psi_g </span><span class="cov8" title="1">{
                psi_g = append(psi_g, common.HexString(v))
        }</span>
        <span class="cov8" title="1">psi_b := []string{}
        for _, v := range a.Psi_b </span><span class="cov8" title="1">{
                psi_b = append(psi_b, common.HexString(v))
        }</span>
        <span class="cov8" title="1">psi_w := []string{}
        for _, v := range a.Psi_w </span><span class="cov8" title="1">{
                psi_w = append(psi_w, common.HexString(v))
        }</span>
        <span class="cov8" title="1">psi_o := []string{}
        for _, v := range a.Psi_o </span><span class="cov8" title="1">{
                psi_o = append(psi_o, common.HexString(v[:]))
        }</span>
        <span class="cov8" title="1">return json.Marshal(&amp;struct {
                Psi_g []string `json:"good"`
                Psi_b []string `json:"bad"`
                Psi_w []string `json:"wonky"`
                Psi_o []string `json:"offenders"`
        }{
                Psi_g: psi_g,
                Psi_b: psi_b,
                Psi_w: psi_w,
                Psi_o: psi_o,
        })</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package statedb

import (
        "reflect"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

/*
const (
        C1  = "CoreAuthPool"
        C2  = "AuthQueue"
        C3  = "RecentBlocks"
        C4  = "safroleState"
        C5  = "PastJudgements"
        C6  = "Entropy"
        C7  = "NextEpochValidatorKeys"
        C8  = "CurrentValidatorKeys"
        C9  = "PriorEpochValidatorKeys"
        C10 = "PendingReports"
        C11 = "MostRecentBlockTimeslot"
        C12 = "PrivilegedServiceIndices"
        C13 = "ActiveValidator"
        C14 = "AccumulationQueue"
        C15 = "AccumulationHistory"
)
*/

// C1 CoreAuthPool
func (n *JamState) SetAuthPool(authPoolByte []byte) <span class="cov0" title="0">{
        if len(authPoolByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">authorizationsPool, _, err := types.Decode(authPoolByte, reflect.TypeOf([types.TotalCores][]common.Hash{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.AuthorizationsPool = authorizationsPool.([types.TotalCores][]common.Hash)</span>
}

func (n *JamState) SetAuthQueue(authQueueByte []byte) <span class="cov0" title="0">{
        if len(authQueueByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">authorizationQueues, _, err := types.Decode(authQueueByte, reflect.TypeOf(types.AuthorizationQueue{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.AuthorizationQueue = authorizationQueues.(types.AuthorizationQueue)</span>
}

// C3 RecentBlocks
func (T Peaks) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return Peaks{}, 0
        }</span>

        <span class="cov0" title="0">peaks_len, length, err := types.Decode(data, reflect.TypeOf(uint(0)))
        if err != nil </span><span class="cov0" title="0">{
                return Peaks{}, 0
        }</span>

        <span class="cov0" title="0">if peaks_len.(uint) == 0 </span><span class="cov0" title="0">{
                return Peaks{}, length
        }</span>

        <span class="cov0" title="0">peaks := make([]*common.Hash, peaks_len.(uint))
        for i := 0; i &lt; int(peaks_len.(uint)); i++ </span><span class="cov0" title="0">{
                if length &gt;= uint32(len(data)) </span><span class="cov0" title="0">{
                        return Peaks{}, 0
                }</span>

                <span class="cov0" title="0">if data[length] == 0 </span><span class="cov0" title="0">{
                        peaks[i] = nil
                        length++
                }</span> else<span class="cov0" title="0"> if data[length] == 1 </span><span class="cov0" title="0">{
                        length++
                        decoded, l, err := types.Decode(data[length:], reflect.TypeOf(&amp;common.Hash{}))
                        if err != nil </span><span class="cov0" title="0">{
                                return Peaks{}, 0
                        }</span>
                        <span class="cov0" title="0">peaks[i] = decoded.(*common.Hash)
                        length += l</span>
                } else<span class="cov0" title="0"> {
                        return Peaks{}, 0
                }</span>
        }
        <span class="cov0" title="0">return peaks, length</span>
}

func (n *JamState) SetRecentBlocks(recentBlocksByte []byte) <span class="cov0" title="0">{
        if len(recentBlocksByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">recentBlocks, _, err := types.Decode(recentBlocksByte, reflect.TypeOf(RecentBlocks{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.RecentBlocks = recentBlocks.(RecentBlocks)</span>
}

// C4 safroleState
func (C CTicketsOrKeys) CT2T() TicketsOrKeys <span class="cov8" title="1">{
        var T TicketsOrKeys

        if C.Tickets != nil </span><span class="cov8" title="1">{
                T.Tickets = make([]*types.TicketBody, 0)
                for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov8" title="1">{
                        if (*C.Tickets)[i] != (types.TicketBody{}) </span><span class="cov8" title="1">{
                                ticket := (*C.Tickets)[i]
                                T.Tickets = append(T.Tickets, &amp;ticket)
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if C.Keys != nil </span><span class="cov8" title="1">{
                T.Keys = make([]common.Hash, 0)
                for i := 0; i &lt; types.EpochLength; i++ </span><span class="cov8" title="1">{
                        if (*C.Keys)[i] != (common.Hash{}) </span><span class="cov8" title="1">{
                                T.Keys = append(T.Keys, (*C.Keys)[i])
                        }</span> else<span class="cov0" title="0"> {
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return T</span>
}

func (T CTicketsOrKeys) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov8" title="1">switch data[0] </span>{
        case 0:<span class="cov8" title="1">
                decoded, length, err := types.Decode(data[1:], reflect.TypeOf(&amp;types.TicketsMark{}))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0
                }</span>
                <span class="cov8" title="1">ticketsMark := decoded.(*types.TicketsMark)
                T.Tickets = ticketsMark
                return T, length + 1</span>
        case 1:<span class="cov8" title="1">
                decoded, length, err := types.Decode(data[1:], reflect.TypeOf([types.EpochLength]common.Hash{}))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0
                }</span>
                <span class="cov8" title="1">keys := decoded.([types.EpochLength]common.Hash)
                T.Keys = &amp;keys
                return T, length + 1</span>
        }
        <span class="cov0" title="0">return nil, 0</span>
}

func (T TicketsOrKeys) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return TicketsOrKeys{}, 0
        }</span>
        <span class="cov8" title="1">var ticketsOrKeys TicketsOrKeys
        decoded, length, err := types.Decode(data, reflect.TypeOf(CTicketsOrKeys{}))
        if err != nil </span><span class="cov0" title="0">{
                return TicketsOrKeys{}, 0
        }</span>
        <span class="cov8" title="1">ticketsOrKeys = decoded.(CTicketsOrKeys).CT2T()
        return ticketsOrKeys, length</span>
}

func (Z GammaZ) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        decoded, length, err := types.Decode(data, reflect.TypeOf([144]byte{}))
        if err != nil </span><span class="cov0" title="0">{
                return GammaZ{}, 0
        }</span>
        <span class="cov8" title="1">gammaZ := make(GammaZ, 144)
        decodedArray := decoded.([144]byte)
        for i := 0; i &lt; 144; i++ </span><span class="cov8" title="1">{
                gammaZ[i] = decodedArray[i]
        }</span>
        <span class="cov8" title="1">return gammaZ, length</span>
}

func (K GammaK) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        decoded, length, err := types.Decode(data, reflect.TypeOf([types.TotalValidators]types.Validator{}))
        if err != nil </span><span class="cov0" title="0">{
                return GammaK{}, 0
        }</span>
        <span class="cov8" title="1">gammaK := make(GammaK, types.TotalValidators)
        decodedArray := decoded.([types.TotalValidators]types.Validator)
        for i := 0; i &lt; types.TotalValidators; i++ </span><span class="cov8" title="1">{
                gammaK[i] = decodedArray[i]
        }</span>
        <span class="cov8" title="1">return gammaK, length</span>
}

func (n *JamState) SetSafroleState(safroleStateByte []byte) <span class="cov0" title="0">{
        if len(safroleStateByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">safroleState, _, err := types.Decode(safroleStateByte, reflect.TypeOf(SafroleBasicState{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleStateGamma = safroleState.(SafroleBasicState)</span>
}

// C5 PastJudgements
func (P Psi_state) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        var s struct {
                Psi_g []common.Hash      `json:"good"`
                Psi_b []common.Hash      `json:"bad"`
                Psi_w []common.Hash      `json:"wonky"`
                Psi_o []types.Ed25519Key `json:"offenders"`
        }
        decoded, l, err := types.Decode(data, reflect.TypeOf(s))
        if err != nil </span><span class="cov0" title="0">{
                return Psi_state{}, 0
        }</span>
        <span class="cov8" title="1">sDecoded := decoded.(struct {
                Psi_g []common.Hash      `json:"good"`
                Psi_b []common.Hash      `json:"bad"`
                Psi_w []common.Hash      `json:"wonky"`
                Psi_o []types.Ed25519Key `json:"offenders"`
        })
        P.Psi_g = make([][]byte, len(sDecoded.Psi_g))
        for i, hash := range sDecoded.Psi_g </span><span class="cov8" title="1">{
                P.Psi_g[i] = hash[:]
        }</span>
        <span class="cov8" title="1">P.Psi_b = make([][]byte, len(sDecoded.Psi_b))
        for i, hash := range sDecoded.Psi_b </span><span class="cov8" title="1">{
                P.Psi_b[i] = hash[:]
        }</span>
        <span class="cov8" title="1">P.Psi_w = make([][]byte, len(sDecoded.Psi_w))
        for i, hash := range sDecoded.Psi_w </span><span class="cov8" title="1">{
                P.Psi_w[i] = hash[:]
        }</span>
        <span class="cov8" title="1">P.Psi_o = sDecoded.Psi_o
        return P, l</span>
}

func (j *JamState) SetPsi(psiByte []byte) <span class="cov0" title="0">{
        if len(psiByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">disputesState, _, err := types.Decode(psiByte, reflect.TypeOf(Psi_state{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">j.DisputesState = disputesState.(Psi_state)</span>
}

// C6 Entropy
func (n *JamState) SetEntropy(entropyByte []byte) <span class="cov0" title="0">{
        if len(entropyByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">entropy, _, err := types.Decode(entropyByte, reflect.TypeOf(Entropy{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleState.Entropy = entropy.(Entropy)</span>
}

// C7 NextEpochValidatorKeys
func (n *JamState) SetDesignedValidators(DesignedEpochValidatorsByte []byte) <span class="cov0" title="0">{
        if len(DesignedEpochValidatorsByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">DesignedEpochValidators, _, err := types.Decode(DesignedEpochValidatorsByte, reflect.TypeOf(types.Validators{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleState.DesignedValidators = DesignedEpochValidators.(types.Validators)</span>
}

// C8 CurrentValidatorKeys
func (n *JamState) SetCurrEpochValidators(currEpochValidatorsByte []byte) <span class="cov0" title="0">{
        if len(currEpochValidatorsByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">currEpochValidators, _, err := types.Decode(currEpochValidatorsByte, reflect.TypeOf(types.Validators{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleState.CurrValidators = currEpochValidators.(types.Validators)</span>
}

// C9 PriorEpochValidatorKeys
func (n *JamState) SetPriorEpochValidators(priorEpochValidatorsByte []byte) <span class="cov0" title="0">{
        if len(priorEpochValidatorsByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">priorEpochValidators, _, err := types.Decode(priorEpochValidatorsByte, reflect.TypeOf(types.Validators{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleState.PrevValidators = priorEpochValidators.(types.Validators)</span>
}

// C10 PendingReports
func (T AvailabilityAssignments) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        length := uint32(0)
        for i := 0; i &lt; len(T); i++ </span><span class="cov8" title="1">{
                if data[length] == 0 </span><span class="cov8" title="1">{
                        T[i] = nil
                        length++
                }</span> else<span class="cov8" title="1"> if data[length] == 1 </span><span class="cov8" title="1">{
                        length++
                        rho_state, l, err := types.Decode(data[length:], reflect.TypeOf(Rho_state{}))
                        if err != nil </span><span class="cov0" title="0">{
                                return AvailabilityAssignments{}, 0
                        }</span>
                        <span class="cov8" title="1">rho := rho_state.(Rho_state)
                        T[i] = &amp;rho
                        length += l</span>
                }
        }
        <span class="cov8" title="1">return T, length</span>
}

func (n *JamState) SetRho(rhoByte []byte) <span class="cov0" title="0">{
        if len(rhoByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">availabilityAssignments, _, err := types.Decode(rhoByte, reflect.TypeOf(AvailabilityAssignments{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.AvailabilityAssignments = availabilityAssignments.(AvailabilityAssignments)</span>
}

// C11 MostRecentBlockTimeslot
func (n *JamState) SetMostRecentBlockTimeSlot(mostRecentBlockTimeSlotByte []byte) <span class="cov0" title="0">{
        if len(mostRecentBlockTimeSlotByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">mostRecentBlockTimeSlot, _, err := types.Decode(mostRecentBlockTimeSlotByte, reflect.TypeOf(uint32(0)))
        //fmt.Printf("Recoved C11 MostRecentBlockTimeSlot=%v (byte=%v)\n", mostRecentBlockTimeSlot, mostRecentBlockTimeSlotByte)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.SafroleState.Timeslot = mostRecentBlockTimeSlot.(uint32)</span>
}

// C12 PrivilegedServiceIndices
func (n *JamState) SetPrivilegedServicesIndices(privilegedServicesIndicesByte []byte) <span class="cov0" title="0">{
        if len(privilegedServicesIndicesByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">privilegedServicesIndices, _, err := types.Decode(privilegedServicesIndicesByte, reflect.TypeOf(types.Kai_state{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.PrivilegedServiceIndices = privilegedServicesIndices.(types.Kai_state)</span>
}

// C13 ActiveValidator
func (n *JamState) SetPi(piByte []byte) <span class="cov0" title="0">{
        if len(piByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">validatorStatistics, _, err := types.Decode(piByte, reflect.TypeOf(ValidatorStatistics{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.ValidatorStatistics = validatorStatistics.(ValidatorStatistics)</span>
}

// C14 AccumulateQueue
func (n *JamState) SetAccumulateQueue(accumulateQueueByte []byte) <span class="cov0" title="0">{
        if len(accumulateQueueByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">validatorStatistics, _, err := types.Decode(accumulateQueueByte, reflect.TypeOf([types.EpochLength][]types.AccumulationQueue{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.AccumulationQueue = validatorStatistics.([types.EpochLength][]types.AccumulationQueue)</span>
}

// C15 AccumulateHistory
func (n *JamState) SetAccumulateHistory(accumulateHistoryByte []byte) <span class="cov0" title="0">{
        if len(accumulateHistoryByte) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">validatorStatistics, _, err := types.Decode(accumulateHistoryByte, reflect.TypeOf([types.EpochLength]types.AccumulationHistory{}))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">n.AccumulationHistory = validatorStatistics.([types.EpochLength]types.AccumulationHistory)</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package statedb

import (
        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

// C1
func (n *JamState) GetAuthPoolBytes() []byte <span class="cov0" title="0">{
        if len(n.AuthorizationsPool) == 0 </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(n.AuthorizationsPool)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

func (n *JamState) GetAuthQueueBytes() []byte <span class="cov0" title="0">{
        if len(n.AuthorizationQueue) == 0 </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(n.AuthorizationQueue)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C3
func (T Peaks) Encode() []byte <span class="cov0" title="0">{
        if len(T) == 0 </span><span class="cov0" title="0">{
                return []byte{0}
        }</span>

        <span class="cov0" title="0">encoded, err := types.Encode(uint(len(T)))
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(T); i++ </span><span class="cov0" title="0">{
                if T[i] == nil </span><span class="cov0" title="0">{
                        encoded = append(encoded, 0)
                }</span> else<span class="cov0" title="0"> {
                        encoded = append(encoded, 1)
                        encodedTi, err := types.Encode(T[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">encoded = append(encoded, encodedTi...)</span>
                }
        }
        <span class="cov0" title="0">return encoded</span>
}

func (n *JamState) GetRecentBlocksBytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := types.Encode(n.RecentBlocks)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C4
func (T TicketsOrKeys) T2CT() CTicketsOrKeys <span class="cov8" title="1">{
        var Tickets types.TicketsMark
        var Keys [types.EpochLength]common.Hash
        var C CTicketsOrKeys

        if T.Tickets != nil </span><span class="cov8" title="1">{
                n := len(T.Tickets)
                if n &gt; types.EpochLength </span><span class="cov0" title="0">{
                        // Handle the error or truncate the slice
                        n = types.EpochLength
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        Tickets[i] = *(T.Tickets)[i]
                }</span>
                <span class="cov8" title="1">C.Tickets = &amp;Tickets</span>
        }

        <span class="cov8" title="1">if T.Keys != nil </span><span class="cov8" title="1">{
                n := len(T.Keys)
                if n &gt; types.EpochLength </span><span class="cov0" title="0">{
                        // Handle the error or truncate the slice
                        n = types.EpochLength
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        Keys[i] = T.Keys[i]
                }</span>
                <span class="cov8" title="1">C.Keys = &amp;Keys</span>
        }

        <span class="cov8" title="1">return C</span>
}

func (T CTicketsOrKeys) Encode() []byte <span class="cov8" title="1">{
        if T.Tickets == nil &amp;&amp; T.Keys == nil || len(T.Tickets) == 0 &amp;&amp; len(T.Keys) == 0 </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">encoded := []byte{}
        if T.Tickets != nil &amp;&amp; T.Keys == nil </span><span class="cov8" title="1">{
                encoded = append(encoded, byte(0))
                encodedTickets, err := types.Encode(T.Tickets)
                if err != nil </span><span class="cov0" title="0">{
                        return []byte{}
                }</span>
                <span class="cov8" title="1">encoded = append(encoded, encodedTickets...)</span>
        }
        <span class="cov8" title="1">if T.Keys != nil &amp;&amp; T.Tickets == nil </span><span class="cov8" title="1">{
                encoded = append(encoded, byte(1))
                encodedKeys, err := types.Encode(T.Keys)
                if err != nil </span><span class="cov0" title="0">{
                        return []byte{}
                }</span>
                <span class="cov8" title="1">encoded = append(encoded, encodedKeys...)</span>
        }
        <span class="cov8" title="1">return encoded</span>
}

func (T TicketsOrKeys) Encode() []byte <span class="cov8" title="1">{
        CT := T.T2CT()
        encoded, err := types.Encode(CT)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">return encoded</span>
}

func (Z GammaZ) Encode() []byte <span class="cov8" title="1">{
        var gammaZ [144]byte
        copy(gammaZ[:], Z[:])
        encoded, err := types.Encode(gammaZ)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">return encoded</span>
}

func (K GammaK) Encode() []byte <span class="cov8" title="1">{
        var gammak [types.TotalValidators]types.Validator
        copy(gammak[:], K[:])
        encoded, err := types.Encode(gammak)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">return encoded</span>
}

func (s SafroleBasicState) GetSafroleStateBytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := types.Encode(s)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C5
func (P Psi_state) Encode() []byte <span class="cov8" title="1">{
        var psi_g []common.Hash
        for _, v := range P.Psi_g </span><span class="cov8" title="1">{
                psi_g = append(psi_g, common.BytesToHash(v))
        }</span>
        <span class="cov8" title="1">var psi_b []common.Hash
        for _, v := range P.Psi_b </span><span class="cov8" title="1">{
                psi_b = append(psi_b, common.BytesToHash(v))
        }</span>
        <span class="cov8" title="1">var psi_w []common.Hash
        for _, v := range P.Psi_w </span><span class="cov8" title="1">{
                psi_w = append(psi_w, common.BytesToHash(v))
        }</span>

        <span class="cov8" title="1">s := struct {
                Psi_g []common.Hash      `json:"good"`
                Psi_b []common.Hash      `json:"bad"`
                Psi_w []common.Hash      `json:"wonky"`
                Psi_o []types.Ed25519Key `json:"offenders"`
        }{
                Psi_g: psi_g,
                Psi_b: psi_b,
                Psi_w: psi_w,
                Psi_o: P.Psi_o,
        }
        encoded, err := types.Encode(s)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">return encoded</span>
}

func (j *JamState) GetPsiBytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := types.Encode(j.DisputesState)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C6
func (s *SafroleState) GetEntropyBytes() []byte <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(s.Entropy)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C7
func (s *SafroleState) GetNextEpochValidatorsBytes() []byte <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(s.NextValidators)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C8
func (s *SafroleState) GetCurrEpochValidatorsBytes() []byte <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(s.CurrValidators)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C9
func (s *SafroleState) GetPriorEpochValidatorsBytes() []byte <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(s.PrevValidators)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C10
func (T AvailabilityAssignments) Encode() []byte <span class="cov8" title="1">{
        encoded := []byte{}
        for i := 0; i &lt; len(T); i++ </span><span class="cov8" title="1">{
                if T[i] == nil </span><span class="cov8" title="1">{
                        encoded = append(encoded, []byte{0}...)
                }</span> else<span class="cov0" title="0"> {
                        encoded = append(encoded, []byte{1}...)
                        encodedTi, err := types.Encode(T[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return []byte{}
                        }</span>
                        <span class="cov0" title="0">encoded = append(encoded, encodedTi...)</span>
                }
        }
        <span class="cov8" title="1">return encoded</span>
}

func (n *JamState) GetRhoBytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := types.Encode(n.AvailabilityAssignments)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C11
func (s *SafroleState) GetMostRecentBlockTimeSlotBytes() []byte <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">codec_bytes, err := types.Encode(s.Timeslot)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C12
func (n *JamState) GetPrivilegedServicesIndicesBytes() []byte <span class="cov0" title="0">{
        codec_bytes, err := types.Encode(n.PrivilegedServiceIndices)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return codec_bytes</span>
}

// C13
func (n *JamState) GetPiBytes() []byte <span class="cov0" title="0">{
        encoded, err := types.Encode(n.ValidatorStatistics)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

// C14
func (n *JamState) GetAccumulationQueueBytes() []byte <span class="cov0" title="0">{
        encoded, err := types.Encode(n.AccumulationQueue)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

// C15
func (n *JamState) GetAccumulationHistoryBytes() []byte <span class="cov0" title="0">{
        encoded, err := types.Encode(n.AccumulationHistory)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package statedb

import (
        "encoding/json"
        "reflect"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

var orderedStateList = []string{
        "CoreAuthPool",             // C1
        "AuthQueue",                // C2
        "RecentBlocks",             // C3
        "safroleState",             // C4
        "PastJudgements",           // C5
        "Entropy",                  // C6
        "NextEpochValidatorKeys",   // C7
        "CurrentValidatorKeys",     // C8
        "PriorEpochValidatorKeys",  // C9
        "PendingReports",           // C10
        "MostRecentBlockTimeslot",  // C11
        "PrivilegedServiceIndices", // C12
        "ActiveValidator",          // C13
        "AccumulationQueue",        // C14
        "AccumulationHistory",      // C15
}

// C1 - C15
type StateSnapshot struct {
        AuthorizationsPool       [types.TotalCores][]common.Hash              `json:"alpha"`           // c1
        AuthorizationQueue       types.AuthorizationQueue                     `json:"varphi"`          // c2
        RecentBlocks             RecentBlocks                                 `json:"beta"`            // c3
        Gamma                    SafroleBasicState                            `json:"gamma"`           // c4
        Disputes                 Psi_state                                    `json:"psi"`             // c5
        Entropy                  Entropy                                      `json:"eta"`             // c6
        NextValidators           types.Validators                             `json:"iota"`            // c7
        CurrValidators           types.Validators                             `json:"kappa"`           // c8
        PrevValidators           types.Validators                             `json:"lambda"`          // c9
        AvailabilityAssignments  AvailabilityAssignments                      `json:"rho"`             // c10
        Timeslot                 uint32                                       `json:"tau"`             // c11
        PrivilegedServiceIndices types.Kai_state                              `json:"chi"`             // c12
        ValidatorStatistics      ValidatorStatistics                          `json:"pi"`              // c13
        AccumulationQueue        [types.EpochLength][]types.AccumulationQueue `json:"theta"`           // c14 Accumulation Queue
        AccumulationHistory      [types.EpochLength]types.AccumulationHistory `json:"xi"`              // c15 Accumulation History
        ServiceAccount           KeyVals                                      `json:"service_account"` // Other C
}

type KeyVal struct {
        Key        []byte `json:"k"`
        Value      []byte `json:"v"`
        StructType string `json:"struct_type,omitempty"`
        Metadata   string `json:"meta,omitempty"`
}

type KeyVals []KeyVal

type KeyValMap map[common.Hash][]byte

// func (kv KeyVals) Encode() []byte {
//         m := make(KeyValMap)
//         for _, kv := range kv {
//                 m[common.BytesToHash(kv[0])] = kv[1]
//         }
//         encoded, err := types.Encode(m)
//         if err != nil {
//                 panic(err)
//         }
//         return encoded
// }

// func (kv KeyVals) Decode(encoded []byte) (interface{}, uint32) {
//         decoded, l, err := types.Decode(encoded, reflect.TypeOf(KeyValMap{}))
//         if err != nil {
//                 panic(err)
//         }
//         m := decoded.(KeyValMap)
//         for k, v := range m {
//                 kv = append(kv, KeyVal{k.Bytes(), v})
//         }
//         return kv, l
// }

type StateSnapshotRaw struct {
        StateRoot common.Hash `json:"state_root"`
        KeyVals   KeyVals     `json:"keyvals"`
}

func (sn *StateSnapshot) Raw() *StateSnapshotRaw <span class="cov0" title="0">{
        //convert this from our struct format into this keyval format..

        /*
                t.SetState(C1, coreAuthPoolEncode)
                t.SetState(C2, authQueueEncode)
                t.SetState(C3, recentBlocksEncode)
                t.SetState(C4, safroleStateEncode)
                t.SetState(C5, disputeState)
                t.SetState(C6, entropyEncode)
                t.SetState(C7, nextEpochValidatorsEncode)
                t.SetState(C8, currEpochValidatorsEncode)
                t.SetState(C9, priorEpochValidatorEncode)
                t.SetState(C10, rhoEncode)
                t.SetState(C11, mostRecentBlockTimeSlotEncode)
                t.SetState(C12, privilegedServiceIndicesEncode)
                t.SetState(C13, piEncode)
                t.SetState(C14, accumulateQueueEncode)
                t.SetState(C15, accumulateHistoryEncode)
        */

        keyValList := make(KeyVals, 0)

        for _, _stateIdentifier := range orderedStateList </span><span class="cov0" title="0">{
                stateKey := make([]byte, 32)
                stateVal := []byte{}
                switch _stateIdentifier </span>{
                case C1:<span class="cov0" title="0">
                        stateKey[0] = 0x01
                        stateVal, _ = types.Encode(sn.AuthorizationsPool)</span>
                case C2:<span class="cov0" title="0">
                        stateKey[0] = 0x02
                        stateVal, _ = types.Encode(sn.AuthorizationQueue)</span>
                case C3:<span class="cov0" title="0">
                        stateKey[0] = 0x03
                        stateVal, _ = types.Encode(sn.RecentBlocks)</span>
                case C4:<span class="cov0" title="0">
                        stateKey[0] = 0x04
                        stateVal, _ = types.Encode(sn.Gamma)</span>
                case C5:<span class="cov0" title="0">
                        stateKey[0] = 0x05
                        stateVal, _ = types.Encode(sn.Disputes)</span>
                case C6:<span class="cov0" title="0">
                        stateKey[0] = 0x06
                        stateVal, _ = types.Encode(sn.Entropy)</span>
                case C7:<span class="cov0" title="0">
                        stateKey[0] = 0x07
                        stateVal, _ = types.Encode(sn.NextValidators)</span>
                case C8:<span class="cov0" title="0">
                        stateKey[0] = 0x08
                        stateVal, _ = types.Encode(sn.CurrValidators)</span>
                case C9:<span class="cov0" title="0">
                        stateKey[0] = 0x09
                        stateVal, _ = types.Encode(sn.PrevValidators)</span>
                case C10:<span class="cov0" title="0">
                        stateKey[0] = 0x0A
                        stateVal, _ = types.Encode(sn.AvailabilityAssignments)</span>
                case C11:<span class="cov0" title="0">
                        stateKey[0] = 0x0B
                        stateVal, _ = types.Encode(sn.Timeslot)</span>
                case C12:<span class="cov0" title="0">
                        stateKey[0] = 0x0C
                        stateVal, _ = types.Encode(sn.PrivilegedServiceIndices)</span>
                case C13:<span class="cov0" title="0">
                        stateKey[0] = 0x0D
                        stateVal, _ = types.Encode(sn.ValidatorStatistics)</span>
                case C14:<span class="cov0" title="0">
                        stateKey[0] = 0x0E
                        stateVal, _ = types.Encode(sn.AccumulationQueue)</span>
                case C15:<span class="cov0" title="0">
                        stateKey[0] = 0x0F
                        stateVal, _ = types.Encode(sn.AccumulationQueue)</span>
                default:<span class="cov0" title="0"></span>

                }
                <span class="cov0" title="0">kv := KeyVal{}
                kv.Key = stateKey
                kv.Value = stateVal
                keyValList = append(keyValList, kv)</span>
        }

        <span class="cov0" title="0">snapshotRaw := StateSnapshotRaw{
                KeyVals: keyValList,
        }
        return &amp;snapshotRaw</span>
}

func (kv KeyVal) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        hexStrings := [4]string{
                common.HexString(kv.Key),
                common.HexString(kv.Value),
                kv.StructType,
                kv.Metadata,
        }
        return json.Marshal(hexStrings)
}</span>

func (kv *KeyVal) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var hexStrings [4]string
        if err := json.Unmarshal(data, &amp;hexStrings); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">keyBytes := common.Hex2Bytes(hexStrings[0])
        kv.Key = keyBytes
        valueBytes := common.Hex2Bytes(hexStrings[1])
        kv.Value = valueBytes
        kv.StructType = hexStrings[2]
        kv.Metadata = hexStrings[3]

        return nil</span>
}

func (snr *StateSnapshotRaw) FromStateSnapshotRaw() *StateSnapshot <span class="cov0" title="0">{
        sn := StateSnapshot{}
        for idx, kv := range snr.KeyVals </span><span class="cov0" title="0">{
                _stateIdentifier := orderedStateList[idx]
                // TODO: we should use kv[0] to determine what _stateIdentifier we are talking about
                //k := kv[0]
                switch _stateIdentifier </span>{
                case C1:<span class="cov0" title="0">
                        authorizationsPool, _, _ := types.Decode(kv.Value, reflect.TypeOf([types.TotalCores][]common.Hash{}))
                        sn.AuthorizationsPool = authorizationsPool.([types.TotalCores][]common.Hash)</span>
                case C2:<span class="cov0" title="0">
                        authorizationQueue, _, _ := types.Decode(kv.Value, reflect.TypeOf(types.AuthorizationQueue{}))
                        sn.AuthorizationQueue = authorizationQueue.(types.AuthorizationQueue)</span>
                case C3:<span class="cov0" title="0">
                        recentBlocks, _, _ := types.Decode(kv.Value, reflect.TypeOf(RecentBlocks{}))
                        sn.RecentBlocks = recentBlocks.(RecentBlocks)</span>
                case C4:<span class="cov0" title="0">
                        gamma, _, _ := types.Decode(kv.Value, reflect.TypeOf(SafroleBasicState{}))
                        sn.Gamma = gamma.(SafroleBasicState)</span>
                case C5:<span class="cov0" title="0">
                        disputes, _, _ := types.Decode(kv.Value, reflect.TypeOf(Psi_state{}))
                        sn.Disputes = disputes.(Psi_state)</span>
                case C6:<span class="cov0" title="0">
                        entropy, _, _ := types.Decode(kv.Value, reflect.TypeOf(Entropy{}))
                        sn.Entropy = entropy.(Entropy)</span>
                case C7:<span class="cov0" title="0">
                        nextValidators, _, _ := types.Decode(kv.Value, reflect.TypeOf(types.Validators{}))
                        sn.NextValidators = nextValidators.(types.Validators)</span>
                case C8:<span class="cov0" title="0">
                        currValidators, _, _ := types.Decode(kv.Value, reflect.TypeOf(types.Validators{}))
                        sn.CurrValidators = currValidators.(types.Validators)</span>
                case C9:<span class="cov0" title="0">
                        prevValidators, _, _ := types.Decode(kv.Value, reflect.TypeOf(types.Validators{}))
                        sn.PrevValidators = prevValidators.(types.Validators)</span>
                case C10:<span class="cov0" title="0">
                        availabilityAssignments, _, _ := types.Decode(kv.Value, reflect.TypeOf(AvailabilityAssignments{}))
                        sn.AvailabilityAssignments = availabilityAssignments.(AvailabilityAssignments)</span>
                case C11:<span class="cov0" title="0">
                        timeslot, _, _ := types.Decode(kv.Value, reflect.TypeOf(uint32(0)))
                        sn.Timeslot = timeslot.(uint32)</span>
                case C12:<span class="cov0" title="0">
                        privilegedServiceIndices, _, _ := types.Decode(kv.Value, reflect.TypeOf(types.Kai_state{}))
                        sn.PrivilegedServiceIndices = privilegedServiceIndices.(types.Kai_state)</span>
                case C13:<span class="cov0" title="0">
                        validatorStatistics, _, _ := types.Decode(kv.Value, reflect.TypeOf(ValidatorStatistics{}))
                        sn.ValidatorStatistics = validatorStatistics.(ValidatorStatistics)</span>
                case C14:<span class="cov0" title="0">
                        validatorStatistics, _, _ := types.Decode(kv.Value, reflect.TypeOf([types.EpochLength][]types.AccumulationQueue{}))
                        sn.AccumulationQueue = validatorStatistics.([types.EpochLength][]types.AccumulationQueue)</span>
                case C15:<span class="cov0" title="0">
                        validatorStatistics, _, _ := types.Decode(kv.Value, reflect.TypeOf([types.EpochLength]types.AccumulationHistory{}))
                        sn.AccumulationHistory = validatorStatistics.([types.EpochLength]types.AccumulationHistory)</span>

                default:<span class="cov0" title="0"></span>

                }
        }
        <span class="cov0" title="0">return &amp;sn</span>
}

func (n *JamState) Snapshot() *StateSnapshot <span class="cov0" title="0">{
        original := n.SafroleState
        copied := &amp;StateSnapshot{
                AuthorizationsPool:       n.AuthorizationsPool,                                  // C1 -- todo
                AuthorizationQueue:       n.AuthorizationQueue,                                  // C2 -- todo
                RecentBlocks:             n.RecentBlocks,                                        // C3 -- todo
                Gamma:                    n.SafroleState.GetSafroleBasicState().Copy(),          // C4
                Disputes:                 n.DisputesState,                                       // C5 -- todo
                Entropy:                  n.SafroleState.Entropy,                                // C6
                NextValidators:           make([]types.Validator, len(original.NextValidators)), // C7
                CurrValidators:           make([]types.Validator, len(original.CurrValidators)), // C8
                PrevValidators:           make([]types.Validator, len(original.PrevValidators)), // C9
                AvailabilityAssignments:  n.AvailabilityAssignments,                             // C10 -- todo
                Timeslot:                 n.SafroleState.Timeslot,                               // C11
                PrivilegedServiceIndices: n.PrivilegedServiceIndices,                            // C12 -- todo
                ValidatorStatistics:      n.ValidatorStatistics,                                 // C13
                AccumulationQueue:        n.AccumulationQueue,                                   // C14
                AccumulationHistory:      n.AccumulationHistory,                                 // C15
        }
        copy(copied.Entropy[:], original.Entropy[:])
        copy(copied.PrevValidators, original.PrevValidators)
        copy(copied.CurrValidators, original.CurrValidators)
        copy(copied.NextValidators, original.NextValidators)
        for j := 0; j &lt; types.TotalValidators; j++ </span><span class="cov0" title="0">{
                copied.ValidatorStatistics.Current[j] = n.ValidatorStatistics.Current[j]
                copied.ValidatorStatistics.Last[j] = n.ValidatorStatistics.Last[j]
        }</span>
        <span class="cov0" title="0">return copied</span>
}

func (original TicketsOrKeys) Copy() TicketsOrKeys <span class="cov0" title="0">{
        // Only one of either Tickets or Keys can have a value, so they cannot be initialized with `make` beforehand.
        if original.Tickets != nil &amp;&amp; original.Keys == nil </span><span class="cov0" title="0">{
                copid := TicketsOrKeys{
                        Tickets: make([]*types.TicketBody, len(original.Tickets)),
                }
                copy(copid.Tickets[:], original.Tickets[:])
                return copid
        }</span> else<span class="cov0" title="0"> if original.Tickets == nil &amp;&amp; original.Keys != nil </span><span class="cov0" title="0">{
                copid := TicketsOrKeys{
                        Keys: make([]common.Hash, len(original.Keys)),
                }
                copy(copid.Keys[:], original.Keys[:])
                return copid
        }</span>
        <span class="cov0" title="0">return TicketsOrKeys{}</span>
}

func (original SafroleBasicState) Copy() SafroleBasicState <span class="cov0" title="0">{
        copied := SafroleBasicState{
                GammaK: make([]types.Validator, len(original.GammaK)),
                GammaA: make([]types.TicketBody, len(original.GammaA)),
                GammaS: original.GammaS.Copy(),
                GammaZ: make([]byte, len(original.GammaZ)),
        }
        copy(copied.GammaK[:], original.GammaK[:])
        copy(copied.GammaA[:], original.GammaA[:])
        copy(copied.GammaZ[:], original.GammaZ[:])
        return copied
}</span>

func (s *StateSnapshot) String() string <span class="cov0" title="0">{
        jsonEncode, _ := json.MarshalIndent(s, "", "  ") // Indent with 2 spaces
        return string(jsonEncode)
}</span>

func (snr *StateSnapshotRaw) String() string <span class="cov0" title="0">{
        jsonEncode, _ := json.MarshalIndent(snr, "", "  ") // Indent with 2 spaces
        return string(jsonEncode)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package statedb

import (
        "bytes"
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "math"
        "os"
        "reflect"
        "strings"
        "sync"
        "time"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/pvm"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/trie"
        "github.com/colorfulnotion/jam/types"
)

type StateDB struct {
        Finalized        bool
        Id               uint16       `json:"id"`
        Block            *types.Block `json:"block"`
        ParentHeaderHash common.Hash  `json:"parentHeaderHash"`
        HeaderHash       common.Hash  `json:"headerHash"`

        StateRoot common.Hash `json:"stateRoot"`
        JamState  *JamState   `json:"Jamstate"`
        sdb       *storage.StateDBStorage
        trie      *trie.MerkleTree

        VMs     map[uint32]*pvm.VM
        vmMutex sync.Mutex

        // used in ApplyStateRecentHistory between statedbs
        AccumulationRoot common.Hash

        X *types.XContext

        GuarantorAssignments         []types.GuarantorAssignment
        PreviousGuarantorAssignments []types.GuarantorAssignment
        AvailableWorkReport          []types.WorkReport // every block has its own available work report

        logChan chan storage.LogMessage

        AncestorSet []types.BlockHeader // AncestorSet is a set of block headers which include the recent 24 hrs of blocks
}

func (s *StateDB) writeLog(obj interface{}, timeslot uint32) <span class="cov0" title="0">{
        s.sdb.WriteLog(obj, timeslot)
}</span>

func (s *StateDB) ProcessIncomingJudgement(j types.Judgement) {<span class="cov0" title="0">
        // get the disputes state

}</span>

func (s *StateDB) getValidatorCredential() []byte <span class="cov0" title="0">{
        // TODO
        return nil
}</span>

func (s *StateDB) CheckIncomingAssurance(a *types.Assurance) (err error) <span class="cov0" title="0">{
        cred := s.GetSafrole().GetCurrValidator(int(a.ValidatorIndex))
        err = a.Verify(cred)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Invalid Assurance. Err=%v\n", err)
                return
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// IsAuthorizedPVM performs the is-authorized PVM function.
func IsAuthorizedPVM(workPackage types.WorkPackage) (bool, error) <span class="cov0" title="0">{
        // Ensure the work-package warrants the needed core-time
        // Ensure all segment-tree roots which form imported segment commitments are known and valid
        // Ensure that all preimage data referenced as commitments of extrinsic segments can be fetched

        // For demonstration, let's assume these checks are passed
        //for _, workItem := range workPackage.WorkItems {

        //}

        return true, nil
}</span>

// EP Errors
const (
        debug                     = false
        debugA                    = false
        debugG                    = false
        debugP                    = false
        debugAudit                = false
        debugSeal                 = false
        trace                     = false
        errServiceIndices         = "ServiceIndices duplicated or not ordered"
        errPreimageLookupNotSet   = "Preimagelookup (h,l) not set"
        errPreimageLookupNotEmpty = "Preimagelookup not empty"
        errPreimageBlobSet        = "PreimageBlob already set"
)

func (s *StateDB) ValidateLookup(l *types.Preimages) (common.Hash, error) <span class="cov0" title="0">{
        // check 157 - (1) a_p not equal to P (2) a_l is empty
        t := s.GetTrie()
        a_p := l.AccountPreimageHash()
        //a_l := l.AccountLookupHash()
        preimage_blob, ok, err := t.GetPreImageBlob(l.Service_Index(), l.BlobHash())
        if err == nil &amp;&amp; ok </span><span class="cov0" title="0">{ // key found
                if l.BlobHash() == common.Blake2Hash(preimage_blob) </span><span class="cov0" title="0">{
                        //H(p) = p
                        fmt.Printf("Fail at 157 - (1) preimage already integrated\n")
                        return common.Hash{}, fmt.Errorf(errPreimageBlobSet)
                }</span>
        }

        //fmt.Printf("Validating E_p %v\n",l.String())
        <span class="cov0" title="0">anchors, ok, err := t.GetPreImageLookup(l.Service_Index(), l.BlobHash(), l.BlobLength())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Fail at anchor not set, service idx %v, blob hash %v, blob length %v\n", l.Service_Index(), l.BlobHash(), l.BlobLength())
                // va := s.GetAllKeyValues() // ISSUE: this does NOT show 00 but PrintTree does!
                t.PrintAllKeyValues()
                t.PrintTree(t.Root, 0)
                return common.Hash{}, fmt.Errorf(errPreimageLookupNotSet) //TODO: differentiate key not found vs leveldb error
        }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                fmt.Printf("Can't find the anchor, service idx %v, blob hash %v, blob length %v\n", l.Service_Index(), l.BlobHash(), l.BlobLength())
                // va := s.GetAllKeyValues() // ISSUE: this does NOT show 00 but PrintTree does!
                t.PrintAllKeyValues()
                t.PrintTree(t.Root, 0)
                return common.Hash{}, fmt.Errorf(errPreimageLookupNotSet) //TODO: differentiate key not found vs leveldb error
        }</span>
        <span class="cov0" title="0">if len(anchors) == 1 </span><span class="cov0" title="0">{ // we have to forget it -- check!
                return common.Hash{}, fmt.Errorf(errPreimageLookupNotEmpty)
        }</span>
        <span class="cov0" title="0">return a_p, nil</span>
}
func newEmptyStateDB(sdb *storage.StateDBStorage) (statedb *StateDB) <span class="cov8" title="1">{
        statedb = new(StateDB)
        statedb.SetStorage(sdb)
        statedb.trie = trie.NewMerkleTree(nil, sdb)
        statedb.logChan = make(chan storage.LogMessage, 100)
        return statedb
}</span>

// state-key constructor functions C(X)
const (
        C1  = "CoreAuthPool"
        C2  = "AuthQueue"
        C3  = "RecentBlocks"
        C4  = "safroleState"
        C5  = "PastJudgements"
        C6  = "Entropy"
        C7  = "NextEpochValidatorKeys"
        C8  = "CurrentValidatorKeys"
        C9  = "PriorEpochValidatorKeys"
        C10 = "PendingReports"
        C11 = "MostRecentBlockTimeslot"
        C12 = "PrivilegedServiceIndices"
        C13 = "ActiveValidator"
        C14 = "AccumulationQueue"
        C15 = "AccumulationHistory"
)

// Initial services
const (
        BootstrapServiceCode = 0
        BootstrapServiceFile = "/services/bootstrap.pvm"
)

func (s *StateDB) GetHeaderHash() common.Hash <span class="cov0" title="0">{
        return s.Block.Header.Hash()
}</span>

func (s *StateDB) GetStateRoot() common.Hash <span class="cov0" title="0">{
        return s.StateRoot
}</span>

func (s *StateDB) GetTentativeStateRoot() common.Hash <span class="cov0" title="0">{
        // return the trie root at the moment
        t := s.GetTrie()
        return t.GetRoot()
}</span>

func (s *StateDB) GetTrie() *trie.MerkleTree <span class="cov8" title="1">{
        return s.trie
}</span>

func (s *StateDB) GetStorage() *storage.StateDBStorage <span class="cov0" title="0">{
        return s.sdb
}</span>

func (s *StateDB) SetStorage(sdb *storage.StateDBStorage) <span class="cov8" title="1">{
        s.sdb = sdb
}</span>

func (s *StateDB) GetSafrole() *SafroleState <span class="cov8" title="1">{
        return s.JamState.SafroleState
}</span>

func (s *StateDB) GetJamState() *JamState <span class="cov8" title="1">{
        return s.JamState
}</span>

func (s *StateDB) SetJamState(jamState *JamState) <span class="cov0" title="0">{
        s.JamState = jamState
}</span>

func (s *StateDB) GetJamSnapshot() *StateSnapshot <span class="cov0" title="0">{
        return s.JamState.Snapshot()
}</span>

func (s *StateDB) RecoverJamState(stateRoot common.Hash) <span class="cov0" title="0">{
        // Now read C1.....C15 from the trie and put it back into JamState
        //t := s.GetTrie()

        t := s.CopyTrieState(stateRoot)

        coreAuthPoolEncode, err := t.GetState(C1)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C1 CoreAuthPool from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">authQueueEncode, err := t.GetState(C2)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C2 AuthQueue from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">recentBlocksEncode, err := t.GetState(C3)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C3 RecentBlocks from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">safroleStateEncode, err := t.GetState(C4)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C4 SafroleState from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">disputeStateEncode, err := t.GetState(C5)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C5 DisputeState from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">entropyEncode, err := t.GetState(C6)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C6 Entropy from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">DesignedEpochValidatorsEncode, err := t.GetState(C7)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C7 NextEpochValidators from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">currEpochValidatorsEncode, err := t.GetState(C8)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C8 CurrentEpochValidators from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">priorEpochValidatorEncode, err := t.GetState(C9)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C9 PriorEpochValidators from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">rhoEncode, err := t.GetState(C10)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C10 Rho from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">mostRecentBlockTimeSlotEncode, err := t.GetState(C11)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C11 MostRecentBlockTimeSlot from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">privilegedServiceIndicesEncode, err := t.GetState(C12)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C12 PrivilegedServiceIndices from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">piEncode, err := t.GetState(C13)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C13 ActiveValidator from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">accunulateQueueEncode, err := t.GetState(C14)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C14 accunulateQueue from trie: %v\n", err)
        }</span>
        <span class="cov0" title="0">accunulateHistoryEncode, err := t.GetState(C15)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading C15 accunulateHistory from trie: %v\n", err)
        }</span>
        //Decode(authQueueEncode) -&gt; AuthorizationQueue
        //set AuthorizationQueue back to JamState

        // fmt.Printf("retrieved C7 NextEpochValidators %v\n", nextEpochValidatorsEncode)
        // fmt.Printf("retrieved C8 CurrentEpochValidators%v\n", currEpochValidatorsEncode)
        // fmt.Printf("retrieved C9 PriorEpochValidators%v\n", priorEpochValidatorEncode)
        // fmt.Printf("retrieved C7 NextEpochValidators %v\n", nextEpochValidatorsEncode)
        // fmt.Printf("retrieved C8 CurrentEpochValidators%v\n", currEpochValidatorsEncode)
        // fmt.Printf("retrieved C9 PriorEpochValidators%v\n", priorEpochValidatorEncode)

        <span class="cov0" title="0">d := s.GetJamState()
        d.SetAuthPool(coreAuthPoolEncode)
        d.SetAuthQueue(authQueueEncode)
        d.SetRecentBlocks(recentBlocksEncode)
        d.SetSafroleState(safroleStateEncode)
        d.SetPsi(disputeStateEncode)
        d.SetEntropy(entropyEncode)
        d.SetDesignedValidators(DesignedEpochValidatorsEncode)
        d.SetCurrEpochValidators(currEpochValidatorsEncode)
        d.SetPriorEpochValidators(priorEpochValidatorEncode)
        d.SetMostRecentBlockTimeSlot(mostRecentBlockTimeSlotEncode)
        d.SetRho(rhoEncode)

        d.SetPrivilegedServicesIndices(privilegedServiceIndicesEncode)
        d.SetPi(piEncode)
        d.SetAccumulateQueue(accunulateQueueEncode)
        d.SetAccumulateHistory(accunulateHistoryEncode)
        s.SetJamState(d)</span>
        //fmt.Printf("[N%v] RecoverJamState jam state: %s -- safrolestate: %s\n", s.Id, d.String(), d.SafroleState.String())
}

func (s *StateDB) UpdateTrieState() common.Hash <span class="cov0" title="0">{
        //γ ≡⎩γk, γz, γs, γa⎭
        //γk :one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        //γz :epoch’s root, a Bandersnatch ring root composed with the one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        //γa :the ticket accumulator, a series of highest-scoring ticket identifiers to be used for the next epoch (epoch N+1)
        //γs :current epoch’s slot-sealer series, which is either a full complement of E tickets or, in the case of a fallback mode, a series of E Bandersnatch keys (epoch N)
        sf := s.GetSafrole()
        if sf == nil </span><span class="cov0" title="0">{
                fmt.Printf("NO SAFROLE %v", s)
                panic(222)</span>
        }
        <span class="cov0" title="0">sb := sf.GetSafroleBasicState()
        safroleStateEncode := sb.GetSafroleStateBytes()
        entropyEncode := sf.GetEntropyBytes()
        nextEpochValidatorsEncode := sf.GetNextEpochValidatorsBytes()
        currEpochValidatorsEncode := sf.GetCurrEpochValidatorsBytes()
        priorEpochValidatorEncode := sf.GetPriorEpochValidatorsBytes()
        mostRecentBlockTimeSlotEncode := sf.GetMostRecentBlockTimeSlotBytes()

        d := s.GetJamState()
        disputeState := d.GetPsiBytes()
        rhoEncode := d.GetRhoBytes()
        piEncode := d.GetPiBytes()
        coreAuthPoolEncode := d.GetAuthPoolBytes()
        authQueueEncode := d.GetAuthQueueBytes()
        privilegedServiceIndicesEncode := d.GetPrivilegedServicesIndicesBytes()
        recentBlocksEncode := d.GetRecentBlocksBytes()

        accunulateQueueEncode := d.GetAccumulationQueueBytes()
        accunulateHistoryEncode := d.GetAccumulationHistoryBytes()

        t := s.GetTrie()
        prev_root := t.GetRoot()
        debug := false
        verify := true
        t.SetState(C1, coreAuthPoolEncode)
        t.SetState(C2, authQueueEncode)
        t.SetState(C3, recentBlocksEncode)
        t.SetState(C4, safroleStateEncode)
        t.SetState(C5, disputeState)
        t.SetState(C6, entropyEncode)
        t.SetState(C7, nextEpochValidatorsEncode)
        t.SetState(C8, currEpochValidatorsEncode)
        t.SetState(C9, priorEpochValidatorEncode)
        t.SetState(C10, rhoEncode)
        t.SetState(C11, mostRecentBlockTimeSlotEncode)
        t.SetState(C12, privilegedServiceIndicesEncode)
        t.SetState(C13, piEncode)
        t.SetState(C14, accunulateQueueEncode)
        t.SetState(C15, accunulateHistoryEncode)
        updated_root := t.GetRoot()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%v] UpdateTrieState - before root:%v\n", s.Id, prev_root)
                fmt.Printf("[N%v] UpdateTrieState - after root:%v\n", s.Id, updated_root)
                // fmt.Printf("C1 coreAuthPoolEncode %x \n", coreAuthPoolEncode)
                // fmt.Printf("C2 authQueueEncode %x \n", authQueueEncode)
                // fmt.Printf("C3 recentBlocksEncode %x \n", recentBlocksEncode)
                // fmt.Printf("C4 safroleStateEncode %x \n", safroleStateEncode)
                // fmt.Printf("C5 disputeState %x \n", disputeState)
                // fmt.Printf("C6 entropyEncode %x \n", entropyEncode)
                // fmt.Printf("C7 nextEpochValidatorsEncode %x \n", nextEpochValidatorsEncode)
                // fmt.Printf("C8 currEpochValidatorsEncode %x \n", currEpochValidatorsEncode)
                // fmt.Printf("C9 priorEpochValidatorEncode %x \n", priorEpochValidatorEncode)
                // fmt.Printf("C10 rhoEncode %x \n", rhoEncode)
                // fmt.Printf("C11 mostRecentBlockTimeSlotEncode %x \n", mostRecentBlockTimeSlotEncode)
                // fmt.Printf("C12 privilegedServiceIndicesEncode %x \n", privilegedServiceIndicesEncode)
                // fmt.Printf("C13 piEncode %x \n", piEncode)
                // fmt.Printf("C14 accunulateQueueEncode %x \n", accunulateQueueEncode)
                // fmt.Printf("C15 accunulateHistoryEncode %x \n", accunulateHistoryEncode)
        }</span>

        <span class="cov0" title="0">if debug || verify </span><span class="cov0" title="0">{
                t2, _ := trie.InitMerkleTreeFromHash(updated_root.Bytes(), s.sdb)
                checkingResult, err := CheckingAllState(t, t2)
                if !checkingResult || err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("CheckingAllState ERROR: %v\n", err))</span>
                }
        }

        /*
                // use C1
                startKey := common.Hex2Bytes("0x0100000000000000000000000000000000000000000000000000000000000000")

                // use C14
                endKey := common.Hex2Bytes("0x0d00000000000000000000000000000000000000000000000000000000000000")

                // maxSize
                maxSize := uint32(10000)
                foundKeyVal, boundaryNode, err := t.GetStateByRange(startKey, endKey, maxSize)
                if err != nil {
                        fmt.Printf("Error getting state by range: %v\n", err)
                }


                fmt.Printf("foundKeyVal: ")
                for i, kv := range foundKeyVal {
                        fmt.Printf("[%d] %x\n", i, kv)
                }
                fmt.Printf("\n")
                fmt.Printf("boundaryNode: ")
                for i, nodeHash := range boundaryNode {
                        fmt.Printf("[%d] %x\n", i, nodeHash)
                }
                fmt.Printf("\n")
        */
        <span class="cov0" title="0">return updated_root</span>
}

func (s *StateDB) GetAllKeyValues() []KeyVal <span class="cov0" title="0">{
        startKey := common.Hex2Bytes("0x0000000000000000000000000000000000000000000000000000000000000000")
        endKey := common.Hex2Bytes("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
        maxSize := uint32(math.MaxUint32)
        t := s.CopyTrieState(s.StateRoot)
        foundKeyVal, _, _ := t.GetStateByRange(startKey, endKey, maxSize)

        tmpKeyVals := make([]KeyVal, 0)
        for _, keyValue := range foundKeyVal </span><span class="cov0" title="0">{
                fetchRealKey := t.GetRealKey(keyValue.Key, keyValue.Value)
                realValue := make([]byte, len(keyValue.Value))
                realKey := make([]byte, 32)
                copy(realKey, fetchRealKey)
                copy(realValue, keyValue.Value)

                metaKey := fmt.Sprintf("meta_%x", realKey)
                metaKeyBytes, err := types.Encode(metaKey)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues Encode Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">metaValue := ""
                metaValues := make([]string, 2)
                switch </span>{
                case common.CompareBytes(realKey, common.Hex2Bytes("0x0100000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c1"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0200000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c2"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0300000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c3"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0400000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c4"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0500000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c5"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0600000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c6"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0700000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c7"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0800000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c8"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0900000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c9"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0A00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c10"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0B00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c11"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0C00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c12"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0D00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c13"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0E00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c14"
                        metaValues[1] = ""</span>

                case common.CompareBytes(realKey, common.Hex2Bytes("0x0F00000000000000000000000000000000000000000000000000000000000000")):<span class="cov0" title="0">
                        metaValues[0] = "c15"
                        metaValues[1] = ""</span>

                default:<span class="cov0" title="0">
                        metaValueBytes, ok, err := t.LevelDBGet(metaKeyBytes)
                        if err != nil || !ok </span><span class="cov0" title="0">{
                                fmt.Printf("PrintAllKeyValues levelDBGet Error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">if metaValueBytes != nil </span><span class="cov0" title="0">{
                                metaValueDecode, _, err := types.Decode(metaValueBytes, reflect.TypeOf(""))
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("PrintAllKeyValues Decode Error: %v\n", err)
                                }</span>
                                <span class="cov0" title="0">metaValue = metaValueDecode.(string)
                                metaValues = strings.SplitN(metaValue, "|", 2)</span>
                                //metaValues[1] = metaValue
                                //metaValues = strings.SplitN(metaValue, "|", 2)
                        } else<span class="cov0" title="0"> {
                                metaValues = append(metaValues, "")
                                metaValues = append(metaValues, "")
                        }</span>
                }

                <span class="cov0" title="0">keyVal := KeyVal{
                        Key:        realKey,
                        Value:      realValue,
                        StructType: metaValues[0],
                        Metadata:   metaValues[1],
                }
                tmpKeyVals = append(tmpKeyVals, keyVal)</span>
        }
        <span class="cov0" title="0">return tmpKeyVals</span>
}

func (s *StateDB) CompareStateRoot(genesis KeyVals, parentStateRoot common.Hash) (bool, error) <span class="cov0" title="0">{
        parent_root := s.StateRoot
        newTrie := trie.NewMerkleTree(nil, s.sdb)
        for _, kv := range genesis </span><span class="cov0" title="0">{
                newTrie.SetRawKeyVal(common.Hash(kv.Key), kv.Value)
        }</span>
        <span class="cov0" title="0">new_root := newTrie.GetRoot()
        //timeslot := s.GetSafrole().Timeslot
        if !common.CompareBytes(parent_root[:], new_root[:]) </span><span class="cov0" title="0">{
                return false, fmt.Errorf("Roots are not the same")
        }</span>

        //fmt.Printf("[%d] ", timeslot)
        //fmt.Printf("current_root, new_root %v %v parentStateRoot: %v\n", parent_root, new_root, parentStateRoot)

        <span class="cov0" title="0">return true, nil</span>
}

func (s *StateDB) UpdateAllTrieState(genesis string) common.Hash <span class="cov0" title="0">{
        //γ ≡⎩γk, γz, γs, γa⎭
        //γk :one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        //γz :epoch’s root, a Bandersnatch ring root composed with the one Bandersnatch key of each of the next epoch’s validators (epoch N+1)
        //γa :the ticket accumulator, a series of highest-scoring ticket identifiers to be used for the next epoch (epoch N+1)
        //γs :current epoch’s slot-sealer series, which is either a full complement of E tickets or, in the case of a fallback mode, a series of E Bandersnatch keys (epoch N)
        snapshotBytesRaw, err := os.ReadFile(genesis)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("[readSnapshot:ReadFile] %s ERR %v\n", genesis, err)
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">snapshotRaw := StateSnapshotRaw{}
        json.Unmarshal(snapshotBytesRaw, &amp;snapshotRaw)

        t := s.GetTrie()
        prev_root := t.GetRoot()
        debug := false
        verify := true

        for _, kv := range snapshotRaw.KeyVals </span><span class="cov0" title="0">{
                t.SetRawKeyVal(common.Hash(kv.Key), kv.Value)
                //fmt.Printf("SetRawKeyVal %v %x\n", common.Hash(kv[0]), kv[1])
        }</span>
        <span class="cov0" title="0">updated_root := t.GetRoot()

        sf := s.GetSafrole()
        if sf == nil </span><span class="cov0" title="0">{
                fmt.Printf("NO SAFROLE %v", s)
                panic(222)</span>
        }

        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%v] UpdateTrieState - before root:%v\n", s.Id, prev_root)
                fmt.Printf("[N%v] UpdateTrieState - after root:%v\n", s.Id, updated_root)
        }</span>

        <span class="cov0" title="0">if debug || verify </span><span class="cov0" title="0">{
                t2, _ := trie.InitMerkleTreeFromHash(updated_root.Bytes(), s.sdb)
                checkingResult, err := CheckingAllState(t, t2)
                if !checkingResult || err != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("CheckingAllState ERROR: %v\n", err))</span>
                }
        }
        <span class="cov0" title="0">return updated_root</span>
}

func (s *StateDB) UpdateAllTrieStateRaw(snapshotRaw StateSnapshotRaw) common.Hash <span class="cov0" title="0">{
        for _, kv := range snapshotRaw.KeyVals </span><span class="cov0" title="0">{
                s.trie.SetRawKeyVal(common.Hash(kv.Key), kv.Value)
                if kv.Metadata != "" </span><span class="cov0" title="0">{
                        metaKey := fmt.Sprintf("meta_%x", kv.Key)
                        metaKeyBytes, err := types.Encode(metaKey)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("UpdateAllTrieStateRaw Encode Error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">metaData := fmt.Sprintf("%s|%s", kv.StructType, kv.Metadata)
                        metaValueBytes, err := types.Encode(metaData)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("UpdateAllTrieStateRaw Encode Error: %v\n", err)
                        }</span>
                        <span class="cov0" title="0">s.sdb.WriteRawKV(metaKeyBytes, metaValueBytes)</span>
                }
        }
        // bootStrapCode := common.FromHex("0x000000000000001000000084000000000072051100000005100000000518000000055f04071300040a0400fffe040b24040713000211f8031004031504050000fffe01582004070000fffe04090020040a0010040b0030040c00404e090d0503570404090400fffe04070000fffe040804040a044e03011004011502110813000407130021842a4825050922222a4190945201")
        // bootStrapCodeHash := common.Blake2Hash(bootStrapCode)
        // fmt.Printf("**** Adding s=0, bootStrapCodeHash=%v, len(%v), | bootStrapCode=%x\n", bootStrapCodeHash, len(bootStrapCode), bootStrapCode)

        <span class="cov0" title="0">return s.trie.GetRoot()</span>
}

func (s *StateDB) GetSafroleState() *SafroleState <span class="cov0" title="0">{
        return s.JamState.SafroleState
}</span>

func CheckingAllState(t *trie.MerkleTree, t2 *trie.MerkleTree) (bool, error) <span class="cov0" title="0">{
        c1a, _ := t.GetState(C1)
        c1b, _ := t2.GetState(C1)
        if !common.CompareBytes(c1a, c1b) </span><span class="cov0" title="0">{
                fmt.Printf("C1 is not the same\n")
                return false, fmt.Errorf("C1 is not the same")
        }</span>
        <span class="cov0" title="0">c2a, _ := t.GetState(C2)
        c2b, _ := t2.GetState(C2)
        if !common.CompareBytes(c2a, c2b) </span><span class="cov0" title="0">{
                fmt.Printf("C2 is not the same\n")
                return false, fmt.Errorf("C2 is not the same")
        }</span>
        <span class="cov0" title="0">c3a, _ := t.GetState(C3)
        c3b, _ := t2.GetState(C3)
        if !common.CompareBytes(c3a, c3b) </span><span class="cov0" title="0">{
                fmt.Printf("C3 is not the same\n")
                return false, fmt.Errorf("C3 is not the same")
        }</span>
        <span class="cov0" title="0">c4a, _ := t.GetState(C4)
        c4b, _ := t2.GetState(C4)
        if !common.CompareBytes(c4a, c4b) </span><span class="cov0" title="0">{
                fmt.Printf("C4 is not the same\n")
                return false, fmt.Errorf("C4 is not the same")
        }</span>
        <span class="cov0" title="0">c5a, _ := t.GetState(C5)
        c5b, _ := t2.GetState(C5)
        if !common.CompareBytes(c5a, c5b) </span><span class="cov0" title="0">{
                fmt.Printf("C5 is not the same\n")
                return false, fmt.Errorf("C5 is not the same")
        }</span>
        <span class="cov0" title="0">c6a, _ := t.GetState(C6)
        c6b, _ := t2.GetState(C6)
        if !common.CompareBytes(c6a, c6b) </span><span class="cov0" title="0">{
                fmt.Printf("C6 is not the same\n")
                return false, fmt.Errorf("C6 is not the same")
        }</span>
        <span class="cov0" title="0">c7a, _ := t.GetState(C7)
        c7b, _ := t2.GetState(C7)
        if !common.CompareBytes(c7a, c7b) </span><span class="cov0" title="0">{
                fmt.Printf("C7 is not the same\n")
                return false, fmt.Errorf("C7 is not the same")
        }</span>
        <span class="cov0" title="0">c8a, _ := t.GetState(C8)
        c8b, _ := t2.GetState(C8)
        if !common.CompareBytes(c8a, c8b) </span><span class="cov0" title="0">{
                fmt.Printf("C8 is not the same\n")
                return false, fmt.Errorf("C8 is not the same")
        }</span>
        <span class="cov0" title="0">c9a, _ := t.GetState(C9)
        c9b, _ := t2.GetState(C9)
        if !common.CompareBytes(c9a, c9b) </span><span class="cov0" title="0">{
                fmt.Printf("C9 is not the same\n")
                return false, fmt.Errorf("C9 is not the same")
        }</span>
        <span class="cov0" title="0">c10a, _ := t.GetState(C10)
        c10b, _ := t2.GetState(C10)
        if !common.CompareBytes(c10a, c10b) </span><span class="cov0" title="0">{
                fmt.Printf("C10 is not the same\n")
                return false, fmt.Errorf("C10 is not the same")
        }</span>
        <span class="cov0" title="0">c11a, _ := t.GetState(C11)
        c11b, _ := t2.GetState(C11)
        if !common.CompareBytes(c11a, c11b) </span><span class="cov0" title="0">{
                fmt.Printf("C11 is not the same\n")
                return false, fmt.Errorf("C11 is not the same")
        }</span>
        <span class="cov0" title="0">c12a, _ := t.GetState(C12)
        c12b, _ := t2.GetState(C12)
        if !common.CompareBytes(c12a, c12b) </span><span class="cov0" title="0">{
                fmt.Printf("C12 is not the same\n")
                return false, fmt.Errorf("C12 is not the same")
        }</span>
        <span class="cov0" title="0">c13a, _ := t.GetState(C13)
        c13b, _ := t2.GetState(C13)
        if !common.CompareBytes(c13a, c13b) </span><span class="cov0" title="0">{
                fmt.Printf("C13 is not the same\n")
                return false, fmt.Errorf("C13 is not the same")
        }</span>
        <span class="cov0" title="0">c14a, _ := t.GetState(C14)
        c14b, _ := t2.GetState(C14)
        if !common.CompareBytes(c14a, c14b) </span><span class="cov0" title="0">{
                fmt.Printf("C14 is not the same\n")
                return false, fmt.Errorf("C14 is not the same")
        }</span>
        <span class="cov0" title="0">c15a, _ := t.GetState(C15)
        c15b, _ := t2.GetState(C15)
        if !common.CompareBytes(c15a, c15b) </span><span class="cov0" title="0">{
                fmt.Printf("C15 is not the same\n")
                return false, fmt.Errorf("C15 is not the same")
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}

// func (s *StateDB) writeLog(obj interface{}, timeslot uint32) {
//         WriteLog
//
//     msg := storage.LogMessage{
//         Payload:  obj,
//         Timeslot: timeslot,
//     }
//         fmt.Printf("sending logMsg: %v\n", msg)
//     s.logChan &lt;- msg
// }

func (s *StateDB) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(s, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}

func NewStateDB(sdb *storage.StateDBStorage, blockHash common.Hash) (statedb *StateDB, err error) <span class="cov0" title="0">{
        return newStateDB(sdb, blockHash)
}</span>

// newStateDB initiates the StateDB using the blockHash+bn; the bn input must refer to the epoch for which the blockHash belongs to
func newStateDB(sdb *storage.StateDBStorage, blockHash common.Hash) (statedb *StateDB, err error) <span class="cov0" title="0">{
        statedb = newEmptyStateDB(sdb)
        statedb.Finalized = false
        statedb.trie = trie.NewMerkleTree(nil, sdb)
        statedb.JamState = NewJamState()

        block := types.Block{}
        b := make([]byte, 32)
        zeroHash := common.BytesToHash(b)
        if bytes.Compare(blockHash.Bytes(), zeroHash.Bytes()) == 0 </span>{<span class="cov0" title="0">
                // genesis block situation

        }</span> else<span class="cov0" title="0"> {
                encodedBlock, err := sdb.ReadKV(blockHash)
                if err != nil </span><span class="cov0" title="0">{
                        return statedb, err
                }</span>

                <span class="cov0" title="0">h := common.Blake2Hash(encodedBlock)
                if bytes.Compare(h.Bytes(), blockHash.Bytes()) != 0 </span><span class="cov0" title="0">{
                        return statedb, fmt.Errorf("[statedb:newStateDB] hash of data incorrect [%d bytes]", len(encodedBlock))
                }</span>
                <span class="cov0" title="0">if err := json.Unmarshal(encodedBlock, &amp;block); err != nil </span><span class="cov0" title="0">{
                        return statedb, fmt.Errorf("[statedb:newStateDB] JSON decode error: %v", err)
                }</span>
                <span class="cov0" title="0">statedb.Block = &amp;block
                statedb.ParentHeaderHash = block.Header.ParentHeaderHash</span>
        }

        <span class="cov0" title="0">return statedb, nil</span>
}

func (s *StateDB) CopyTrieState(stateRoot common.Hash) *trie.MerkleTree <span class="cov0" title="0">{
        t, _ := trie.InitMerkleTreeFromHash(stateRoot.Bytes(), s.sdb)
        return t
}</span>

// Copy generates a copy of the StateDB
func (s *StateDB) Copy() (newStateDB *StateDB) <span class="cov0" title="0">{
        // Create a new instance of StateDB
        // T.P.G.A.
        tmpAvailableWorkReport := make([]types.WorkReport, len(s.AvailableWorkReport))
        copy(tmpAvailableWorkReport, s.AvailableWorkReport)
        newStateDB = &amp;StateDB{
                Id:                  s.Id,
                Block:               s.Block.Copy(), // You might need to deep copy the Block if it's mutable
                ParentHeaderHash:    s.ParentHeaderHash,
                HeaderHash:          s.HeaderHash,
                StateRoot:           s.StateRoot,
                JamState:            s.JamState.Copy(), // DisputesState has a Copy method
                sdb:                 s.sdb,
                trie:                s.CopyTrieState(s.StateRoot),
                logChan:             make(chan storage.LogMessage, 100),
                AccumulationRoot:    s.AccumulationRoot, // compressed C
                AvailableWorkReport: tmpAvailableWorkReport,
                AncestorSet:         s.AncestorSet,
                /*
                        Following flds are not copied over..?

                        VMs       map[uint32]*pvm.VM
                        vmMutex   sync.Mutex
                        X                   XContext
                        S                   uint32

                */
        }
        // copy instead of recalculate
        newStateDB.RotateGuarantors()
        return newStateDB
}</span>

func (s *StateDB) ProcessState(credential types.ValidatorSecret, ticketIDs []common.Hash, extrinsic_pool *types.ExtrinsicPool) (*types.Block, *StateDB, error) <span class="cov0" title="0">{
        genesisReady := s.JamState.SafroleState.CheckFirstPhaseReady()
        if !genesisReady </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>
        <span class="cov0" title="0">currJCE, timeSlotReady := s.JamState.SafroleState.CheckTimeSlotReady()
        if timeSlotReady </span><span class="cov0" title="0">{
                // Time to propose block if authorized
                isAuthorizedBlockBuilder := false
                sf := s.GetSafrole()
                isAuthorizedBlockBuilder = sf.IsAuthorizedBuilder(currJCE, common.Hash(credential.BandersnatchPub), ticketIDs)
                if isAuthorizedBlockBuilder </span><span class="cov0" title="0">{
                        // propose block without state transition
                        start := time.Now()
                        proposedBlk, err := s.MakeBlock(credential, currJCE, extrinsic_pool)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error making block: %v\n", err)
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">newStateDB, err := ApplyStateTransitionFromBlock(s, context.Background(), proposedBlk)
                        if err != nil </span><span class="cov0" title="0">{
                                // HOW could this happen, we made the block ourselves!
                                fmt.Printf("Error applying state transition: %v\n", err)
                                return nil, nil, err
                        }</span>
                        <span class="cov0" title="0">var validators []types.Validator
                        validators = newStateDB.GetSafrole().NextValidators
                        if len(validators) == 0 </span><span class="cov0" title="0">{
                                panic("No validators")</span>
                        }
                        <span class="cov0" title="0">currEpoch, currPhase := s.JamState.SafroleState.EpochAndPhase(currJCE)
                        // AddDrawBlock(common.Str(proposedBlk.Hash()), common.Str(proposedBlk.ParentHash()), int(proposedBlk.Header.AuthorIndex), fmt.Sprintf("%d", proposedBlk.Header.Slot))
                        fmt.Printf("[N%v] \033[33m Blk %s&lt;-%s \033[0m e'=%d,m'=%02d, len(γ_a')=%d   \t%s %s\n", s.Id, common.Str(proposedBlk.GetParentHeaderHash()), common.Str(proposedBlk.Header.Hash()),
                                currEpoch, currPhase, len(newStateDB.JamState.SafroleState.NextEpochTicketsAccumulator), proposedBlk.Str(), newStateDB.JamState.GetValidatorStats())
                        elapsed := time.Since(start)
                        if trace &amp;&amp; elapsed &gt; 2000000 </span><span class="cov0" title="0">{
                                fmt.Printf("\033[31m MakeBlock / ApplyStateTransitionFromBlock\033[0m %d ms\n", elapsed/1000)
                        }</span>
                        <span class="cov0" title="0">return proposedBlk, newStateDB, nil</span>
                } else <span class="cov0" title="0">{
                        //waiting for block ... potentially submit ticket here
                }</span>
        }
        <span class="cov0" title="0">return nil, nil, nil</span>
}

func (s *StateDB) SetID(id uint16) <span class="cov0" title="0">{
        s.Id = id
        s.JamState.SafroleState.Id = id
}</span>

// TODO: REMOVE THESE and use service account object methods INSTEAD!
func (s *StateDB) WriteServicePreimageBlob(service uint32, blob []byte) <span class="cov0" title="0">{
        tree := s.GetTrie()
        tree.SetPreImageBlob(service, blob)
}</span>
func (s *StateDB) WriteServicePreimageLookup(service uint32, blob_hash common.Hash, blob_length uint32, time_slots []uint32) <span class="cov0" title="0">{
        tree := s.GetTrie()
        tree.SetPreImageLookup(service, blob_hash, blob_length, time_slots)
}</span>
func (s *StateDB) DeleteServicePreimageKey(service uint32, blob_hash common.Hash) error <span class="cov0" title="0">{
        tree := s.GetTrie()
        err := tree.DeletePreImageBlob(service, blob_hash)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("DeleteServicePreimageKey: Failed to delete blob_hash: %x, error: %v\n", blob_hash.Bytes(), err)
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (s *StateDB) ApplyStateTransitionPreimages(preimages []types.Preimages, targetJCE uint32) (uint32, uint32, error) <span class="cov0" title="0">{
        num_preimages := uint32(0)
        num_octets := uint32(0)

        //TODO: (eq 156) need to make sure E_P is sorted. by what??
        //validate (eq 156)
        for i := 1; i &lt; len(preimages); i++ </span><span class="cov0" title="0">{
                if preimages[i].Requester &lt;= preimages[i-1].Requester </span><span class="cov0" title="0">{
                        return 0, 0, fmt.Errorf(errServiceIndices)
                }</span>
        }

        <span class="cov0" title="0">for _, l := range preimages </span><span class="cov0" title="0">{
                // validate eq 157
                _, err := s.ValidateLookup(&amp;l)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] ApplyStateTransitionPreimages ValidateLookup Error: %v\n", s.Id, err)
                        return 0, 0, err
                }</span>
        }

        // ready for state transisiton
        <span class="cov0" title="0">for _, l := range preimages </span><span class="cov0" title="0">{
                // (eq 158)
                // δ†[s]p[H(p)] = p
                // δ†[s]l[H(p),∣p∣] = [τ′]
                if debugP </span><span class="cov0" title="0">{
                        fmt.Printf(("WriteServicePreimageBlob, Service_Index: %d, Blob: %x\n"), l.Service_Index(), l.Blob)
                }</span>
                <span class="cov0" title="0">s.WriteServicePreimageBlob(l.Service_Index(), l.Blob)
                s.WriteServicePreimageLookup(l.Service_Index(), l.BlobHash(), l.BlobLength(), []uint32{targetJCE})
                num_preimages++
                num_octets += l.BlobLength()</span>
        }

        <span class="cov0" title="0">return num_preimages, num_octets, nil</span>
}

func (s *StateDB) getRhoWorkReportByWorkPackage(workPackageHash common.Hash) (types.WorkReport, uint32, bool) <span class="cov0" title="0">{
        // TODO
        return types.WorkReport{}, 0, false
}</span>

// for any hits in m, remove them from pool
func (s *StateDB) remove_guarantees_authhash(pool []common.Hash, m map[common.Hash]bool) []common.Hash <span class="cov0" title="0">{
        p := make([]common.Hash, 0)
        for _, h := range p </span><span class="cov0" title="0">{
                _, ok := m[h]
                if ok </span>{<span class="cov0" title="0">

                }</span> else<span class="cov0" title="0"> {
                        p = append(p, h)
                }</span>
        }
        <span class="cov0" title="0">return p</span>
}

func (s *StateDB) getServiceAccount(c uint32) (*types.ServiceAccount, bool, error) <span class="cov0" title="0">{
        t := s.GetTrie()
        v, ok, err := t.GetService(types.ServiceAccountPrefix, c)
        if err != nil || !ok </span><span class="cov0" title="0">{
                if !ok </span>{<span class="cov0" title="0">
                        // fmt.Printf("getServiceAccount: ServiceAccount not found for core %d\n", c)
                }</span>
                <span class="cov0" title="0">return &amp;types.ServiceAccount{}, false, nil</span>
        }
        // v looks like: ac ⌢ E8(ab,ag,am,al) ⌢ E4(ai)
        // TODO: William to figure out the transformation
        <span class="cov0" title="0">a, err := types.ServiceAccountFromBytes(c, v)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;types.ServiceAccount{}, false, nil
        }</span>
        //William check here!
        //fmt.Printf("getServiceAccount s=%v, v=%v\n", c, a.String())
        <span class="cov0" title="0">return a, false, nil</span>
}

func (s *StateDB) getPreimageBlob(c uint32, codeHash common.Hash) ([]byte, error) <span class="cov0" title="0">{
        t := s.GetTrie()
        preimage_blob, ok, err := t.GetPreImageBlob(c, codeHash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">return preimage_blob, nil</span>
}

func (s *StateDB) getServiceCoreCode(c uint32) (code []byte, err error) <span class="cov0" title="0">{
        serviceAccount, ok, err := s.getServiceAccount(c)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, err
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return []byte{}, errors.New("Service Account/Core not found")
        }</span>
        <span class="cov0" title="0">codeHash := serviceAccount.CodeHash
        code, err = s.getPreimageBlob(c, codeHash)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}, errors.New("Code not found")
        }</span>
        <span class="cov0" title="0">return code, nil</span>
}

func (s *StateDB) getWrangledWorkResultsBytes(results []types.WrangledWorkResult) []byte <span class="cov0" title="0">{
        output, err := types.Encode(results)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return output</span>
}

// Process Rho - Eq 25/26/27 using disputes, assurances, guarantees in that order
func (s *StateDB) ApplyStateTransitionRho(disputes types.Dispute, assurances []types.Assurance, guarantees []types.Guarantee, targetJCE uint32) (uint32, uint32, error) <span class="cov0" title="0">{

        // (25) / (111) We clear any work-reports which we judged as uncertain or invalid from their core
        d := s.GetJamState()
        //apply the dispute
        var err error
        result, err := d.IsValidateDispute(&amp;disputes)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        //state changing here
        //cores reading the old jam state
        //ρ†
        <span class="cov0" title="0">d.ProcessDispute(result, disputes.Culprit, disputes.Fault)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">err = s.ValidateAssurances(assurances)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        // Assurances: get the bitstring from the availability
        // core's data is now available
        //ρ††
        <span class="cov0" title="0">num_assurances, availableWorkReport := d.ProcessAssurances(assurances)
        _ = availableWorkReport                     // availableWorkReport is the work report that is available for the core, will be used in the audit section
        s.AvailableWorkReport = availableWorkReport // every block has new available work report

        if debugA </span><span class="cov0" title="0">{
                fmt.Printf("Rho State Update - Assurances\n")
                for i, rho := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                        if rho == nil </span><span class="cov0" title="0">{
                                fmt.Printf("Rho core[%d] WorkPackage Hash: nil\n", i)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Rho core[%d] WorkPackage Hash: %v\n", i, rho.WorkReport.GetWorkPackageHash())
                        }</span>
                }
        }

        // Guarantees
        <span class="cov0" title="0">err = s.Verify_Guarantees()
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov0" title="0">num_reports := uint32(len(guarantees))

        d.ProcessGuarantees(guarantees)
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("Rho State Update - Guarantees\n")
                for i, rho := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                        if rho == nil </span><span class="cov0" title="0">{
                                fmt.Printf("Rho core[%d] WorkPackage Hash: nil\n", i)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Rho core[%d] WorkPackage Hash: %v\n", i, rho.WorkReport.GetWorkPackageHash())
                        }</span>
                }
        }

        <span class="cov0" title="0">return num_reports, num_assurances, nil</span>
}

// given previous safrole, applt state transition using block
// σ'≡Υ(σ,B)
func ApplyStateTransitionFromBlock(oldState *StateDB, ctx context.Context, blk *types.Block) (s *StateDB, err error) <span class="cov0" title="0">{
        start := time.Now()
        s = oldState.Copy()
        old_timeslot := s.GetSafrole().Timeslot
        s.JamState = oldState.JamState.Copy()
        s.Block = blk
        s.ParentHeaderHash = blk.Header.ParentHeaderHash
        s.HeaderHash = blk.Header.Hash()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] ApplyStateTransitionFromBlock (%v &lt;== %v) s.StateRoot=%v\n", s.Id, s.ParentHeaderHash, s.HeaderHash, s.StateRoot)
        }</span>
        <span class="cov0" title="0">targetJCE := blk.TimeSlot()
        // 17+18 -- takes the PREVIOUS accumulationRoot which summarizes C a set of (service, result) pairs and
        // 19-22 - Safrole last
        ticketExts := blk.Tickets()
        sf_header := blk.GetHeader()
        epochMark := blk.EpochMark()

        if epochMark != nil </span><span class="cov0" title="0">{
                // s.queuedTickets = make(map[common.Hash]types.Ticket)
                s.GetJamState().ResetTallyStatistics()
        }</span>
        <span class="cov0" title="0">sf := s.GetSafrole()
        var vs []types.Validator
        vs = sf.PrevValidators
        if len(vs) == 0 </span><span class="cov0" title="0">{
                panic("No validators")</span>
        }
        <span class="cov0" title="0">s2, err := sf.ApplyStateTransitionTickets(ticketExts, targetJCE, sf_header) // Entropy computed!
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("sf.ApplyStateTransitionFromBlock %v\n", err)
                panic(1)</span>
        }
        <span class="cov0" title="0">vs = s2.PrevValidators
        if len(vs) == 0 </span><span class="cov0" title="0">{
                panic("No validators")</span>
        }
        <span class="cov0" title="0">s.JamState.SafroleState = &amp;s2
        s.RotateGuarantors()
        //fmt.Printf("ApplyStateTransitionFromBlock - SafroleState \n")
        s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "tickets", uint32(len(ticketExts)))
        elapsed := time.Since(start).Microseconds()
        if trace &amp;&amp; elapsed &gt; 1000000 </span><span class="cov0" title="0">{ // OPTIMIZED ApplyStateTransitionTickets/ValidateProposedTicket
                fmt.Printf("\033[31mApplyStateTransitionFromBlock:Tickets\033[0m %d ms\n", elapsed/1000)
        }</span>

        // 24 - Preimages
        <span class="cov0" title="0">preimages := blk.PreimageLookups()
        num_preimage, num_octets, err := s.ApplyStateTransitionPreimages(preimages, targetJCE)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        //fmt.Printf("ApplyStateTransitionFromBlock - Preimages\n")
        <span class="cov0" title="0">s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "preimages", num_preimage)
        s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "octets", num_octets)
        // 23,25-27 Disputes, Assurances. Guarantees
        disputes := blk.Disputes()
        assurances := blk.Assurances()
        guarantees := blk.Guarantees()

        if debug </span><span class="cov0" title="0">{
                for _, g := range guarantees </span><span class="cov0" title="0">{
                        fmt.Printf("[Core: %d]ApplyStateTransitionFromBlock Guarantee W_Hash%v\n", g.Report.CoreIndex, g.Report.GetWorkPackageHash())
                }</span>
        }
        <span class="cov0" title="0">num_reports, num_assurances, err := s.ApplyStateTransitionRho(disputes, assurances, guarantees, targetJCE)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("ApplyStateTransitionFromBlock - Disputes, Assurances, Guarantees\n")
                for _, rho := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                        if rho != nil </span><span class="cov0" title="0">{
                                fmt.Printf("ApplyStateTransitionFromBlock - Rho core[%d] WorkPackage Hash: %v\n", rho.WorkReport.CoreIndex, rho.WorkReport.GetWorkPackageHash())
                        }</span>
                }
        }
        // we get the service into JamState by AvailableWorkReport
        /*        rho_wr := s.AvailableWorkReport
                if err != nil {
                        fmt.Printf("Error getting work report from rho: %v\n", err)
                }
                for _, workreport := range rho_wr {
                        for _, result := range workreport.Results {
                                serviceID := result.ServiceID
                                v, ok, err := s.trie.GetService(255, serviceID)
                                if err != nil || !ok {
                                        fmt.Printf("Error getting service from rho: %v\n", err)
                                }
                        }
                }*/

        // appends "n" to MMR "Beta" s.JamState.RecentBlocks
        <span class="cov0" title="0">s.ApplyStateRecentHistory(blk, &amp;(s.AccumulationRoot))

        s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "assurances", num_assurances)
        s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "reports", num_reports)

        // 28 -- ACCUMULATE
        var g uint64 = 10000
        o := s.JamState.newPartialState()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] s.StateRoot=%v newPartialState len=%v\n", s.Id, s.StateRoot, len(o.D))
        }</span>
        <span class="cov0" title="0">var f map[uint32]uint32
        var b []BeefyCommitment
        accumulate_input_wr := s.AvailableWorkReport
        accumulate_input_wr = s.AccumulatableSequence(accumulate_input_wr)
        n, t, b := s.OuterAccumulate(g, accumulate_input_wr, o, f)
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("ApplyStateTransitionFromBlock - Accumulate\n")
        }</span>

        // Not sure whether transfer happens here
        <span class="cov0" title="0">tau := s.GetTimeslot() // Not sure whether τ ′ is set up like this
        if len(t) &gt; 0 </span><span class="cov0" title="0">{
                s.ProcessDeferredTransfers(o.D, tau, t)
        }</span>

        <span class="cov0" title="0">s.ApplyXContext(o)
        s.ApplyStateTransitionAccumulation(accumulate_input_wr, n, old_timeslot)
        s.ApplyStateTransitionAuthorizations()
        // n.r = M_B( [ s \ E_4(s) ++ E(h) | (s,h) in C] , H_K)
        var leaves [][]byte
        for _, sa := range b </span><span class="cov0" title="0">{
                // put (s,h) of C  into leaves
                leaf := append(common.Uint32ToBytes(sa.Service), sa.Commitment.Bytes()...)
                leaves = append(leaves, leaf)
        }</span>
        <span class="cov0" title="0">tree := trie.NewWellBalancedTree(leaves, types.Keccak)
        s.AccumulationRoot = common.Hash(tree.Root())

        // 29 -  Update Authorization Pool alpha'
        err = s.ApplyStateTransitionAuthorizations()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("ApplyStateTransitionFromBlock - Authorizations\n")
        }</span>
        // 30 - compute pi
        <span class="cov0" title="0">s.JamState.tallyStatistics(uint32(blk.Header.AuthorIndex), "blocks", 1)
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("ApplyStateTransitionFromBlock - Blocks\n")
        }</span>

        <span class="cov0" title="0">err = s.OnTransfer()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("ApplyStateTransitionFromBlock - OnTransfer\n")
        }</span>
        <span class="cov0" title="0">s.StateRoot = s.UpdateTrieState()
        return s, nil</span>
}

func (s *StateDB) GetBlock() *types.Block <span class="cov0" title="0">{
        return s.Block
}</span>

func (s *StateDB) isCorrectCodeHash(workReport types.WorkReport) bool <span class="cov0" title="0">{
        // TODO: logic to validate the code hash prediction.
        return true
}</span>

// make block generate block prior to state execution
func (s *StateDB) MakeBlock(credential types.ValidatorSecret, targetJCE uint32, extrinsic_pool *types.ExtrinsicPool) (bl *types.Block, err error) <span class="cov0" title="0">{

        sf := s.GetSafrole()
        isNewEpoch := sf.IsNewEpoch(targetJCE)
        needWinningMarker := sf.IseWinningMarkerNeeded(targetJCE)
        stateRoot := s.GetStateRoot()
        s.JamState.CheckInvalidCoreIndex()
        //fmt.Printf("\n\n----- MAKEBLOCK\n[N%v] MakeBlock using stateRoot %v JamState %s\n", s.Id, stateRoot, s.String())
        s.RecoverJamState(stateRoot)
        //fmt.Printf("[N%v] Recovered JamState %s\n", s.Id, s.String())
        s.JamState.CheckInvalidCoreIndex()
        //fmt.Printf("------ MAKEBLOCK\n\n")

        b := types.NewBlock()
        h := types.NewBlockHeader()
        extrinsicData := types.NewExtrinsic()
        h.ParentHeaderHash = s.HeaderHash
        h.ParentStateRoot = stateRoot
        h.Slot = targetJCE
        // Extrinsic Data has 5 different Extrinsics
        // E_P - Preimages:  aggregate queuedPreimageLookups into extrinsicData.Preimages
        extrinsicData.Preimages = make([]types.Preimages, 0)

        // Make sure this Preimages is ready to be included..
        for _, preimageLookup := range extrinsic_pool.GetPreimageFromPool() </span><span class="cov0" title="0">{
                _, err := s.ValidateLookup(preimageLookup)
                if err == nil </span><span class="cov0" title="0">{
                        pl, err := preimageLookup.DeepCopy()
                        if err != nil </span><span class="cov0" title="0">{
                                extrinsic_pool.RemoveOldPreimages([]types.Preimages{*preimageLookup}, targetJCE)
                                continue</span>
                        }
                        <span class="cov0" title="0">extrinsicData.Preimages = append(extrinsicData.Preimages, pl)</span>
                }
        }

        // 156: These pairs must be ordered and without duplicates
        <span class="cov0" title="0">for i := 0; i &lt; len(extrinsicData.Preimages); i++ </span><span class="cov0" title="0">{
                for j := 0; j &lt; len(extrinsicData.Preimages)-1; j++ </span><span class="cov0" title="0">{
                        if extrinsicData.Preimages[j].Requester &gt; extrinsicData.Preimages[j+1].Requester </span><span class="cov0" title="0">{
                                extrinsicData.Preimages[j], extrinsicData.Preimages[j+1] = extrinsicData.Preimages[j+1], extrinsicData.Preimages[j]
                        }</span>
                }
        }

        // E_A - Assurances
        // 126 - The assurances must ordered by validator index
        <span class="cov0" title="0">extrinsicData.Assurances = extrinsic_pool.GetAssurancesFromPool(h.ParentHeaderHash)
        SortAssurances(extrinsicData.Assurances)

        tmpState := s.JamState.Copy()
        _, _ = tmpState.ProcessAssurances(extrinsicData.Assurances)
        // E_G - Guarantees: aggregate queuedGuarantees into extrinsicData.Guarantees
        extrinsicData.Guarantees = make([]types.Guarantee, 0)
        queuedGuarantees := make([]types.Guarantee, 0)
        currRotationIdx := s.GetTimeslot() / types.ValidatorCoreRotationPeriod
        previousIdx := currRotationIdx - 1
        acceptedTimeslot := previousIdx * types.ValidatorCoreRotationPeriod
        queuedGuarantees = extrinsic_pool.GetGuaranteesFromPool(acceptedTimeslot)
        for _, guarantee := range queuedGuarantees </span><span class="cov0" title="0">{
                g, err := guarantee.DeepCopy()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">s.JamState.CheckInvalidCoreIndex()
                for _, rho := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("Rho %v\n", rho)
                        }</span>
                }
                <span class="cov0" title="0">err = s.Verify_Guarantee_MakeBlock(g)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Node %d \n", s.Id)
                        fmt.Println("Error verifying guarantee (in Make Block): ", err)
                        continue</span>
                }
                <span class="cov0" title="0">extrinsicData.Guarantees = append(extrinsicData.Guarantees, g)
                if debugG </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] Include Guarantee (Package Hash : %v)\n", s.Id, g.Report.GetWorkPackageHash())
                }</span>
                // check guarantee one per core
                // check guarantee is not a duplicate

        }
        <span class="cov0" title="0">SortByCoreIndex(extrinsicData.Guarantees)
        // return duplicate guarantee err
        extrinsicData.Guarantees, err, _ = s.Verify_Guarantees_MakeBlock(extrinsicData.Guarantees)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // E_D - Disputes: aggregate queuedDisputes into extrinsicData.Disputes
        // d := s.GetJamState()

        // extrinsicData.Disputes = make([]types.Dispute, 0)
        // dispute := FormDispute(s.queuedVotes)
        // if d.NeedsOffendersMarker(&amp;dispute) {
        //         // Handle the case where the dispute does not need an offenders marker.
        //         OffendMark, err := d.GetOffenderMark(dispute)
        //         if err != nil {
        //                 return nil, err
        //         }
        //         h.OffendersMark = OffendMark.OffenderKey
        // }

        // TODO: 103 Verdicts v must be ordered by report hash.
        // TODO: 104 Offender signatures c and f must each be ordered by the validator’s Ed25519 key.
        // TODO: 105 There may be no duplicate report hashes within the extrinsic, nor amongst any past reported hashes.
        // target_Epoch, target_Phase := sf.EpochAndPhase(targetJCE)
        <span class="cov0" title="0">needEpochMarker := isNewEpoch
        // eq 71
        if needEpochMarker </span><span class="cov0" title="0">{
                epochMarker := sf.GenerateEpochMarker()
                //a tuple of the epoch randomness and a sequence of Bandersnatch keys defining the Bandersnatch valida- tor keys (kb) beginning in the next epoch
                if debug </span><span class="cov0" title="0">{
                        fmt.Printf("[N%d] *** \033[32mEpochMarker\033[0m %v\n", s.Id, epochMarker)
                }</span>
                <span class="cov0" title="0">h.EpochMark = epochMarker</span>
        }
        // eq 72
        <span class="cov0" title="0">if needWinningMarker </span><span class="cov0" title="0">{
                winningMarker, err := sf.GenerateWinningMarker()
                //block is the first after the end of the submission period for tickets and if the ticket accumulator is saturated
                if err == nil </span><span class="cov0" title="0">{
                        if debug </span><span class="cov0" title="0">{
                                fmt.Printf("[N%d] *** \033[32mWinningTicketMarker\033[0m #Tickets=%d targetJCE=%v\n", s.Id, len(winningMarker), targetJCE)
                        }</span>
                        <span class="cov0" title="0">h.TicketsMark = winningMarker</span>
                }
        } else<span class="cov0" title="0"> {
                // If there's new ticketID, add them into extrinsic
                // Question: can we submit tickets at the exact tail end block?
                extrinsicData.Tickets = make([]types.Ticket, 0)
                // add the limitation for receiving tickets
                if s.JamState.SafroleState.IsTicketSubmissionClosed(targetJCE) &amp;&amp; !isNewEpoch </span>{<span class="cov0" title="0">
                        // s.queuedTickets = make(map[common.Hash]types.Ticket)

                }</span> else<span class="cov0" title="0"> {
                        next_n2 := s.JamState.SafroleState.GetNextN2()
                        for _, ticket := range extrinsic_pool.GetTicketsFromPool(next_n2) </span><span class="cov0" title="0">{
                                t, err := ticket.DeepCopy()
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">ticketID, _ := t.TicketID()
                                if s.JamState.SafroleState.InTicketAccumulator(ticketID) </span><span class="cov0" title="0">{
                                        continue</span>
                                } else<span class="cov0" title="0"> if len(extrinsicData.Tickets) &gt;= types.MaxTicketsPerExtrinsic </span><span class="cov0" title="0">{
                                        // we only allow a maxium number of tickets per block
                                        continue</span>
                                } else<span class="cov0" title="0"> {
                                        // fmt.Printf("[N%d] GetTicketQueue %v =&gt; %v\n", s.Id, ticketID, t)
                                        extrinsicData.Tickets = append(extrinsicData.Tickets, t)
                                }</span>
                        }

                        // s.queuedTickets = make(map[common.Hash]types.Ticket)
                }
                <span class="cov0" title="0">SortTicketsById(extrinsicData.Tickets)</span>
        }

        <span class="cov0" title="0">h.ExtrinsicHash = extrinsicData.Hash()
        author_index, err := sf.GetAuthorIndex(credential.BandersnatchPub.Hash(), "Curr")
        if err != nil </span><span class="cov0" title="0">{
                return bl, err
        }</span>
        <span class="cov0" title="0">h.AuthorIndex = author_index
        b.Extrinsic = extrinsicData

        unsignHeader := h.BytesWithoutSig() //signing

        auth_secret_key, err := sf.ConvertBanderSnatchSecret(credential.BandersnatchSecret)
        if err != nil </span><span class="cov0" title="0">{
                return bl, err
        }</span>

        <span class="cov0" title="0">epochType := sf.CheckEpochType()
        if epochType == "fallback" </span><span class="cov0" title="0">{
                blockseal, fresh_vrfSig, err := sf.SignFallBack(auth_secret_key, unsignHeader)
                if err != nil </span><span class="cov0" title="0">{
                        return bl, err
                }</span>
                <span class="cov0" title="0">copy(h.Seal[:], blockseal[:])
                copy(h.EntropySource[:], fresh_vrfSig[:])
                if debugSeal </span><span class="cov0" title="0">{
                        fmt.Printf("FALLBACK:\n")
                        fmt.Printf("  Seal: %x\n", h.Seal)
                        fmt.Printf("  EntropySource: %x\n", h.EntropySource)
                }</span>
        } else<span class="cov0" title="0"> {
                attempt, err := sf.GetBindedAttempt(targetJCE)
                blockseal, fresh_vrfSig, err := sf.SignPrimary(auth_secret_key, unsignHeader, attempt)
                if err != nil </span><span class="cov0" title="0">{
                        return bl, err
                }</span>
                <span class="cov0" title="0">copy(h.Seal[:], blockseal[:])
                copy(h.EntropySource[:], fresh_vrfSig[:])
                if debugSeal </span><span class="cov0" title="0">{
                        fmt.Printf("SAFROLE - Attempt %d\n", attempt)
                        fmt.Printf("  Seal: %x\n", h.Seal)
                        fmt.Printf("  EntropySource: %x\n", h.EntropySource)
                }</span>
        }
        <span class="cov0" title="0">if debugSeal </span><span class="cov0" title="0">{
                // Create an instance of the new struct without the signature fields.
                bwoSig := types.BlockHeaderWithoutSig{
                        ParentHeaderHash: h.ParentHeaderHash,
                        PriorStateRoot:   h.ParentStateRoot,
                        ExtrinsicHash:    h.ExtrinsicHash,
                        TimeSlot:         h.Slot,
                        EpochMark:        h.EpochMark,
                        // TicketsMark:    b.TicketsMark,
                        OffendersMark: h.OffendersMark,
                        AuthorIndex:   h.AuthorIndex,
                        EntropySource: h.EntropySource,
                }

                ticketMark, ok, _ := h.ConvertTicketsMark()
                if ok &amp;&amp; ticketMark != nil </span><span class="cov0" title="0">{
                        bwoSig.TicketsMark = ticketMark
                }</span>
                <span class="cov0" title="0">fmt.Printf("Node %d with secret key: %v\n", s.Id, auth_secret_key)
                fmt.Printf("  Unsigned Header: %s\n", bwoSig.String())
                fmt.Printf("  Unsigned Header Bytes: %x\n", h.BytesWithoutSig())</span>
        }
        <span class="cov0" title="0">b.Header = *h
        return b, nil</span>
}

func (s *StateDB) GetAncestorTimeSlot() []uint32 <span class="cov0" title="0">{
        timeslots := make([]uint32, 0)
        for _, h := range s.AncestorSet </span><span class="cov0" title="0">{
                timeslots = append(timeslots, h.Slot)
        }</span>
        <span class="cov0" title="0">return timeslots</span>
}

func (s *StateDB) SetAncestor(blockHeader types.BlockHeader, oldState *StateDB) <span class="cov0" title="0">{
        for _, h := range oldState.AncestorSet </span><span class="cov0" title="0">{
                if blockHeader.Slot-h.Slot &lt;= types.LookupAnchorMaxAge &amp;&amp; !HeaderContains(s.AncestorSet, h) </span><span class="cov0" title="0">{
                        s.AncestorSet = append(s.AncestorSet, h)
                }</span>
        }
        <span class="cov0" title="0">s.AncestorSet = append(s.AncestorSet, blockHeader)</span>
}

func HeaderContains(headers []types.BlockHeader, checkHeader types.BlockHeader) bool <span class="cov0" title="0">{
        for _, h := range headers </span><span class="cov0" title="0">{
                if h.Hash() == checkHeader.Hash() </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package statedb

import (
        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

const OK uint32 = 0

const (
        x_s = "S"
        x_c = "C"
        x_v = "V"
        x_i = "I"
        x_t = "T"
        x_n = "N"
        x_p = "P"
)

func (s *StateDB) writeAccount(sa *types.ServiceAccount) (err error) <span class="cov8" title="1">{
        if sa.Mutable == false </span><span class="cov0" title="0">{
                panic("WriteAccount")</span>
        }
        <span class="cov8" title="1">service_idx := sa.GetServiceIndex()
        tree := s.GetTrie()
        //fmt.Printf("[N%d] WriteAccount %v\n", s.Id, sa.String())
        for k, storage := range sa.Storage </span><span class="cov0" title="0">{
                if storage.Dirty </span><span class="cov0" title="0">{
                        if len(storage.Value) == 0 || storage.Deleted </span><span class="cov0" title="0">{
                                err = tree.DeleteServiceStorage(service_idx, storage.RawKey)
                                if err != nil </span><span class="cov0" title="0">{
                                        fmt.Printf("DeleteServiceStorageKey: Failed to delete k: %x, error: %v\n", k, err)
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tree.SetServiceStorage(service_idx, storage.RawKey, storage.Value)

                        }</span>
                }
        }
        <span class="cov8" title="1">for blob_hash, v := range sa.Lookup </span><span class="cov8" title="1">{
                if v.Dirty </span><span class="cov8" title="1">{
                        if v.Deleted </span><span class="cov0" title="0">{
                                panic("check this case as [] is natural -- does it exist")</span>
                        } else<span class="cov8" title="1"> {
                                tree.SetPreImageLookup(service_idx, blob_hash, v.Z, v.T)
                        }</span>
                }
        }
        <span class="cov8" title="1">for blobHash, v := range sa.Preimage </span><span class="cov0" title="0">{
                if v.Dirty </span><span class="cov0" title="0">{
                        if len(v.Preimage) == 0 || v.Deleted </span><span class="cov0" title="0">{
                                err = tree.DeletePreImageBlob(service_idx, blobHash)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> {
                                tree.SetPreImageBlob(service_idx, v.Preimage)
                        }</span>
                }
        }
        <span class="cov8" title="1">s.writeService(service_idx, sa)
        return nil</span>
}

func (s *StateDB) ApplyXContext(U *types.PartialState) <span class="cov0" title="0">{

        for _, sa := range U.D </span><span class="cov0" title="0">{
                // U.D should only have service accounts with Mutable = true
                if sa.Mutable == false </span><span class="cov0" title="0">{
                        fmt.Printf("ApplyXContext -- Immutable %d in U.X\n", sa.ServiceIndex)
                        panic("Immutable Service account in X.U.D")</span>
                } else<span class="cov0" title="0"> if sa.Dirty </span><span class="cov0" title="0">{
                        s.writeAccount(sa)
                }</span>
        }
        // p - Bless =&gt; Kai_state 12.4.1 (164)
        <span class="cov0" title="0">s.JamState.PrivilegedServiceIndices = U.PrivilegedState

        // c - Designate =&gt; AuthorizationQueue
        for i := 0; i &lt; types.TotalCores; i++ </span><span class="cov0" title="0">{
                copy(s.JamState.AuthorizationQueue[i][:], U.QueueWorkReport[i][:])
        }</span>
        // v - Assign =&gt; DesignatedValidators
        <span class="cov0" title="0">s.JamState.SafroleState.DesignedValidators = U.UpcomingValidators</span>
}

func (s *StateDB) GetTimeslot() uint32 <span class="cov8" title="1">{
        // Successfully casted to *statedb.StateDB
        sf := s.GetSafrole()
        return sf.GetTimeSlot()
}</span>

// GetService returns a **Immutable** service object.
func (s *StateDB) GetService(service uint32) (sa *types.ServiceAccount, ok bool, err error) <span class="cov8" title="1">{
        tree := s.GetTrie()
        var serviceBytes []byte
        serviceBytes, ok, err = tree.GetService(255, service)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">sa, err = types.ServiceAccountFromBytes(service, serviceBytes)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *StateDB) writeService(service uint32, sa *types.ServiceAccount) <span class="cov8" title="1">{
        v, _ := sa.Bytes()
        tree := s.GetTrie()
        tree.SetService(255, service, v)
}</span>

func (s *StateDB) ReadServiceStorage(service uint32, k []byte) (storage []byte, ok bool, err error) <span class="cov0" title="0">{
        // not init case
        tree := s.GetTrie()
        storage, ok, err = tree.GetServiceStorage(service, k)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                //fmt.Printf("ReadServiceStorage (S,K)=(%v,%x) RESULT: storage=%x, err=%v\n", service, k, storage, err)
                return
        }</span>
}

func (s *StateDB) ReadServicePreimageBlob(service uint32, blob_hash common.Hash) (blob []byte, ok bool, err error) <span class="cov0" title="0">{
        tree := s.GetTrie()
        blob, ok, err = tree.GetPreImageBlob(service, blob_hash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                if debug </span><span class="cov0" title="0">{
                        fmt.Printf("ReadServicePreimageBlob (s,l)=(%v, %v) RESULT: blob=%x (len=%v), err=%v\n", service, blob_hash, blob, len(blob), err)
                }</span>
                <span class="cov0" title="0">return</span>
        }
}

func (s *StateDB) ReadServicePreimageLookup(service uint32, blob_hash common.Hash, blob_length uint32) (time_slots []uint32, ok bool, err error) <span class="cov0" title="0">{
        tree := s.GetTrie()
        time_slots, ok, err = tree.GetPreImageLookup(service, blob_hash, blob_length)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("ReadServicePreimageLookup (s, (h,l))=(%v, (%v,%v))  RESULT: time_slots=%v, err=%v\n", service, blob_hash, blob_length, time_slots, err)
                return
        }</span>
}

// HistoricalLookup, GetImportItem, ExportSegment
func (s *StateDB) HistoricalLookup(service uint32, t uint32, blob_hash common.Hash) []byte <span class="cov0" title="0">{
        tree := s.GetTrie()
        rootHash := tree.GetRoot()
        fmt.Printf("Root Hash=%v\n", rootHash)
        blob, ok, err_v := tree.GetPreImageBlob(service, blob_hash)
        if err_v != nil || !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">blob_length := uint32(len(blob))

        timeslots, ok, err_t := tree.GetPreImageLookup(service, blob_hash, blob_length)
        if err_t != nil || !ok </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if timeslots[0] == 0 </span><span class="cov0" title="0">{
                return nil
        }</span> else<span class="cov0" title="0"> if len(timeslots) == (12 + 1) </span><span class="cov0" title="0">{
                x := timeslots[0]
                y := timeslots[1]
                z := timeslots[2]
                if (x &lt;= t &amp;&amp; t &lt; y) || (z &lt;= t) </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> if len(timeslots) == (8 + 1) </span><span class="cov0" title="0">{
                x := timeslots[0]
                y := timeslots[1]
                if x &lt;= t &amp;&amp; t &lt; y </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        } else<span class="cov0" title="0"> {
                x := timeslots[0]
                if x &lt;= t </span><span class="cov0" title="0">{
                        return blob
                }</span> else<span class="cov0" title="0"> {
                        return nil
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package statedb

import (
        "context"
        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/types"
)

type StateTransition struct {
        PreState  StateSnapshotRaw `json:"pre_state"`
        Block     types.Block      `json:"block"`
        PostState StateSnapshotRaw `json:"post_state"`
}

type StateTransitionCheck struct {
        ValidMatch         bool          `json:"valid_match"`
        PostStateRootMatch bool          `json:"post_state_root_match"`
        PostStateMismatch  []common.Hash `json:"post_state_mismatch"`
}

func compareKeyVals(p0 []KeyVal, p1 []KeyVal) <span class="cov0" title="0">{
        if len(p0) != len(p1) </span><span class="cov0" title="0">{
                fmt.Printf("len pre %d != len post %d\n", len(p0), len(p1))
        }</span>
        <span class="cov0" title="0">kv0, m0 := makemap(p0)
        kv1, m1 := makemap(p1)
        for k0, v0 := range kv0 </span><span class="cov0" title="0">{
                v1 := kv1[k0]
                if !common.CompareBytes(v0, v1) </span><span class="cov0" title="0">{
                        metaKey := fmt.Sprintf("meta_%v", k0)
                        metaData0 := m0[metaKey]
                        metaData1 := m1[metaKey]
                        fmt.Printf("K %v\ns1(Current) Meta Data: %s\nPostState Meta Data:   %s\n", k0, metaData0, metaData1)
                        fmt.Printf("s1(Current) Value: %x\nPostState   Value: %x\n", v0, v1)
                }</span>
        }
}

func makemap(p []KeyVal) (map[common.Hash][]byte, map[string]string) <span class="cov0" title="0">{
        kvMap := make(map[common.Hash][]byte)
        metaMap := make(map[string]string)
        for _, kvs := range p </span><span class="cov0" title="0">{
                k := common.BytesToHash(kvs.Key)
                v := kvs.Value
                kvMap[k] = v
                metaKey := fmt.Sprintf("meta_%v", k)
                metaMap[metaKey] = fmt.Sprintf("%s|%s", kvs.StructType, kvs.Metadata)
        }</span>
        <span class="cov0" title="0">return kvMap, metaMap</span>
}

func CheckStateTransition(storage *storage.StateDBStorage, st *StateTransition, ancestorSet []types.BlockHeader, accumulationRoot common.Hash) error <span class="cov0" title="0">{
        // Apply the state transition
        s0, err := NewStateDBFromSnapshotRaw(storage, &amp;(st.PreState))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">s0.AncestorSet = ancestorSet
        s0.AccumulationRoot = accumulationRoot
        s1, err := ApplyStateTransitionFromBlock(s0, context.Background(), &amp;(st.Block))
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">if st.PostState.StateRoot == s1.StateRoot </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("STATEROOT does not match: s1: %v st.PostState: %v FAIL\n", s1.StateRoot, st.PostState.StateRoot)
        compareKeyVals(s1.GetAllKeyValues(), st.PostState.KeyVals)
        return fmt.Errorf("mismatch")</span>

}
</pre>
		
		<pre class="file" id="file31" style="display: none">package statedb

import (
        "fmt"

        "github.com/colorfulnotion/jam/types"

        "github.com/colorfulnotion/jam/pvm"
)

func (s *StateDB) OnTransfer() error <span class="cov0" title="0">{
        for _, core := range s.JamState.AvailabilityAssignments </span><span class="cov0" title="0">{
                if core == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">code, err := s.getServiceCoreCode(uint32(core.WorkReport.CoreIndex))
                if err == nil </span><span class="cov0" title="0">{
                        fmt.Printf("OnTransfers %d\n", core.WorkReport.CoreIndex)
                        vm := pvm.NewVMFromCode(uint32(core.WorkReport.CoreIndex), code, 0, s)
                        argument_input, _ := types.Encode(s.X.T)
                        vm.ExecuteTransfer(argument_input, s.X.D[s.X.S])
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package trie

import (
        "encoding/binary"
        "errors"
        "fmt"
        "math"
        "os"
        "reflect"
        "strings"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/storage"
        "github.com/colorfulnotion/jam/types"
)

type KeyVal struct {
        Key        []byte `json:"k"`
        Value      []byte `json:"v"`
        StructType string `json:"struct_type,omitempty"`
        Metadata   string `json:"meta,omitempty"`
}

type KeyVals struct {
        KeyVals []KeyVal
}

// TODO: stanley to figure what this is
type BMTProof []common.Hash

// Node represents a node in the Merkle Tree
type Node struct {
        Hash  []byte
        Key   []byte
        Left  *Node
        Right *Node
}

// state-key constructor functions C(X)
const (
        C1  = "CoreAuthPool"
        C2  = "AuthQueue"
        C3  = "RecentBlocks"
        C4  = "safroleState"
        C5  = "PastJudgements"
        C6  = "Entropy"
        C7  = "NextEpochValidatorKeys"
        C8  = "CurrentValidatorKeys"
        C9  = "PriorEpochValidatorKeys"
        C10 = "PendingReports"
        C11 = "MostRecentBlockTimeslot"
        C12 = "PrivilegedServiceIndices"
        C13 = "ActiveValidator"
        C14 = "AccumulationQueue"
        C15 = "AccumulationHistory"
)

const (
        LevelDBNull  = "null"
        LevelDBEmpty = ""

        debug    = false
        debugCDT = false
)

/*
Branch Node (64 bytes)
+-------------------------------------------------+
|    First 255 bits of left child node hash       |
+-------------------------------------------------+
|    Full 256 bits of right child node hash       |
+-------------------------------------------------+

Embedded-Value Leaf Node (64 bytes) &lt;= data is small enough, let's store the value in left &lt;0x1234 .... 0000&gt;
+--------+------------------------------------------+
|  2 bits | 6 bits (value size) | 31 bytes (key)    |
+--------+------------------------------------------+
|              32 bytes (embedded value)            |
+---------------------------------------------------+

Regular Leaf Node (64 bytes) [K,V] -&gt; V &gt;= 32bytes. too long, only store Hash
+--------+------------------------------------------+
|  2 bits | 6 bits (0s) | 31 bytes (key)            |
+--------+------------------------------------------+
|               32 bytes (hash of value)            |
+---------------------------------------------------+
*/

/*
TODO: eleminate the "Value" from Node. we need to store this map saperately
levelDB =&gt; Hash(apple) =&gt; apple
Hash(hash of value that's &gt;= 32bytes) =&gt; value
*/

// MerkleTree represents the entire Merkle Tree
type MerkleTree struct {
        Root *Node
        // levelDBMap map[string][]byte // &lt;&gt;
        db *storage.StateDBStorage
}

// NewMerkleTree creates a new Merkle Tree from the provided data
func initLevelDB(optionalPath ...string) (*storage.StateDBStorage, error) <span class="cov8" title="1">{
        path := "/tmp/log/leveldb/bpt"
        if len(optionalPath) &gt; 0 </span><span class="cov0" title="0">{
                path = optionalPath[0]
        }</span>
        <span class="cov8" title="1">stateDBStorage, err := storage.NewStateDBStorage(path)
        //db, err := leveldb.OpenFile(path, nil)
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("Initialized levelDB at: %s\n", path)
        }</span>
        <span class="cov8" title="1">return stateDBStorage, err</span>
}

func InitLevelDB(optionalPath ...string) (*storage.StateDBStorage, error) <span class="cov0" title="0">{
        return initLevelDB(optionalPath...)
}</span>

func DeleteLevelDB(optionalPath ...string) error <span class="cov8" title="1">{
        path := "/tmp/log/leveldb/bpt"
        if len(optionalPath) &gt; 0 </span><span class="cov0" title="0">{
                path = optionalPath[0]
        }</span>

        //fmt.Printf("Deleting LevelDB at: %s\n", path)
        <span class="cov8" title="1">err := os.RemoveAll(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete LevelDB at %s: %v", path, err)
        }</span>
        //fmt.Println("LevelDB deleted successfully")
        <span class="cov8" title="1">return nil</span>
}

// NewMerkleTree creates a new Merkle Tree from the provided data
func NewMerkleTreeWithPath(data [][2][]byte, optionalPath ...string) *MerkleTree <span class="cov0" title="0">{
        path := "/tmp/log/leveldb/bpt"
        if len(optionalPath) &gt; 0 </span><span class="cov0" title="0">{
                path = optionalPath[0]
        }</span>
        <span class="cov0" title="0">db, err := initLevelDB(path)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("levelDB ERR: %v", err)
        }</span>
        <span class="cov0" title="0">if data == nil || len(data) == 0 </span><span class="cov0" title="0">{
                return &amp;MerkleTree{Root: nil, db: db}
        }</span>
        <span class="cov0" title="0">root := buildMerkleTree(data, 0)
        return &amp;MerkleTree{Root: root, db: db}</span>
}

func NewMerkleTree(data [][2][]byte, db *storage.StateDBStorage) *MerkleTree <span class="cov8" title="1">{
        if data == nil || len(data) == 0 </span><span class="cov8" title="1">{
                return &amp;MerkleTree{Root: nil, db: db}
        }</span>
        <span class="cov0" title="0">root := buildMerkleTree(data, 0)
        return &amp;MerkleTree{Root: root, db: db}</span>
}

// buildMerkleTree constructs the Merkle tree from key-value pairs
func buildMerkleTree(kvs [][2][]byte, i int) *Node <span class="cov0" title="0">{
        // Base Case - Empty Data |d| = 0
        if len(kvs) == 0 </span><span class="cov0" title="0">{
                return &amp;Node{Hash: make([]byte, 32)}
        }</span>
        // V(d) = {(K,v)}
        <span class="cov0" title="0">if len(kvs) == 1 </span><span class="cov0" title="0">{
                encoded := leaf(kvs[0][0], kvs[0][1])
                //TODO: we should store (Hash, Value) in levelDB for future lookup
                //computeHash(encoded) -&gt; kvs[0][1]
                //kvs[0][1] -&gt; computeHash(encoded) X NOT like this
                //will only store the value if less than 32 bytes
                return &amp;Node{Hash: computeHash(encoded), Key: kvs[0][0]}
        }</span>
        // Recursive Case: B(M(l),M(r))
        <span class="cov0" title="0">var l, r [][2][]byte
        for _, kv := range kvs </span><span class="cov0" title="0">{
                if bit(kv[0], i) </span><span class="cov0" title="0">{
                        r = append(r, kv)
                }</span> else<span class="cov0" title="0"> {
                        l = append(l, kv)
                }</span>
        }

        <span class="cov0" title="0">left := buildMerkleTree(l, i+1)
        right := buildMerkleTree(r, i+1)
        encoded := branch(left.Hash, right.Hash)
        return &amp;Node{Hash: computeHash(encoded), Left: left, Right: right}</span>
}

//        func branch(left, right []byte) []byte {
//                if len(left) != 32 || len(right) != 32 {
//                        panic("branch: input hashes must be 32 bytes")
//                }
//                head := left[0] &amp; 0x7f                           // Set the LSB of the first byte of the left hash to 0
//                left255bits := append([]byte{head}, left[1:]...) // Left: last 255 bits of
//                concatenated := append(left255bits, right...)    // (l,r): 512 bits
//                return concatenated
//        }

// branch concatenates the left and right node hashes with a modified head
func branch(left, right []byte) []byte <span class="cov8" title="1">{
        if len(left) != 32 || len(right) != 32 </span><span class="cov0" title="0">{
                panic("branch: input hashes must be 32 bytes")</span>
        }
        <span class="cov8" title="1">head := left[0] &amp; 0xfe                           // Set the LSB of the first byte of the left hash to 0
        left255bits := append([]byte{head}, left[1:]...) // Left: last 255 bits of
        concatenated := append(left255bits, right...)    // (l,r): 512 bits
        return concatenated</span>
}

// leaf encodes a key-value pair into a leaf node
func leaf(k, v []byte) []byte <span class="cov8" title="1">{
        // Embedded-value leaf node
        if len(v) &lt;= 32 </span><span class="cov8" title="1">{
                // head := byte(0b10000000 | len(v))
                head := byte(0b01 | (len(v) &lt;&lt; 2))
                tmpk := make([]byte, len(k))
                copy(tmpk, k)
                if len(tmpk) &gt; 31 </span><span class="cov8" title="1">{
                        tmpk = tmpk[:31]
                }</span> else<span class="cov0" title="0"> {
                        tmpk = append(tmpk, make([]byte, 31-len(tmpk))...)
                }</span>
                <span class="cov8" title="1">value := append(v, make([]byte, 32-len(v))...)
                return append([]byte{head}, append(tmpk, value...)...)</span>
        } else<span class="cov8" title="1"> {
                // Regular leaf node
                // head := byte(0b11000000)
                head := byte(0b11)
                tmpk := make([]byte, len(k))
                copy(tmpk, k)
                if len(tmpk) &gt; 31 </span><span class="cov8" title="1">{
                        tmpk = tmpk[:31]
                }</span> else<span class="cov0" title="0"> {
                        tmpk = append(tmpk, make([]byte, 31-len(tmpk))...)
                }</span>
                <span class="cov8" title="1">hash := computeHash(v)
                return append([]byte{head}, append(tmpk, hash...)...)</span>
        }
}

// decodeLeaf decodes a leaf node into its key and value/hash
// func decodeLeaf(leaf []byte) (k []byte, v []byte, isEmbedded bool, err error) {
//         if len(leaf) != 64 {
//                 return nil, nil, false, fmt.Errorf("invalid leaf length %v", len(leaf))
//         }

//         head := leaf[0]
//         key := leaf[1:32]

//         if head&amp;0b11000000 == 0b10000000 {
//                 // Embedded-value leaf node
//                 valueSize := int(head &amp; 0b00111111) // Extract the value size from the lower 6 bits
//                 value := leaf[32 : 32+valueSize]
//                 return key, value, true, nil
//         } else if head&amp;0b11000000 == 0b11000000 {
//                 // Regular leaf node
//                 hash := leaf[32:64]
//                 return key, hash, false, nil
//         } else {
//                 return nil, nil, false, fmt.Errorf("invalid leaf node header")
//         }
// }

// decodeLeaf decodes a leaf node into its key and value/hash
func decodeLeaf(leaf []byte) (k []byte, v []byte, isEmbedded bool, err error) <span class="cov8" title="1">{
        if len(leaf) != 64 </span><span class="cov8" title="1">{
                return nil, nil, false, fmt.Errorf("invalid leaf length %v", len(leaf))
        }</span>

        <span class="cov8" title="1">head := leaf[0]
        key := leaf[1:32]

        if head&amp;0b11 == 0b01 </span><span class="cov8" title="1">{
                // Embedded-value leaf node
                valueSize := int(head &gt;&gt; 2)
                value := leaf[32 : 32+valueSize]
                return key, value, true, nil
        }</span> else<span class="cov8" title="1"> if head&amp;0b11 == 0b11 </span><span class="cov8" title="1">{
                // Regular leaf node
                hash := leaf[32:64]
                return key, hash, false, nil
        }</span> else<span class="cov0" title="0"> {
                return nil, nil, false, fmt.Errorf("invalid leaf node header")
        }</span>
}

//        func bit(k []byte, i int) bool {
//                byteIndex := i / 8 // the byte index in the array where the bit is located
//                if byteIndex &gt;= len(k) {
//                        return false // return false if index is out of range
//                }
//                bitIndex := 7 - (i % 8)       // the bit position within the byte
//                b := k[byteIndex]             // target byte
//                mask := byte(1 &lt;&lt; (bitIndex)) // least significant bit first
//                return (b &amp; mask) != 0        // return set (1) or not (0)
//        }

func bit(k []byte, i int) bool <span class="cov8" title="1">{
        byteIndex := i / 8 // the byte index in the array where the bit is located
        if byteIndex &gt;= len(k) </span><span class="cov0" title="0">{
                return false // return false if index is out of range
        }</span>
        <span class="cov8" title="1">bitIndex := i % 8             // the bit position within the byte
        b := k[byteIndex]             // target byte
        mask := byte(1 &lt;&lt; (bitIndex)) // least significant bit first
        return (b &amp; mask) != 0</span>        // return set (1) or not (0)
}

func (t *MerkleTree) GetRoot() common.Hash <span class="cov0" title="0">{
        if t.Root == nil </span><span class="cov0" title="0">{
                return common.BytesToHash(make([]byte, 32))
        }</span>
        <span class="cov0" title="0">return common.BytesToHash(t.Root.Hash)</span>
}

// GetRootHash returns the root hash of the Merkle Tree
func (t *MerkleTree) GetRootHash() []byte <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov8" title="1">{
                return make([]byte, 32)
        }</span>
        <span class="cov8" title="1">return t.Root.Hash</span>
}

func InitMerkleTreeFromHash(root []byte, db *storage.StateDBStorage) (*MerkleTree, error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("database is not initialized")
        }</span>
        <span class="cov8" title="1">tree := &amp;MerkleTree{Root: nil, db: db}
        if compareBytes(root, common.Hex2Bytes("0000000000000000000000000000000000000000000000000000000000000000")) </span><span class="cov0" title="0">{
                return &amp;MerkleTree{Root: nil, db: db}, nil
        }</span>
        <span class="cov8" title="1">rootNode, err := tree.levelDBGetNode(root)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tree.Root = rootNode
        return tree, nil</span>
}

func (t *MerkleTree) levelDBSetBranch(branchHash, value []byte) <span class="cov8" title="1">{
        /*
                Branch Node (64 bytes)
                +-------------------------------------------------+
                |    First 255 bits of left child node hash       |
                +-------------------------------------------------+
                |    Full 256 bits of right child node hash       |
                +-------------------------------------------------+
        */
        // store Left hash and Right hash separately
        t.levelDBSet(branchHash, append([]byte("branch"), value...))
}</span>

func (t *MerkleTree) levelDBGetBranch(branchHash []byte) (*Node, error) <span class="cov8" title="1">{
        value, ok, err := t.levelDBGet(branchHash)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("value is nil for key: %s", branchHash)
        }</span>
        <span class="cov8" title="1">if len(value) &lt; 38 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("value is too short, expected at least 38 bytes but got %d bytes", len(value))
        }</span>
        <span class="cov8" title="1">leftHash := make([]byte, 32)
        copy(leftHash, value[6:38])
        rightHash := value[38:]
        copy(rightHash, value[38:])

        leftNode, err := t.levelDBGetNode(leftHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rightNode, err := t.levelDBGetNode(rightHash)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">n := Node{
                Hash:  branchHash,
                Left:  leftNode,
                Right: rightNode,
        }
        return &amp;n, nil</span>
}

func (t *MerkleTree) levelDBSetLeaf(encodedLeaf, value []byte, key []byte) <span class="cov8" title="1">{
        _k, _v, isEmbedded, _ := decodeLeaf(encodedLeaf)
        encodedLeafHash := computeHash(encodedLeaf)
        encodedLeafHashVal := computeHash(append(encodedLeafHash, value...))
        //t.levelDBSet(key, encodedLeafHashVal)
        t.levelDBSet(encodedLeafHashVal, key)
        if isEmbedded </span><span class="cov8" title="1">{
                // value-embedded leaf node: 2 bits | 6 bits (value size) | 31 bytes (key)
                // value is less or equal to 32 bytes
                // value can be recovered from encodedLeaf.
                t.levelDBSet(encodedLeafHash, encodedLeaf)
        }</span> else<span class="cov8" title="1"> {
                // regular leaf node: 2 bits | 2 bits | 6 bits (0s) | 31 bytes (key)
                // value is greater than 32 bytes
                // store additional hash(value) -&gt; value
                if len(_k) &gt; 0 </span>{<span class="cov8" title="1">

                }</span>
                <span class="cov8" title="1">t.levelDBSet(encodedLeafHash, encodedLeaf)
                t.levelDBSet(_v, value)</span>
        }
}

func (t *MerkleTree) levelDBGetLeaf(nodeHash []byte) ([]byte, bool, error) <span class="cov8" title="1">{
        encodedLeaf, ok, err := t.levelDBGet(nodeHash)
        //TODO:
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                return nil, false, nil
        }</span>
        //recover encodedLeaf from nodeHash
        <span class="cov8" title="1">_, _v, isEmbedded, err := decodeLeaf(encodedLeaf)
        // fmt.Printf("levelDBGetLeaf nodeHash=%x k=%x, v=%x, isEmbedded=%v\n", nodeHash, _K, _v, isEmbedded)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("decodeLeaf leaf Err: %s", err)
        }</span>
        <span class="cov8" title="1">if isEmbedded </span><span class="cov8" title="1">{
                // value-embedded leaf node: 2 bits | 6 bits (value size) | 31 bytes (key)
                // value is less or equal to 32 bytes, return exact value
                return _v, true, nil
        }</span> else<span class="cov8" title="1"> {
                // regular leaf node: 2 bits | 2 bits | 6 bits (0s) | 31 bytes (key)
                // value is greater than 32 bytes. lookup _v -&gt; value
                return t.levelDBGet(_v)
        }</span>
}

// levelDBSet sets the value for the given key in the levelDBMap
func (t *MerkleTree) levelDBSet(k, v []byte) error <span class="cov8" title="1">{
        if t.db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("database is not initialized")
        }</span>
        //fmt.Printf("Len(k)=%d, k=%x\n", len(k), k)
        <span class="cov8" title="1">err := t.db.WriteRawKV(k, v)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to set key %s: %v", k, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *MerkleTree) LevelDBGet(k []byte) ([]byte, bool, error) <span class="cov0" title="0">{
        return t.levelDBGet(k)
}</span>

// levelDBGet gets the value for the given key from the levelDBMap
func (t *MerkleTree) levelDBGet(k []byte) ([]byte, bool, error) <span class="cov8" title="1">{
        if t.db == nil </span><span class="cov8" title="1">{
                return nil, false, fmt.Errorf("database is not initialized")
        }</span>
        //value, err := t.db.Get(k, nil)
        <span class="cov8" title="1">value, ok, err := t.db.ReadRawKV(k)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("failed to get key [%s]: %v", k, err)
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                return nil, false, nil
        }</span>
        <span class="cov8" title="1">return value, true, nil</span>
}

func (t *MerkleTree) levelDBGetNode(nodeHash []byte) (*Node, error) <span class="cov8" title="1">{
        //value, _ := t.db.Get([]byte(nodeHash), nil)
        value, _, _ := t.db.ReadRawKV(nodeHash)
        zeroHash := make([]byte, 32)
        if compareBytes(nodeHash, zeroHash) || value == nil </span><span class="cov8" title="1">{
                return &amp;Node{
                        Hash: zeroHash,
                }, nil
        }</span>
        <span class="cov8" title="1">leafKey, _, _ := t.levelDBGetLeaf(nodeHash)
        // fmt.Printf("levelDBGetNode: nodeHash=%x, leafKey=%x\n", nodeHash, leafKey)
        if leafKey != nil </span><span class="cov8" title="1">{
                leafValue, _, _ := t.db.ReadRawKV(computeHash([]byte(append(nodeHash, leafKey...))))
                //leafValue, _ := t.db.Get([]byte(append(nodeHash, leafKey...)), nil)
                return &amp;Node{
                        Hash: nodeHash,
                        Key:  leafValue,
                }, nil
        }</span>

        <span class="cov8" title="1">if value != nil || !compareBytes(value, zeroHash) </span><span class="cov8" title="1">{
                return t.levelDBGetBranch(nodeHash)
        }</span> else<span class="cov0" title="0"> {
                return &amp;Node{
                        Hash: zeroHash,
                }, nil
        }</span>
}

// Close closes the levelDB connection
func (t *MerkleTree) Close() error <span class="cov8" title="1">{
        if t.db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("database is not initialized")
        }</span>
        <span class="cov8" title="1">return t.db.Close()</span>
}

func (n *Node) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf("Node Hash=%x, Key=%x\n", n.Hash, n.Key)
        return s
}</span>

func (t *MerkleTree) PrintAllKeyValues() <span class="cov0" title="0">{
        startKey := common.Hex2Bytes("0x0000000000000000000000000000000000000000000000000000000000000000")
        endKey := common.Hex2Bytes("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")
        maxSize := uint32(math.MaxUint32)
        foundKeyVal, _, _ := t.GetStateByRange(startKey, endKey, maxSize)

        keyVals := make([]KeyVal, 0)
        for _, keyValue := range foundKeyVal </span><span class="cov0" title="0">{
                fetchRealKey := t.GetRealKey(keyValue.Key, keyValue.Value)
                realValue := make([]byte, len(keyValue.Value))
                realKey := make([]byte, 32)
                copy(realKey, fetchRealKey)
                copy(realValue, keyValue.Value)
                metaKey := fmt.Sprintf("meta_%x", realKey)
                metaKeyBytes, err := types.Encode(metaKey)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues Encode Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues Encode Error: %v\n", err)
                }</span>
                <span class="cov0" title="0">metaValueBytes, ok, err := t.levelDBGet(metaKeyBytes)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues levelDBGet Error: %v\n", err)
                        return
                }</span> else<span class="cov0" title="0"> if !ok </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues Key not found: %v\n", metaKey)
                        return
                }</span>
                <span class="cov0" title="0">metaValueDecode, _, err := types.Decode(metaValueBytes, reflect.TypeOf(""))
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("PrintAllKeyValues Decode Error: %v\n", err)
                        return
                }</span>
                <span class="cov0" title="0">metaValue := metaValueDecode.(string)
                metaValues := strings.SplitN(metaValue, "|", 2)

                keyVal := KeyVal{
                        Key:        realKey,
                        Value:      realValue,
                        StructType: metaValues[0],
                        Metadata:   metaValues[1],
                }
                keyVals = append(keyVals, keyVal)</span>
        }
        <span class="cov0" title="0">fmt.Printf("GetAllKeyValues right after %v\n", keyVals)</span>
        // for _, kv := range keyVals.KeyVals {
        //         fmt.Printf("[Key] %x\n[Value] %x\n", kv[0], kv[1])
        // }
}

func (t *MerkleTree) PrintTree(node *Node, level int) <span class="cov0" title="0">{
        fmt.Printf("\n----------------PrintTree START----------------\n")
        t.printTree(node, level)
        fmt.Printf("\n----------------PrintTree END----------------\n")
}</span>

// maximum size: The total encoded length of the response
func (t *MerkleTree) GetStateByRange(starKey []byte, endKey []byte, maxSize uint32) (foundKeyVal []types.StateKeyValue, boundaryNode [][]byte, err error) <span class="cov0" title="0">{
        foundKeyVal = make([]types.StateKeyValue, 0)
        currenSize := uint32(0)
        paddedStart := make([]byte, 32)
        copy(paddedStart, starKey)
        value, _, _ := t.Get(paddedStart)
        // fmt.Printf("paddedStart: %x, value: %x\n", paddedStart, value)
        found := false
        end := false
        if value != nil </span><span class="cov0" title="0">{
                t.getTreeContentIncludeKey(t.Root, 0, starKey, endKey, &amp;currenSize, maxSize, &amp;foundKeyVal, &amp;boundaryNode, &amp;found, &amp;end)
        }</span> else<span class="cov0" title="0"> {
                t.getTreeContent(t.Root, 0, starKey, endKey, &amp;currenSize, maxSize, &amp;foundKeyVal, &amp;boundaryNode)
        }</span>
        <span class="cov0" title="0">return foundKeyVal, boundaryNode, err</span>
}

func (t *MerkleTree) getTreeContentIncludeKey(node *Node, level int, starKey []byte, endKey []byte, currenSize *uint32, maxSize uint32, foundkv *[]types.StateKeyValue, boundaryNodes *[][]byte, findKey *bool, end *bool) (ok bool) <span class="cov0" title="0">{
        if *currenSize &gt;= maxSize || *end </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">nodeType := "Branch"
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                nodeType = "Leaf"
        }</span>
        //fmt.Printf("%s[%s Node] Key: %x, Hash: %x\n", strings.Repeat("  ", level), nodeType, node.Key, node.Hash)
        <span class="cov0" title="0">*boundaryNodes = append(*boundaryNodes, node.Hash)

        value, _, _ := t.Get(node.Key)

        // Copy the original key into the new slice
        if value != nil </span><span class="cov0" title="0">{
                //fmt.Printf("%s  [Leaf Node] Value: %x\n", strings.Repeat("  ", level), value)
                paddedStart := make([]byte, len(node.Key))
                paddedEnd := make([]byte, len(node.Key))
                // Copy the original key into the new slice
                copy(paddedStart, starKey)
                copy(paddedEnd, endKey)

                if common.CompareBytes(node.Key, paddedStart) </span><span class="cov0" title="0">{
                        fmt.Printf("Found Key: %x\n", node.Key)
                        *boundaryNodes = make([][]byte, 0)
                        *boundaryNodes, _ = t.GetPath(node.Key)
                        *boundaryNodes = append(*boundaryNodes, node.Hash)
                        *findKey = true
                }</span>
                <span class="cov0" title="0">if *findKey </span><span class="cov0" title="0">{
                        if (common.CompareKeys(paddedStart, node.Key) &gt;= 0 &amp;&amp; common.CompareKeys(paddedEnd, node.Key) &gt;= 0) &amp;&amp; (nodeType == "Leaf") </span><span class="cov0" title="0">{
                                // check if the key is within range..
                                // key is expected to 31 bytes

                                var k_31 [31]byte
                                copy(k_31[:], node.Key[:31])
                                if len(k_31) != 31 </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("Key is not 31 bytes: %x", node.Key))</span>
                                }
                                <span class="cov0" title="0">stateKeyValue := types.StateKeyValue{
                                        Key:   k_31,
                                        Len:   uint8(len(value)),
                                        Value: value,
                                }
                                addSize := len(stateKeyValue.Key) + len(stateKeyValue.Value)
                                // fmt.Printf("[%v] Adding key++Len++Val len(%v|%v=&gt; %v)\n", nodeType, len(stateKeyValue.Key), len(stateKeyValue.Value), addSize)

                                *foundkv = append(*foundkv, stateKeyValue)
                                *currenSize += uint32(addSize)</span>
                        }
                        <span class="cov0" title="0">if common.CompareBytes(paddedEnd, node.Key) </span><span class="cov0" title="0">{
                                *end = true
                                return true
                        }</span>
                }
        }
        <span class="cov0" title="0">if node.Left != nil || node.Right != nil </span><span class="cov0" title="0">{
                //fmt.Printf("%s  Left:\n", strings.Repeat("  ", level))
                t.getTreeContentIncludeKey(node.Left, level+1, starKey, endKey, currenSize, maxSize, foundkv, boundaryNodes, findKey, end)
                //fmt.Printf("%s  Right:\n", strings.Repeat("  ", level))
                t.getTreeContentIncludeKey(node.Right, level+1, starKey, endKey, currenSize, maxSize, foundkv, boundaryNodes, findKey, end)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (t *MerkleTree) getTreeContent(node *Node, level int, starKey []byte, endKey []byte, currenSize *uint32, maxSize uint32, foundkv *[]types.StateKeyValue, boundaryNodes *[][]byte) (ok bool) <span class="cov0" title="0">{
        if *currenSize &gt;= maxSize </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">nodeType := "Branch"
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                nodeType = "Leaf"
        }</span>
        //fmt.Printf("%s[%s Node] Key: %x, Hash: %x\n", strings.Repeat("  ", level), nodeType, node.Key, node.Hash)
        <span class="cov0" title="0">*boundaryNodes = append(*boundaryNodes, node.Hash)
        value, _, _ := t.Get(node.Key)
        if value != nil </span><span class="cov0" title="0">{
                //fmt.Printf("%s  [Leaf Node] Value: %x\n", strings.Repeat("  ", level), value)
                paddedStart := make([]byte, len(node.Key))
                paddedEnd := make([]byte, len(node.Key))
                // Copy the original key into the new slice
                copy(paddedStart, starKey)
                copy(paddedEnd, endKey)
                if nodeType == "Leaf" </span><span class="cov0" title="0">{
                        // check if the key is within range..
                        // key is expected to 31 bytes

                        var k_31 [31]byte
                        copy(k_31[:], node.Key[:31])
                        if len(k_31) != 31 </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("Key is not 31 bytes: %x", node.Key))</span>
                        }
                        <span class="cov0" title="0">stateKeyValue := types.StateKeyValue{
                                Key:   k_31,
                                Len:   uint8(len(value)),
                                Value: value,
                        }
                        addSize := len(stateKeyValue.Key) + len(stateKeyValue.Value)
                        // fmt.Printf("[%v] Adding key++Len++Val len(%v|%v=&gt; %v)\n", nodeType, len(stateKeyValue.Key), len(stateKeyValue.Value), addSize)

                        *foundkv = append(*foundkv, stateKeyValue)
                        *currenSize += uint32(addSize)</span>
                }
                <span class="cov0" title="0">if common.CompareBytes(paddedEnd, node.Key) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">if node.Left != nil || node.Right != nil </span><span class="cov0" title="0">{
                //fmt.Printf("%s  Left:\n", strings.Repeat("  ", level))
                t.getTreeContent(node.Left, level+1, starKey, endKey, currenSize, maxSize, foundkv, boundaryNodes)
                //fmt.Printf("%s  Right:\n", strings.Repeat("  ", level))
                t.getTreeContent(node.Right, level+1, starKey, endKey, currenSize, maxSize, foundkv, boundaryNodes)
        }</span>
        <span class="cov0" title="0">return true</span>
}

func (t *MerkleTree) GetRealKey(key [31]byte, value []byte) []byte <span class="cov0" title="0">{
        encodedLeaf := leaf(key[:], value)
        nodeHash := computeHash(encodedLeaf)

        leafKey, _, _ := t.levelDBGetLeaf(nodeHash)
        // fmt.Printf("levelDBGetNode: nodeHash=%x, leafKey=%x\n", nodeHash, leafKey)
        if leafKey != nil </span><span class="cov0" title="0">{
                realKey, _, _ := t.db.ReadRawKV(computeHash([]byte(append(nodeHash, leafKey...))))
                //leafValue, _ := t.db.Get([]byte(append(nodeHash, leafKey...)), nil)
                return realKey
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (t *MerkleTree) printTree(node *Node, level int) <span class="cov0" title="0">{
        if level == 0 &amp;&amp; t.Root != nil </span><span class="cov0" title="0">{
                fmt.Printf("Root Hash: %x\n", t.Root.Hash)
        }</span>
        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                fmt.Printf("%snode empty\n", strings.Repeat("  ", level))
                return
        }</span>
        <span class="cov0" title="0">nodeType := "Branch"
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                nodeType = "Leaf"
        }</span>
        <span class="cov0" title="0">fmt.Printf("%s[%s Node] Key: %x, Hash: %x\n", strings.Repeat("  ", level), nodeType, node.Key, node.Hash)
        value, _, _ := t.Get(node.Key)
        if value != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s  [Leaf Node] Value: %x\n", strings.Repeat("  ", level), value)
        }</span>
        <span class="cov0" title="0">if node.Left != nil || node.Right != nil </span><span class="cov0" title="0">{
                fmt.Printf("%s  Left:\n", strings.Repeat("  ", level))
                t.printTree(node.Left, level+1)
                fmt.Printf("%s  Right:\n", strings.Repeat("  ", level))
                t.printTree(node.Right, level+1)
        }</span>
}

func (t *MerkleTree) SetRawKeyVal(key common.Hash, value []byte) <span class="cov0" title="0">{
        t.Insert(key.Bytes(), value)
}</span>

func (t *MerkleTree) SetState(_stateIdentifier string, value []byte) <span class="cov0" title="0">{
        stateKey := make([]byte, 32)
        debug := false
        switch _stateIdentifier </span>{
        case C1:<span class="cov0" title="0">
                stateKey[0] = 0x01</span>
        case C2:<span class="cov0" title="0">
                stateKey[0] = 0x02</span>
        case C3:<span class="cov0" title="0">
                stateKey[0] = 0x03</span>
        case C4:<span class="cov0" title="0">
                stateKey[0] = 0x04</span>
        case C5:<span class="cov0" title="0">
                stateKey[0] = 0x05</span>
        case C6:<span class="cov0" title="0">
                stateKey[0] = 0x06</span>
        case C7:<span class="cov0" title="0">
                stateKey[0] = 0x07</span>
        case C8:<span class="cov0" title="0">
                stateKey[0] = 0x08</span>
        case C9:<span class="cov0" title="0">
                stateKey[0] = 0x09</span>
        case C10:<span class="cov0" title="0">
                stateKey[0] = 0x0A</span>
        case C11:<span class="cov0" title="0">
                stateKey[0] = 0x0B</span>
        case C12:<span class="cov0" title="0">
                stateKey[0] = 0x0C</span>
        case C13:<span class="cov0" title="0">
                stateKey[0] = 0x0D</span>
        case C14:<span class="cov0" title="0">
                stateKey[0] = 0x0E</span>
        case C15:<span class="cov0" title="0">
                stateKey[0] = 0x0F</span>
        }
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("SetState %v stateKey=%x | value=%x\n", _stateIdentifier, stateKey, value)
        }</span>
        <span class="cov0" title="0">t.Insert(stateKey, value)</span>
}

func (t *MerkleTree) GetState(_stateIdentifier string) ([]byte, error) <span class="cov0" title="0">{
        stateKey := make([]byte, 32)
        debug := false
        switch _stateIdentifier </span>{
        case C1:<span class="cov0" title="0">
                stateKey[0] = 0x01</span>
        case C2:<span class="cov0" title="0">
                stateKey[0] = 0x02</span>
        case C3:<span class="cov0" title="0">
                stateKey[0] = 0x03</span>
        case C4:<span class="cov0" title="0">
                stateKey[0] = 0x04</span>
        case C5:<span class="cov0" title="0">
                stateKey[0] = 0x05</span>
        case C6:<span class="cov0" title="0">
                stateKey[0] = 0x06</span>
        case C7:<span class="cov0" title="0">
                stateKey[0] = 0x07</span>
        case C8:<span class="cov0" title="0">
                stateKey[0] = 0x08</span>
        case C9:<span class="cov0" title="0">
                stateKey[0] = 0x09</span>
        case C10:<span class="cov0" title="0">
                stateKey[0] = 0x0A</span>
        case C11:<span class="cov0" title="0">
                stateKey[0] = 0x0B</span>
        case C12:<span class="cov0" title="0">
                stateKey[0] = 0x0C</span>
        case C13:<span class="cov0" title="0">
                stateKey[0] = 0x0D</span>
        case C14:<span class="cov0" title="0">
                stateKey[0] = 0x0E</span>
        case C15:<span class="cov0" title="0">
                stateKey[0] = 0x0F</span>
        }
        <span class="cov0" title="0">value, ok, err := t.Get(stateKey)
        if !ok || err != nil </span><span class="cov0" title="0">{
                fmt.Printf("GetState stateKey=%x Error %v, %v\n", stateKey, ok, err)
                if debug </span><span class="cov0" title="0">{
                        fmt.Printf("GetState %v stateKey=%x | RecovedValue=%x, err=%v\n", _stateIdentifier, stateKey, value, err)
                }</span>
        }
        <span class="cov0" title="0">return value, err</span>
}

func (t *MerkleTree) SetService(i uint8, s uint32, v []byte) <span class="cov8" title="1">{
        /*
                ∀(s ↦ a) ∈ δ ∶ C(255, s) ↦ a c ⌢E 8 (a b ,a g ,a m ,a l )⌢E 4 (a i )
                i: 255
                s: service_index
                ac: service_accout_code_hash
                ab: service_accout_balance
                ag: service_accout_accumulate_gas
                am: service_accout_on_transfer_gas
                al: see GP_0.35(95)
                ai: see GP_0.35(95)

                (i, s ∈ N S ) ↦ [i, n 0 ,n 1 ,n 2 ,n 3 , 0, 0, . . . ] where n = E 4 (s)
        */
        service_account := common.ComputeC_is(i, s)
        stateKey := service_account.Bytes()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("SetService stateKey=%x, v=%x\n", stateKey, v)
        }</span>

        <span class="cov8" title="1">metaKey := fmt.Sprintf("meta_%x", stateKey)
        metaKeyBytes, err := types.Encode(metaKey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetService metaKey Encode Error: %v\n", err)
        }</span>

        <span class="cov8" title="1">acctState, err := types.AccountStateFromBytes(s, v)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetService AccountStateFromBytes Error: %v\n", err)
        }</span>

        <span class="cov8" title="1">metaVal := fmt.Sprintf("service_account|s=%d|b=%d g=%d m=%d l=%d i=%d|clen=%d", s, acctState.Balance, acctState.GasLimitG, acctState.GasLimitM, acctState.StorageSize, acctState.NumStorageItems, len(acctState.CodeHash))
        metaValBytes, err := types.Encode(metaVal)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetService metaValBytes Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">t.levelDBSet(metaKeyBytes, metaValBytes)
        t.Insert(stateKey, v)</span>
}

func (t *MerkleTree) GetService(i uint8, s uint32) ([]byte, bool, error) <span class="cov8" title="1">{
        service_account := common.ComputeC_is(i, s)
        stateKey := service_account.Bytes()
        value, ok, err := t.Get(stateKey)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, fmt.Errorf("GetService Error: %v\n", err) //Need to differentiate not found vs leveldb error
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                return nil, ok, nil
        }</span>
        <span class="cov8" title="1">return value, true, nil</span>
}

// set a_l (with timeslot if we have E_P). For GP_0.3.5(158)
func (t *MerkleTree) SetPreImageLookup(s uint32, blob_hash common.Hash, blob_len uint32, time_slots []uint32) <span class="cov8" title="1">{

        al_internal_key := common.Compute_preimageLookup_internal(blob_hash, blob_len)
        account_lookuphash := common.ComputeC_sh(s, al_internal_key) // C(s, (h,l))
        stateKey := account_lookuphash.Bytes()

        /*
                Follow GP_0.3.5(270, 273, 274, 276, 291)
                Process State value(timeslots), covert []uint32 to []byte
        */

        vBytes, err := types.Encode(time_slots)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageLookup Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">if debug </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageLookup stateKey=%x, vBytes=%v\n", stateKey, vBytes)
        }</span>
        // Insert the value into the state

        <span class="cov8" title="1">metaKey := fmt.Sprintf("meta_%x", stateKey)
        metaKeyBytes, err := types.Encode(metaKey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageLookup Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">metaVal := fmt.Sprintf("account_lookup|s=%d|h=%s l=%d t=%d|tlen=%d", s, blob_hash, blob_len, time_slots, len(time_slots))
        metaValBytes, err := types.Encode(metaVal)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageLookup metaValBytes Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">t.levelDBSet(metaKeyBytes, metaValBytes)
        t.Insert(stateKey, vBytes)</span>
}

// lookup a_l .. returning time slot. For GP_0.3.5(157)
func (t *MerkleTree) GetPreImageLookup(s uint32, blob_hash common.Hash, blob_len uint32) ([]uint32, bool, error) <span class="cov8" title="1">{

        al_internal_key := common.Compute_preimageLookup_internal(blob_hash, blob_len)
        account_lookuphash := common.ComputeC_sh(s, al_internal_key) // C(s, (h,l))

        stateKey := account_lookuphash.Bytes()

        /*
                Follow GP_0.3.5(270, 273, 274, 276, 291)
                Process State value(timeslots), covert []uint32 to []byte
        */

        vByte, ok, err := t.Get(stateKey)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ok, err
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                return nil, ok, nil
        }</span>
        <span class="cov0" title="0">if debug </span><span class="cov0" title="0">{
                fmt.Printf("GetPreImageLookup stateKey=%x, vByte=%v\n", stateKey, vByte)
        }</span>
        <span class="cov0" title="0">var time_slots []uint32

        if len(vByte) == 0 </span><span class="cov0" title="0">{
                time_slots = make([]uint32, 0)
        }</span> else<span class="cov0" title="0"> {
                vByte = vByte[1:]
                time_slots = make([]uint32, (len(vByte) / 4))
                for i := 0; i &lt; len(time_slots); i++ </span><span class="cov0" title="0">{
                        time_slots[i] = binary.LittleEndian.Uint32(vByte[i*4 : (i+1)*4])
                }</span>
        }
        <span class="cov0" title="0">return time_slots, ok, err</span>
}

// Delete PreImageLookup key(hash)
func (t *MerkleTree) DeletePreImageLookup(s uint32, blob_hash common.Hash, blob_len uint32) error <span class="cov8" title="1">{

        al_internal_key := common.Compute_preimageLookup_internal(blob_hash, blob_len)
        account_lookuphash := common.ComputeC_sh(s, al_internal_key) // C(s, (h,l))
        stateKey := account_lookuphash.Bytes()

        err := t.Delete(stateKey)

        return err
}</span>

// Insert Storage Value into the trie
func (t *MerkleTree) SetServiceStorage(s uint32, k []byte, storageValue []byte) <span class="cov8" title="1">{
        storageKey := common.Compute_storageKey_internal_byte(s, k)

        account_storage_key := common.ComputeC_sh_Byte(s, storageKey)
        stateKey := account_storage_key.Bytes()
        if debug </span><span class="cov0" title="0">{
                fmt.Printf("SetServiceStorage s = %d, hk = %x, k = %x\n", s, storageKey, k)
                fmt.Printf("SetServiceStorage stateKey=%x, storageValue=%x\n", stateKey, storageValue)
        }</span>

        <span class="cov8" title="1">metaKey := fmt.Sprintf("meta_%x", stateKey)
        metaKeyBytes, err := types.Encode(metaKey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetServiceStorage Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">metaVal := fmt.Sprintf("account_storage|s=%d|hk=%x k=%x|vlen=%d klen=%d", s, storageKey, k, len(storageValue), len(k))
        metaValBytes, err := types.Encode(metaVal)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetServiceStorage metaValBytes Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">t.levelDBSet(metaKeyBytes, metaValBytes)
        t.Insert(stateKey, storageValue)</span>
}

func (t *MerkleTree) GetServiceStorage(s uint32, k []byte) ([]byte, bool, error) <span class="cov8" title="1">{
        storageKey := common.Compute_storageKey_internal_byte(s, k)

        account_storage_key := common.ComputeC_sh_Byte(s, storageKey)
        stateKey := account_storage_key.Bytes()

        // Get Storage from trie
        value, ok, err := t.Get(stateKey)
        if !ok || err != nil </span><span class="cov8" title="1">{
                // fmt.Printf("GetServiceStorage stateKey=%x Error %v, %v\n", stateKey, ok, err)
                return nil, ok, err
        }</span>
        <span class="cov0" title="0">return value, true, nil</span>
}

// Delete Storage key(hash)
func (t *MerkleTree) DeleteServiceStorage(s uint32, k []byte) error <span class="cov8" title="1">{
        storageKey := common.Compute_storageKey_internal_byte(s, k)
        account_storage_key := common.ComputeC_sh_Byte(s, storageKey)
        stateKey := account_storage_key.Bytes()
        err := t.Delete(stateKey)
        return err
}</span>

// Set PreImage Blob for GP_0.3.5(158)
func (t *MerkleTree) SetPreImageBlob(s uint32, blob []byte) <span class="cov8" title="1">{
        /*
                ∀(s ↦ a) ∈ δ, (h ↦ p) ∈ a p ∶ C(s, h) ↦ p
                (s, h) ↦ [n 0 ,h 0 ,n 1 ,h 1 ,n 2 ,h 2 ,n 3 ,h 3 ,h 4 ,h 5 ,...,h 27 ] where n = E 4 (s)

                s: service_index
                h: blob_hash
                p: blob
        */

        blobHash := common.Blake2Hash(blob)
        ap_internal_key := common.Compute_preimageBlob_internal(blobHash)
        account_preimage_hash := common.ComputeC_sh(s, ap_internal_key)

        stateKey := account_preimage_hash.Bytes()

        metaKey := fmt.Sprintf("meta_%x", stateKey)
        metaKeyBytes, err := types.Encode(metaKey)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageBlob Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">metaVal := fmt.Sprintf("account_preimage|s=%d|h=%v|plen=%d", s, blobHash, len(blob))
        metaValBytes, err := types.Encode(metaVal)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("SetPreImageBlob metaValBytes Encode Error: %v\n", err)
        }</span>
        <span class="cov8" title="1">t.levelDBSet(metaKeyBytes, metaValBytes)
        // Insert Preimage Blob into trie
        t.Insert(stateKey, blob)</span>
}

func (t *MerkleTree) GetPreImageBlob(s uint32, blobHash common.Hash) (value []byte, ok bool, err error) <span class="cov8" title="1">{
        ap_internal_key := common.Compute_preimageBlob_internal(blobHash)
        account_preimage_hash := common.ComputeC_sh(s, ap_internal_key)

        stateKey := account_preimage_hash.Bytes()
        value, ok, err = t.Get(stateKey)
        if !ok || err != nil </span><span class="cov8" title="1">{
                // fmt.Printf("GetPreImageBlob stateKey=%x Error %v, %v\n", stateKey, ok, err)
                return nil, ok, err
        }</span>
        // Get Preimage Blob from trie
        <span class="cov0" title="0">return value, ok, nil</span>
}

// Delete PreImage Blob
func (t *MerkleTree) DeletePreImageBlob(s uint32, blobHash common.Hash) error <span class="cov8" title="1">{
        ap_internal_key := common.Compute_preimageBlob_internal(blobHash)
        account_preimage_hash := common.ComputeC_sh(s, ap_internal_key)

        stateKey := account_preimage_hash.Bytes()
        err := t.Delete(stateKey)
        return err
}</span>

// Insert fixed-length hashed key with value for the BPT
func (t *MerkleTree) Insert(key, value []byte) <span class="cov8" title="1">{
        // if common.CompareBytes(key, common.Hex2Bytes("ff00000000000000000000000000000000000000000000000000000000000000")) {
        //         panic("Insert: key is ff")
        // }
        node, err := t.findNode(t.Root, key, 0)
        if err != nil </span><span class="cov8" title="1">{
                encodedLeaf := leaf(key, value)
                t.levelDBSetLeaf(encodedLeaf, value, key)
                if t.Root == nil </span><span class="cov8" title="1">{
                        //fmt.Printf("encodedLeaf=%x, computedHash=%x\n", encodedLeaf, computeHash(encodedLeaf))
                        t.Root = &amp;Node{
                                Hash: computeHash(encodedLeaf),
                                Key:  key,
                        }

                }</span> else<span class="cov8" title="1"> {
                        t.Root = t.insertNode(t.Root, key, value, 0)
                }</span>
        } else<span class="cov0" title="0"> {
                encodedLeaf := leaf(key, value)
                t.levelDBSetLeaf(encodedLeaf, value, key)
                t.updateNode(node, key, value)
        }</span>
}

func (t *MerkleTree) insertNode(node *Node, key, value []byte, depth int) *Node <span class="cov8" title="1">{
        nullNode := Node{Hash: make([]byte, 32)}

        if node == nil || compareBytes(node.Hash, nullNode.Hash) || depth &gt; computeKeyLengthAsBit(key) </span><span class="cov8" title="1">{
                return &amp;Node{
                        Hash: computeHash(leaf(key, value)),
                        Key:  key,
                }
        }</span>

        <span class="cov8" title="1">if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov8" title="1">{
                if compareBytes(node.Key, key) </span><span class="cov0" title="0">{
                        node.Hash = computeHash(leaf(key, value))
                        return node
                }</span>
                <span class="cov8" title="1">return t.createBranchNode(node, key, value, depth)</span>
        }

        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                node.Right = t.insertNode(node.Right, key, value, depth+1)
        }</span> else<span class="cov8" title="1"> {
                node.Left = t.insertNode(node.Left, key, value, depth+1)
        }</span>

        <span class="cov8" title="1">leftHash := make([]byte, 32)
        rightHash := make([]byte, 32)

        if node.Left != nil </span><span class="cov8" title="1">{
                leftHash = node.Left.Hash
        }</span> else<span class="cov0" title="0"> {
                node.Left = &amp;Node{Hash: make([]byte, 32)}
        }</span>

        <span class="cov8" title="1">if node.Right != nil </span><span class="cov8" title="1">{
                rightHash = node.Right.Hash
        }</span> else<span class="cov0" title="0"> {
                node.Right = &amp;Node{Hash: make([]byte, 32)}
        }</span>

        <span class="cov8" title="1">node.Hash = computeHash(branch(leftHash, rightHash))
        t.levelDBSetBranch(node.Hash, append(leftHash, rightHash...))
        return node</span>
}

func (t *MerkleTree) createBranchNode(node *Node, key, value []byte, depth int) *Node <span class="cov8" title="1">{
        existingKey := node.Key
        //existingValue, _ := t.GetValue_stanley(node.Key) // new but wrong
        existingValue, _, _ := t.Get(node.Key)

        // why do you need to null here?
        node.Key = nil

        if bit(existingKey, depth) </span><span class="cov8" title="1">{
                node.Right = &amp;Node{
                        Hash: computeHash(leaf(existingKey, existingValue)),
                        Key:  existingKey,
                }
        }</span> else<span class="cov8" title="1"> {
                node.Left = &amp;Node{
                        Hash: computeHash(leaf(existingKey, existingValue)),
                        Key:  existingKey,
                }
        }</span>

        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                node.Right = t.insertNode(node.Right, key, value, depth+1)
        }</span> else<span class="cov8" title="1"> {
                node.Left = t.insertNode(node.Left, key, value, depth+1)
        }</span>

        <span class="cov8" title="1">leftHash := make([]byte, 32)
        rightHash := make([]byte, 32)

        if node.Left != nil </span><span class="cov8" title="1">{
                leftHash = node.Left.Hash
        }</span> else<span class="cov8" title="1"> {
                node.Left = &amp;Node{Hash: make([]byte, 32)}
        }</span>

        <span class="cov8" title="1">if node.Right != nil </span><span class="cov8" title="1">{
                rightHash = node.Right.Hash
        }</span> else<span class="cov8" title="1"> {
                node.Right = &amp;Node{Hash: make([]byte, 32)}
        }</span>

        <span class="cov8" title="1">node.Hash = computeHash(branch(leftHash, rightHash))
        t.levelDBSetBranch(node.Hash, append(leftHash, rightHash...))
        return node</span>
}

func (t *MerkleTree) Modify(key, value []byte) error <span class="cov0" title="0">{
        node, err := t.findNode(t.Root, key, 0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">nodeHash := computeHash(leaf(key, value))
        t.levelDBSet(nodeHash, value)
        t.updateNode(node, key, value)
        return nil</span>
}

func (t *MerkleTree) findNode(node *Node, key []byte, depth int) (*Node, error) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return nil, errors.New("key not found")
        }</span>
        <span class="cov8" title="1">if compareBytes(node.Key, key) </span><span class="cov8" title="1">{
                return node, nil
        }</span>
        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                return t.findNode(node.Right, key, depth+1)
        }</span> else<span class="cov8" title="1"> {
                return t.findNode(node.Left, key, depth+1)
        }</span>
}

func (t *MerkleTree) updateNode(node *Node, key, value []byte) <span class="cov0" title="0">{
        node.Hash = computeHash(leaf(key, value))
        t.updateTree(t.Root, key, value, 0)
}</span>

func (t *MerkleTree) updateTree(node *Node, key, value []byte, depth int) <span class="cov0" title="0">{
        if node == nil || depth &gt; computeKeyLengthAsBit(key) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if compareBytes(node.Key, key) </span><span class="cov0" title="0">{
                node.Hash = computeHash(leaf(key, value))
                return
        }</span>
        <span class="cov0" title="0">if bit(key, depth) </span><span class="cov0" title="0">{
                t.updateTree(node.Right, key, value, depth+1)
        }</span> else<span class="cov0" title="0"> {
                t.updateTree(node.Left, key, value, depth+1)
        }</span>
        <span class="cov0" title="0">leftHash := make([]byte, 32)
        rightHash := make([]byte, 32)
        if node.Left != nil </span><span class="cov0" title="0">{
                leftHash = node.Left.Hash
        }</span> else<span class="cov0" title="0"> {
                node.Left = &amp;Node{Hash: make([]byte, 32)}
        }</span>
        <span class="cov0" title="0">if node.Right != nil </span><span class="cov0" title="0">{
                rightHash = node.Right.Hash
        }</span> else<span class="cov0" title="0"> {
                node.Right = &amp;Node{Hash: make([]byte, 32)}
        }</span>
        <span class="cov0" title="0">node.Hash = computeHash(branch(leftHash, rightHash))
        t.levelDBSetBranch(node.Hash, append(leftHash, rightHash...))</span>
}

// Get retrieves the value of a specific key in the Merkle Tree
// Add ok for detecting if the key is found or not
func (t *MerkleTree) Get(key []byte) ([]byte, bool, error) <span class="cov8" title="1">{
        value, ok, err := t.getValue(t.Root, key, 0)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ok, err
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                return nil, ok, nil
        }</span>
        <span class="cov8" title="1">return value, true, nil</span>
}

func (t *MerkleTree) GetValue(key []byte) ([]byte, error) <span class="cov0" title="0">{
        value, ok, err := t.getValue(t.Root, key, 0)
        if err != nil || !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("GetValue key not found: %x", key)
        }</span>
        <span class="cov0" title="0">return value, err</span>
}

func (t *MerkleTree) getValue(node *Node, key []byte, depth int) ([]byte, bool, error) <span class="cov8" title="1">{
        if node == nil || depth &gt; computeKeyLengthAsBit(key) </span><span class="cov8" title="1">{
                return nil, false, nil
        }</span>

        // fmt.Printf("Searching key: %x at node key: %x at depth: %d\n", key, node.Key, depth)
        <span class="cov8" title="1">if compareBytes(node.Key, key) </span><span class="cov8" title="1">{
                //fmt.Printf("Found key: %x with Hash: %x/n", key, node.Hash)
                valueLeaf, okLeaf, errLeaf := t.levelDBGetLeaf(node.Hash)
                if errLeaf != nil </span><span class="cov8" title="1">{
                        return nil, false, fmt.Errorf("GetValue: Error %v", errLeaf)
                }</span> else<span class="cov8" title="1"> if !okLeaf </span><span class="cov0" title="0">{
                        return nil, false, nil
                }</span> else<span class="cov8" title="1"> if valueLeaf != nil </span><span class="cov8" title="1">{
                        return valueLeaf, true, nil
                }</span>

                <span class="cov0" title="0">if t.db != nil </span><span class="cov0" title="0">{
                        valueRaw, okRaw, errRaw := t.db.ReadRawKV(node.Key)
                        if errRaw != nil </span><span class="cov0" title="0">{
                                return nil, false, fmt.Errorf("ReadRawKV: Error %v", errRaw)
                        }</span> else<span class="cov0" title="0"> if !okRaw </span><span class="cov0" title="0">{
                                return nil, false, nil
                        }</span> else<span class="cov0" title="0"> if valueRaw != nil </span><span class="cov0" title="0">{
                                return valueRaw, true, nil
                        }</span>
                }
                <span class="cov0" title="0">return nil, false, fmt.Errorf("unexpected error: key:%x", key)</span>
        }

        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                return t.getValue(node.Right, key, depth+1)
        }</span> else<span class="cov8" title="1"> {
                return t.getValue(node.Left, key, depth+1)
        }</span>
}

// Trace traces the path to a specific key in the Merkle Tree and returns the sibling hashes along the path
func (t *MerkleTree) Trace(key []byte) ([][]byte, error) <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov0" title="0">{
                return nil, errors.New("empty tree")
        }</span>
        <span class="cov8" title="1">var path [][]byte
        err := t.tracePath(t.Root, key, 0, &amp;path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return path, nil</span>
}

func (t *MerkleTree) tracePath(node *Node, key []byte, depth int, path *[][]byte) error <span class="cov8" title="1">{
        if node == nil || depth &gt; computeKeyLengthAsBit(key) </span><span class="cov8" title="1">{
                return errors.New("key not found")
        }</span>

        <span class="cov8" title="1">if compareBytes(node.Key, key) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                if node.Left != nil </span><span class="cov8" title="1">{
                        *path = append(*path, node.Left.Hash)
                }</span> else<span class="cov8" title="1"> {
                        *path = append(*path, make([]byte, 32))
                }</span>
                <span class="cov8" title="1">return t.tracePath(node.Right, key, depth+1, path)</span>
        } else<span class="cov8" title="1"> {
                if node.Right != nil </span><span class="cov8" title="1">{
                        *path = append(*path, node.Right.Hash)
                }</span> else<span class="cov0" title="0"> {
                        *path = append(*path, make([]byte, 32))
                }</span>
                <span class="cov8" title="1">return t.tracePath(node.Left, key, depth+1, path)</span>
        }
}

func (t *MerkleTree) GetPath(key []byte) ([][]byte, error) <span class="cov8" title="1">{
        if t.Root == nil </span><span class="cov0" title="0">{
                return nil, errors.New("empty tree")
        }</span>
        <span class="cov8" title="1">var path [][]byte
        err := t.getPath(t.Root, key, 0, &amp;path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return path, nil</span>
}

func (t *MerkleTree) getPath(node *Node, key []byte, depth int, path *[][]byte) error <span class="cov8" title="1">{
        if node == nil || depth &gt; computeKeyLengthAsBit(key) </span><span class="cov0" title="0">{
                return errors.New("key not found")
        }</span>

        <span class="cov8" title="1">if compareBytes(node.Key, key) </span><span class="cov0" title="0">{
                *path = append(*path, node.Hash)
                return nil
        }</span>

        <span class="cov8" title="1">if bit(key, depth) </span><span class="cov8" title="1">{
                if node.Hash != nil </span><span class="cov8" title="1">{
                        *path = append(*path, node.Hash)
                }</span> else<span class="cov0" title="0"> {
                        *path = append(*path, make([]byte, 32))
                }</span>
                <span class="cov8" title="1">return t.tracePath(node.Right, key, depth+1, path)</span>
        } else<span class="cov0" title="0"> {
                if node.Hash != nil </span><span class="cov0" title="0">{
                        *path = append(*path, node.Hash)
                }</span> else<span class="cov0" title="0"> {
                        *path = append(*path, make([]byte, 32))
                }</span>
                <span class="cov0" title="0">return t.tracePath(node.Left, key, depth+1, path)</span>
        }
}

// Verify verifies the path to a specific key in the Merkle Tree
func (t *MerkleTree) Verify(key []byte, value []byte, rootHash []byte, path [][]byte) bool <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                return compareBytes(computeHash(leaf(key, value)), rootHash)
        }</span>

        <span class="cov8" title="1">leafHash := computeHash(leaf(key, value))

        for i := len(path) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if bit(key, i) </span><span class="cov8" title="1">{
                        // fmt.Printf("computing hash (%x, %x):%x\n", path[i], leafHash, computeHash(branch(path[i], leafHash)))
                        leafHash = computeHash(branch(path[i], leafHash))
                }</span> else<span class="cov8" title="1"> {
                        // fmt.Printf("computing hash (%x, %x):%x\n", leafHash, path[i], computeHash(branch(leafHash, path[i])))
                        leafHash = computeHash(branch(leafHash, path[i]))
                }</span>
        }
        <span class="cov8" title="1">return compareBytes(leafHash, rootHash)</span>
}

// Delete removes a leaf node by key and reinserts remaining nodes into the tree
func (t *MerkleTree) Delete(key []byte) error <span class="cov8" title="1">{
        // Find the node to delete
        node, err := t.findNode(t.Root, key, 0)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Retrieve the value of the node to delete
        <span class="cov8" title="1">value, ok, err := t.levelDBGetLeaf(node.Hash)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("Delete: key not found: %x", key)
        }</span>

        // Collect remaining nodes' key-value pairs
        <span class="cov8" title="1">remainingNodes := [][2][]byte{}
        t.collectRemainingNodes(t.Root, key, &amp;remainingNodes)

        // Remove the node from levelDB
        nodeHash := computeHash(leaf(key, value))
        t.db.DeleteK(common.BytesToHash(nodeHash))
        //t.Close()

        // Rebuild the tree without the deleted node
        tree := NewMerkleTree(nil, t.db)
        for _, kv := range remainingNodes </span><span class="cov8" title="1">{
                tree.Insert(kv[0], kv[1])
        }</span>
        <span class="cov8" title="1">t.Root = tree.Root
        t.db = tree.db
        return nil</span>
}

// collectRemainingNodes collects all key-value pairs except for the one to be deleted
func (t *MerkleTree) collectRemainingNodes(node *Node, deleteKey []byte, nodes *[][2][]byte) <span class="cov8" title="1">{
        if node == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Skip the node to be deleted
        <span class="cov8" title="1">if compareBytes(node.Key, deleteKey) </span><span class="cov8" title="1">{
                return
        }</span>

        // Retrieve the value for the current node
        <span class="cov8" title="1">value, _, err := t.levelDBGetLeaf(node.Hash)
        if err == nil &amp;&amp; node.Key != nil </span><span class="cov8" title="1">{
                *nodes = append(*nodes, [2][]byte{node.Key, value})
        }</span>

        // Recursively collect from left and right subtrees
        <span class="cov8" title="1">t.collectRemainingNodes(node.Left, deleteKey, nodes)
        t.collectRemainingNodes(node.Right, deleteKey, nodes)</span>
}

func isBranchNode(value []byte) bool <span class="cov0" title="0">{
        // Implement logic to determine if a node is a branch node
        return len(value) == 64 &amp;&amp; value[0] != 0 &amp;&amp; value[1] != 0
}</span>

// Implement "¬"
func falseBytes(data []byte) []byte <span class="cov0" title="0">{
        result := make([]byte, len(data))
        for i := 0; i &lt; len(data); i++ </span><span class="cov0" title="0">{
                result[i] = 0xFF - data[i]
                // result[i] = ^data[i]
        }</span>
        <span class="cov0" title="0">return result</span>
}

// compareBytes compares two Tries
func CompareTrees(node1, node2 *Node) bool <span class="cov0" title="0">{
        return compareTrees(node1, node2)
}</span>

func compareTrees(node1, node2 *Node) bool <span class="cov8" title="1">{
        if node1 == nil &amp;&amp; node2 == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if node1 == nil &amp;&amp; node2 != nil </span><span class="cov0" title="0">{
                fmt.Printf("Node1 empty. Node2 Not Empty\n")
                fmt.Printf("Node1 %v\n", node1.String())
                fmt.Printf("Node2 %v\n", node2.String())
                return false
        }</span>
        <span class="cov8" title="1">if node1 != nil &amp;&amp; node2 == nil </span><span class="cov0" title="0">{
                fmt.Printf("Node1 Not empty. Node2 Empty\n")
                fmt.Printf("Node1 %v\n", node1.String())
                fmt.Printf("Node2 %v\n", node2.String())
                return false
        }</span>
        <span class="cov8" title="1">if !compareBytes(node1.Hash, node2.Hash) </span><span class="cov0" title="0">{
                fmt.Printf("Node Hash Mismatch N1=%x N2=%x\n", node1.Hash, node2.Hash)
                fmt.Printf("Node1 %v\n", node1.String())
                fmt.Printf("Node2 %v\n", node2.String())
                return false
        }</span>
        <span class="cov8" title="1">if !compareBytes(node1.Key, node2.Key) </span><span class="cov0" title="0">{
                fmt.Printf("Node Key Mismatch N1=%x N2=%x\n", node1.Key, node2.Key)
                fmt.Printf("Node1 %v\n", node1.String())
                fmt.Printf("Node2 %v\n", node2.String())
                return false
        }</span>
        <span class="cov8" title="1">return compareTrees(node1.Left, node2.Left) &amp;&amp; compareTrees(node1.Right, node2.Right)</span>
}

// Compute the key length in bits. byte -&gt; 8bits
func computeKeyLengthAsBit(key []byte) int <span class="cov8" title="1">{
        return len(key) * 8
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package trie

import (
        "errors"
        "fmt"
        "strings"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

//"golang.org/x/crypto/blake2b"

// CDT Node structure represents a node in the CDT
type CDTNode struct {
        Hash  []byte
        Value []byte
        Left  *CDTNode
        Right *CDTNode
}

// CDMerkleTree represents the Merkle Tree structure
type CDMerkleTree struct {
        root   *CDTNode
        leaves []*CDTNode
}

// NewCDMerkleTree creates a new constant-depth Merkle tree
func NewCDMerkleTree(values [][]byte) *CDMerkleTree <span class="cov8" title="1">{
        // If there are no leaves, return a tree with a hash of 0
        emptyHash := make([]byte, 32)
        if len(values) == 0 </span><span class="cov0" title="0">{
                return &amp;CDMerkleTree{
                        root: &amp;CDTNode{Hash: emptyHash},
                }
        }</span>

        // Padding leaves to the next power of 2
        <span class="cov8" title="1">paddedLeaves := values
        if len(values) != 1 </span><span class="cov8" title="1">{
                paddedLeaves = padLeaves(values)
        }</span>

        // Creating leaf nodes
        <span class="cov8" title="1">var leaves []*CDTNode
        for _, value := range paddedLeaves </span><span class="cov8" title="1">{
                if !compareBytes(value, emptyHash) </span><span class="cov8" title="1">{
                        leaves = append(leaves, &amp;CDTNode{Hash: computeLeaf(value), Value: value})
                }</span> else<span class="cov8" title="1"> {
                        leaves = append(leaves, &amp;CDTNode{Hash: emptyHash, Value: emptyHash})
                }</span>
        }

        // Build the tree recursively
        <span class="cov8" title="1">root := buildTree(leaves)

        return &amp;CDMerkleTree{
                root:   root,
                leaves: leaves,
        }</span>
}

// padLeaves pads the leaves to the next power of 2
func padLeaves(values [][]byte) [][]byte <span class="cov8" title="1">{
        n := len(values)
        nextPowerOfTwo := 1
        for nextPowerOfTwo &lt; n </span><span class="cov8" title="1">{
                nextPowerOfTwo &lt;&lt;= 1
        }</span>

        // Padding with zero hashes
        <span class="cov8" title="1">for len(values) &lt; nextPowerOfTwo </span><span class="cov8" title="1">{
                values = append(values, make([]byte, 32))
        }</span>

        <span class="cov8" title="1">return values</span>
}

// buildTree recursively builds the tree from the leaf nodes
func buildTree(leaves []*CDTNode) *CDTNode <span class="cov8" title="1">{
        // Base case: only one node, return it
        if len(leaves) == 1 </span><span class="cov8" title="1">{
                return leaves[0]
        }</span>

        <span class="cov8" title="1">var nextLevel []*CDTNode

        // Combine nodes in pairs
        for i := 0; i &lt; len(leaves); i += 2 </span><span class="cov8" title="1">{
                left := leaves[i]
                right := leaves[i+1]
                parent := &amp;CDTNode{
                        Hash:  computeNode(append(left.Hash, right.Hash...)),
                        Left:  left,
                        Right: right,
                }
                nextLevel = append(nextLevel, parent)
        }</span>

        <span class="cov8" title="1">return buildTree(nextLevel)</span>
}

// PrintTree prints the tree structure for debugging
func (tree *CDMerkleTree) PrintTree() <span class="cov0" title="0">{
        printCDTNode(tree.root, 0, "Root")
}</span>

func printCDTNode(node *CDTNode, level int, pos string) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">prefix := strings.Repeat("  ", level)
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                fmt.Printf("%s[Leaf %s]: %s\n", prefix, pos, common.Bytes2Hex(node.Hash))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%s[Branch %s]: %s\n", prefix, pos, common.Bytes2Hex(node.Hash))
        }</span>
        <span class="cov0" title="0">printCDTNode(node.Left, level+1, "Left")
        printCDTNode(node.Right, level+1, "Right")</span>
}

// // Root returns the root of the Merkle Tree
func (tree *CDMerkleTree) Root() []byte <span class="cov8" title="1">{
        return tree.root.Hash
}</span>

func (tree *CDMerkleTree) RootHash() common.Hash <span class="cov0" title="0">{
        return common.BytesToHash(tree.Root())
}</span>

func (mt *CDMerkleTree) Length() int <span class="cov8" title="1">{
        return len(mt.leaves)
}</span>

func (mt *CDMerkleTree) IsOutOfRange(index int) (bool, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= mt.Length() </span><span class="cov8" title="1">{
                return true, fmt.Errorf("index %v out of range", index)
        }</span>
        <span class="cov8" title="1">return false, nil</span>
}

// Get returns the value of the leaf at the given index
func (mt *CDMerkleTree) Get(index int) ([]byte, error) <span class="cov8" title="1">{
        if _, err := mt.IsOutOfRange(index); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return mt.leaves[index].Value, nil</span>
}

// Justify returns the justification for a given index
func (mt *CDMerkleTree) Justify(index int) ([][]byte, error) <span class="cov8" title="1">{
        if _, err := mt.IsOutOfRange(index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">justification := make([][]byte, 0)
        currentNode := mt.leaves[index]

        if len(mt.leaves) == 1 </span><span class="cov0" title="0">{
                justification = append(justification, mt.Root())
                return justification, nil
        }</span>
        <span class="cov8" title="1">for currentNode != mt.root </span><span class="cov8" title="1">{
                parent := findParent(mt.root, currentNode)
                sibling := findSibling(parent, currentNode)
                if sibling != nil </span><span class="cov8" title="1">{
                        justification = append(justification, sibling.Hash)
                }</span> else<span class="cov0" title="0"> {
                        justification = append(justification, make([]byte, 32))
                }</span>
                <span class="cov8" title="1">currentNode = parent</span>
        }

        <span class="cov8" title="1">return justification, nil</span>
}

// JustifyX returns the justification for a given index and size x (function J_x)
func (mt *CDMerkleTree) JustifyX(index int, x int) ([][]byte, error) <span class="cov8" title="1">{
        if _, err := mt.IsOutOfRange(index); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">justification := make([][]byte, 0)
        if len(mt.leaves) == 1 </span><span class="cov0" title="0">{
                return append(justification, mt.Root()), nil
        }</span>
        <span class="cov8" title="1">currentNode := mt.leaves[index]
        var parent *CDTNode
        for currentNode != mt.root &amp;&amp; x &gt; 0 </span><span class="cov8" title="1">{
                parent = findParent(mt.root, currentNode)
                sibling := findSibling(parent, currentNode)
                if sibling != nil </span><span class="cov8" title="1">{
                        justification = append(justification, sibling.Hash)
                }</span> else<span class="cov0" title="0"> {
                        justification = append(justification, make([]byte, 32))
                }</span>
                <span class="cov8" title="1">currentNode = parent
                x--</span>
        }
        <span class="cov8" title="1">justification = append(justification, parent.Hash)
        return justification, nil</span>
}

func VerifyJustification(leafHash []byte, index int, justification [][]byte) []byte <span class="cov0" title="0">{
        return verifyJustification(leafHash, index, justification)
}</span>

// verifyJustification verifies the justification for a given index
func verifyJustification(leafHash []byte, index int, justification [][]byte) []byte <span class="cov8" title="1">{
        if len(justification) == 0 </span><span class="cov0" title="0">{
                return leafHash
        }</span>
        <span class="cov8" title="1">currentHash := leafHash
        for _, siblingHash := range justification </span><span class="cov8" title="1">{
                if index%2 == 0 </span><span class="cov8" title="1">{
                        currentHash = computeNode(append(currentHash, siblingHash...))
                }</span> else<span class="cov8" title="1"> {
                        currentHash = computeNode(append(siblingHash, currentHash...))
                }</span>
                <span class="cov8" title="1">index /= 2</span>
        }
        <span class="cov8" title="1">return currentHash</span>
}

func VerifyJustifyX(leafHash []byte, index int, justification [][]byte, x int) []byte <span class="cov8" title="1">{
        return verifyJustifyX(leafHash, index, justification, x)
}</span>

// verifyJustifyX verifies the justification for a given index and size x
func verifyJustifyX(leafHash []byte, index int, justification [][]byte, x int) []byte <span class="cov8" title="1">{
        currentHash := leafHash
        for i := 0; i &lt; x &amp;&amp; i &lt; len(justification)-1; i++ </span><span class="cov8" title="1">{
                siblingHash := justification[i]
                if index%2 == 0 </span><span class="cov8" title="1">{
                        currentHash = computeNode(append(currentHash, siblingHash...))
                }</span> else<span class="cov0" title="0"> {
                        currentHash = computeNode(append(siblingHash, currentHash...))
                }</span>
                <span class="cov8" title="1">index /= 2</span>
        }
        <span class="cov8" title="1">return currentHash</span>
}

func findParent(root, node *CDTNode) *CDTNode <span class="cov8" title="1">{
        if root == nil || root == node </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if root.Left == node || root.Right == node </span><span class="cov8" title="1">{
                return root
        }</span>
        <span class="cov8" title="1">parent := findParent(root.Left, node)
        if parent != nil </span><span class="cov8" title="1">{
                return parent
        }</span>
        <span class="cov8" title="1">return findParent(root.Right, node)</span>
}

func findSibling(parent, node *CDTNode) *CDTNode <span class="cov8" title="1">{
        if parent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if parent.Left == node </span><span class="cov8" title="1">{
                return parent.Right
        }</span>
        <span class="cov8" title="1">return parent.Left</span>
}

// generatePageProof creates paged proofs from segments
func GeneratePageProof(segments [][]byte) ([][]byte, error) <span class="cov0" title="0">{
        return generatePageProof(segments)
}</span>

/* generatePageProof creates paged proofs from segments
 */
func generatePageProof(segments [][]byte) ([][]byte, error) <span class="cov8" title="1">{
        // Build the Merkle tree
        tree := NewCDMerkleTree(segments)
        // Count the number of pages
        pageSize := 64
        numPages := (len(segments) + pageSize - 1) / pageSize // ceiling function
        results := make([][]byte, 0)
        for page := 0; page &lt; numPages; page++ </span><span class="cov8" title="1">{
                // The start and end index of the current page
                start := page * 64
                end := start + 64
                if end &gt; len(segments) </span><span class="cov8" title="1">{
                        end = len(segments)
                }</span>

                // Calculate the index of the leaf node
                <span class="cov8" title="1">i := page * 64

                // Get the justification for the leaf node
                tracePath, err := tree.JustifyX(i, 6)
                if err != nil </span><span class="cov0" title="0">{
                        return results, err
                }</span>

                // Encode the trace path and the segments
                <span class="cov8" title="1">combinedData := append(tracePath, segments[start:end]...)
                encoded, err := types.Encode(combinedData)

                if err != nil </span><span class="cov0" title="0">{
                        return results, err
                }</span>

                // Pad the encoded data to W_E * W_S
                // paddingSize := types.W_E * types.W_S
                // paddedOutput := make([]byte, paddingSize)
                // copy(paddedOutput, encoded) // If the encoded data is larger than the padding size, it will be truncated
                <span class="cov8" title="1">results = append(results, encoded)</span>
        }

        <span class="cov8" title="1">return results, nil</span>
}

// splitPageProof splits the page proof into trace path, root
func splitPageProof(pageProof [][]byte) ([][]byte, []byte, [][]byte) <span class="cov8" title="1">{
        switch </span>{
        case len(pageProof) == 2:<span class="cov0" title="0">
                return pageProof[0:1], pageProof[0], pageProof[1:]</span>
        case len(pageProof) == 4:<span class="cov8" title="1">
                return pageProof[0:2], pageProof[1], pageProof[2:]</span>
        case len(pageProof) &gt;= 6 &amp;&amp; len(pageProof) &lt;= 7:<span class="cov8" title="1">
                return pageProof[0:3], pageProof[2], pageProof[3:]</span>
        case len(pageProof) &gt;= 9 &amp;&amp; len(pageProof) &lt;= 12:<span class="cov8" title="1">
                return pageProof[0:4], pageProof[3], pageProof[4:]</span>
        case len(pageProof) &gt;= 14 &amp;&amp; len(pageProof) &lt;= 21:<span class="cov8" title="1">
                return pageProof[0:5], pageProof[4], pageProof[5:]</span>
        case len(pageProof) &gt;= 23 &amp;&amp; len(pageProof) &lt;= 38:<span class="cov8" title="1">
                return pageProof[0:6], pageProof[5], pageProof[6:]</span>
        default:<span class="cov8" title="1">
                return pageProof[0:7], pageProof[6], pageProof[7:]</span>
        }
}

func VerifyPageProof(pageProof [][]byte, pageIndex int) (bool, error) <span class="cov8" title="1">{
        if pageIndex &gt;= 1 </span><span class="cov8" title="1">{
                paddingSize := 71 - len(pageProof)
                if len(pageProof) != 71 </span><span class="cov8" title="1">{
                        for i := 0; i &lt; paddingSize; i++ </span><span class="cov8" title="1">{
                                pageProof = append(pageProof, make([]byte, 32))
                        }</span>
                }
        }
        <span class="cov8" title="1">tracePath, treeRoot, segments := splitPageProof(pageProof)
        // fmt.Printf("Trace path: %x\n", tracePath)
        // fmt.Printf("Tree root: %x\n", treeRoot)
        // fmt.Printf("Segments: %x\n", segments)
        // Verify the root hash
        tree := NewCDMerkleTree(segments)
        // tree.PrintTree()
        if !compareBytes(tree.Root(), treeRoot) </span><span class="cov0" title="0">{
                fmt.Printf("Root hash mismatch, expected %x, got %x\n", tree.Root(), treeRoot)
                return false, errors.New("Root hash mismatch")
        }</span>
        // Verify the justification for the leaf
        <span class="cov8" title="1">leafHash := computeLeaf(segments[0])
        computedRoot := VerifyJustifyX(leafHash, 0, tracePath, 6)
        expectedRoot := treeRoot

        if !compareBytes(computedRoot, expectedRoot) </span><span class="cov0" title="0">{
                fmt.Printf("Root hash mismatch: expected %x, got %x", expectedRoot, computedRoot)
                return false, errors.New("Root hash mismatch")
        }</span> else <span class="cov8" title="1">{
                // fmt.Printf("Root hash verified: %x\n", computedRoot)
        }</span>
        <span class="cov8" title="1">return true, nil</span>
}

func FindPositions(nums [][]byte, target []byte) int <span class="cov0" title="0">{
        return findPositions(nums, target)
}</span>

func findPositions(nums [][]byte, target []byte) int <span class="cov8" title="1">{
        positions := -1
        for i, num := range nums </span><span class="cov8" title="1">{
                if compareBytes(num, target) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return positions</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package trie

import (
        //"errors"
        //"math"

        //"fmt"
        "hash"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
        "golang.org/x/crypto/blake2b"
        "golang.org/x/crypto/sha3"
)

func BytesToHash(data []byte) common.Hash <span class="cov0" title="0">{
        return common.BytesToHash(data[:])
}</span>

func createHash() hash.Hash <span class="cov0" title="0">{
        h, _ := blake2b.New256(nil)
        return h
}</span>

var EMPTYHASH = make([]byte, 32)

// compareHashes compares two byte slices for equality
func compareBytes(a, b []byte) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range a </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// computeHash hashes the data using Blake2b-256
func computeHash(data []byte, hashType ...string) []byte <span class="cov8" title="1">{
        var h hash.Hash
        // Check if "keccak" is passed in hashType, else use default Blake2b-256.
        if len(hashType) &gt; 0 &amp;&amp; hashType[0] == types.Keccak </span><span class="cov0" title="0">{
                //fmt.Printf("!!using %v\n", types.Keccak)
                h = sha3.NewLegacyKeccak256()
        }</span> else<span class="cov8" title="1"> {
                h, _ = blake2b.New256(nil)
        }</span>
        <span class="cov8" title="1">h.Write(data)
        return h.Sum(nil)</span>
}

// computeNode hashes the data with $node on WBT, CDT using Blake2b-256
func computeNode(data []byte, hashType ...string) []byte <span class="cov8" title="1">{
        var h hash.Hash
        // Check if "keccak" is passed in hashType, else use default Blake2b-256.
        if len(hashType) &gt; 0 &amp;&amp; hashType[0] == types.Keccak </span><span class="cov8" title="1">{
                h = sha3.NewLegacyKeccak256()
        }</span> else<span class="cov8" title="1"> {
                h, _ = blake2b.New256(nil)
        }</span>
        <span class="cov8" title="1">h.Write([]byte("node"))
        h.Write(data)
        return h.Sum(nil)</span>
}

// computeLeaf hashes the data with $leaf on CDT using Blake2b-256
func computeLeaf(data []byte, hashType ...string) []byte <span class="cov8" title="1">{
        var h hash.Hash
        // Check if "keccak" is passed in hashType, else use default Blake2b-256.
        if len(hashType) &gt; 0 &amp;&amp; hashType[0] == types.Keccak </span><span class="cov8" title="1">{
                h = sha3.NewLegacyKeccak256()
        }</span> else<span class="cov8" title="1"> {
                h, _ = blake2b.New256(nil)
        }</span>
        <span class="cov8" title="1">h.Write([]byte("leaf"))
        h.Write(data)
        return h.Sum(nil)</span>
}

func ComputeLeaf(data []byte, hashType ...string) []byte <span class="cov0" title="0">{
        return computeLeaf(data, hashType...)
}</span>

// eq 187
func PadToMultipleOfN(x []byte, n int) []byte <span class="cov8" title="1">{
        if n &lt;= 0 </span><span class="cov0" title="0">{
                return x // If n is not positive, return the original slice
        }</span>
        <span class="cov8" title="1">paddingSize := (n - (len(x) % n)) % n // Calculate how many zeros to add
        if paddingSize == 0 </span><span class="cov0" title="0">{
                return x // Already a multiple of n
        }</span>
        <span class="cov8" title="1">padded := make([]byte, len(x)+paddingSize)
        copy(padded, x) // Copy original slice to the new padded slice
        return padded</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package trie

import (
        "encoding/hex"
        "fmt"

        "github.com/colorfulnotion/jam/storage"
)

func Initial_bpt(db *storage.StateDBStorage) ([]byte, *MerkleTree, error) <span class="cov8" title="1">{
        // Test data
        data := [][2]string{
                {"0000000000000000000000000000000000000000000000000000000000000000", "abcdef"},
                {"1111111111111111111111111111111111111111111111111111111111111111", "123456789987654321"},
        }

        decodedData := make([][2][]byte, len(data))
        for i, item := range data </span><span class="cov8" title="1">{
                key, err := hex.DecodeString(item[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to decode key: %v", err)
                }</span>
                <span class="cov8" title="1">value, err := hex.DecodeString(item[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to decode value: %v", err)
                }</span>
                <span class="cov8" title="1">decodedData[i] = [2][]byte{key, value}</span>
        }

        // Create a new Merkle Tree
        <span class="cov8" title="1">tree := NewMerkleTree(nil, db)
        // defer tree.Close()

        for _, item := range decodedData </span><span class="cov8" title="1">{
                tree.Insert(item[0], item[1])
        }</span>

        <span class="cov8" title="1">service_account_info := []string{
                /*
                        ac: Service Accout code, same as Service Accout Primage value, random generate
                        ab: Service Accout balance, random generate
                        ag: Service Accout gas for accumulate funtion, random generate
                        am: Service Accout gas for on_transfer funtion, random generate
                        al: In GP(95), An index of an Service Accout
                        ai: In GP(95), An index of an Service Accout
                */

                // Follow GP(292):
                /*   "|-----------------------------value----------------------------||------ab------||------ag------||------am------||------al------||--ai--|"   */
                /**/ "0000000000000000000000000000000000000000000000000000000000000000a0860100000000000a000000000000000a00000000000000960000000000000003000000", // s=0
                /**/ "1111111111111111111111111111111111111111111111111111111111111111b77a0000000000000a000000000000000a00000000000000960000000000000003000000", // s=1
                /**/ "222222222222222222222222222222222222222222222222222222222222222239300000000000000a000000000000000a00000000000000960000000000000003000000", // s=2
                /**/ "333333333333333333333333333333333333333333333333333333333333333306120f00000000000a000000000000000a00000000000000960000000000000003000000", // s=3
                /**/ "44444444444444444444444444444444444444444444444444444444444444449f860100000000000a000000000000000a00000000000000960000000000000003000000", // s=4
        }

        service_account_storage := [][2]string{
                /*
                        The way to generate "Service Account Storage Dict":

                        func bhash(data []byte) common.Hash {
                                hash := blake2b.Sum256(data)
                                return common.BytesToHash(hash[:])
                        }

                        sbytes := make([]byte, 4)
                        binary.LittleEndian.PutUint32(sbytes, 0) // s = 0,1,2,3,4
                        vBytes := []byte{18, 52, 86, 120} // initial RAM
                        k := bhash(append(sbytes, vBytes...))
                        fmt.Println(k)

                        value : Random generate
                */

                // Follow GP(292):
                /*    "|----------------------------hash------------------------------|"  "|-value-|"*/
                /**/ {"e6f0db7107765905cfdc1f19af6eb8ff07d89626f47429556d9a52b4e8b001d7", "0123456789"}, /* s=0 */
                /**/ {"b0d9726bb896edffa662a893c33ecfd228237736dc999f3484ce07ef101d1326", "9876543210"}, /* s=1 */
                /**/ {"10d33da886f4650e774a8fa7749b56266acdd32a894588ba94bb9cfa966cad8a", "aabbccddee"}, /* s=2 */
                /**/ {"7cedd57efd9c8e2211d7d149d046ba9e8f9173659e6339dbda93a7192fe081f2", "0011223344"}, /* s=3 */
                /**/ {"089208209619955d3467790628a955b80582e4ea0a4af264b000de85df79ed32", "5566778899"}, /* s=4 */
        }

        service_account_preimage := [][2]string{
                /*
                        The way to generate "Service Account Preimage Dict":

                        func bhash(data []byte) common.Hash {
                                hash := blake2b.Sum256(data)
                                return common.BytesToHash(hash[:])
                        }

                        hash := bhash(value)
                        value : Same as ac in service_account_info, represent code
                */

                // Follow GP(292):
                /*    "|----------------------------hash------------------------------|"  "|-----------------------------value----------------------------|"*/
                /**/ {"89eb0d6a8a691dae2cd15ed0369931ce0a949ecafa5c3f93f8121833646e15c3", "0000000000000000000000000000000000000000000000000000000000000000"}, /* s=0 */
                /**/ {"d4ffaeeac45aa41825e0bc3f875570af061acbf0b950ad752ff0f9463fe13ad5", "1111111111111111111111111111111111111111111111111111111111111111"}, /* s=1 */
                /**/ {"e2a94e18647fe0c6283a31e40c46ae1cc5f0867650f6834e4f01e34284adc9c7", "2222222222222222222222222222222222222222222222222222222222222222"}, /* s=2 */
                /**/ {"510c7466f2a90281df576a765517adfc6a4c8f89fee3e14b8eae3a574f442c37", "3333333333333333333333333333333333333333333333333333333333333333"}, /* s=3 */
                /**/ {"0395256ce5d90f07504b614b9e70e29a06fdd69cef6b01f6018615164125a5c5", "4444444444444444444444444444444444444444444444444444444444444444"}, /* s=4 */
        }

        service_account_preimage_l := [][2]string{

                /*
                        The way to generate "Service Account Preimage_l Dict":

                        hash := preimage_value_length + false(preimage_key[4:])
                        value : Service account preimage_l value, belongs to time slots, random generate
                */

                // Follow GP(292):
                /*    "|----------------------------hash------------------------------|"  "|----------value---------|"*/
                /**/ {"200000007596e251d32ea12fc966ce31f56b613505a3c06c07ede7cc9b91ea3c", "0101000000"}, /*                                 s=0 */
                /**/ {"200000003ba55be7da1f43c078aa8f50f9e5340f46af528ad00f06b9c01ec52a", "020100000002000000"}, /*                 s=1 */
                /**/ {"200000009b801f39d7c5ce1bf3b951e33a0f7989af097cb1b0fe1cbd7b523638", "03010000000200000003000000"}, /* s=2 */
                /**/ {"200000000d56fd7e20a89589aae8520395b37076011c1eb47151c5a8b0bbd3c8", "020200000003000000"}, /*                 s=3 */
                /**/ {"200000001a26f0f8afb49eb4618f1d65f90229631094fe09fe79eae9beda5a3a", "0103000000"}, /*                                 s=4 */

        }

        // Insert service index and service account info
        for s, hexString := range service_account_info </span><span class="cov8" title="1">{
                service_account_info_byte, err := hex.DecodeString(hexString)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                }</span>
                <span class="cov8" title="1">tree.SetService(255, uint32(s), service_account_info_byte)</span>
        }
        // Insert service index, hash, storage value
        <span class="cov8" title="1">for s, hexString := range service_account_storage </span><span class="cov8" title="1">{
                // service_account_storage_hash_byte, err := hex.DecodeString(hexString[0])
                // if err != nil {
                //         fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                // }
                service_account_storage_value_byte, err := hex.DecodeString(hexString[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                }</span>
                <span class="cov8" title="1">tree.SetPreImageBlob(uint32(s), service_account_storage_value_byte)</span>
        }
        // Insert service index, hash, primage value
        <span class="cov8" title="1">for s, hexString := range service_account_preimage </span><span class="cov8" title="1">{
                // service_account_primage_hash_byte, err := hex.DecodeString(hexString[0])
                // if err != nil {
                //         fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                // }
                service_account_primage_value_byte, err := hex.DecodeString(hexString[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                }</span>
                <span class="cov8" title="1">tree.SetPreImageBlob(uint32(s), service_account_primage_value_byte)</span>
        }

        // Insert service index, (preimage_length, hash), timeslots
        <span class="cov8" title="1">for s, hexString := range service_account_preimage_l </span><span class="cov8" title="1">{
                // service_account_primage_l_hash_byte, err := hex.DecodeString(hexString[0])
                // if err != nil {
                //         fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                // }
                service_account_primage_l_value_byte, err := hex.DecodeString(hexString[1])
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Errorf("Failed to decode service value %s: %v", hexString, err)
                }</span>
                <span class="cov8" title="1">tree.SetPreImageBlob(uint32(s), service_account_primage_l_value_byte)</span>
        }

        // Get the root hash of the tree
        <span class="cov8" title="1">rootHash := tree.GetRootHash()
        return rootHash, tree, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package trie

import (
        "bytes"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
        "github.com/ethereum/go-ethereum/crypto"
)

type MMR struct {
        Peaks []*common.Hash
}

func NewMMR() *MMR <span class="cov0" title="0">{
        return &amp;MMR{
                Peaks: make([]*common.Hash, 0),
        }
}</span>

func keccak256(data []byte) common.Hash <span class="cov8" title="1">{
        hash := crypto.Keccak256(data)
        return common.Hash(hash)
}</span>

func hashConcat(left, right *common.Hash) *common.Hash <span class="cov8" title="1">{
        if left == nil &amp;&amp; right == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if left == nil </span><span class="cov0" title="0">{
                left = &amp;common.Hash{}
        }</span>
        <span class="cov8" title="1">if right == nil </span><span class="cov0" title="0">{
                right = &amp;common.Hash{}
        }</span>
        <span class="cov8" title="1">combined := append(left.Bytes(), right.Bytes()...)
        r := keccak256(combined)
        return &amp;r</span>
}

// Append function for the MMR (as described in the image)
func (m *MMR) Append(data *common.Hash) <span class="cov8" title="1">{
        m.Peaks = appendToMMR(m.Peaks, data)
}</span>

func (m *MMR) Print() <span class="cov0" title="0">{
        for i, peak := range m.Peaks </span><span class="cov0" title="0">{
                if peak == nil </span><span class="cov0" title="0">{
                        fmt.Printf("Peak %d: nil\n", i)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Peak %d: %v\n", i, *peak)
                }</span>
        }
}

func (m *MMR) ComparePeaks(compare MMR) bool <span class="cov8" title="1">{
        for i, peak := range m.Peaks </span><span class="cov8" title="1">{
                cpeak := compare.Peaks[i]
                if peak == nil </span><span class="cov8" title="1">{
                        if cpeak != nil </span><span class="cov0" title="0">{
                                return false
                        }</span>
                } else<span class="cov8" title="1"> {
                        if bytes.Compare(cpeak.Bytes(), peak.Bytes()) != 0 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

func appendToMMR(Peaks []*common.Hash, l *common.Hash) []*common.Hash <span class="cov8" title="1">{
        return P(Peaks, l, 0)
}</span>

// Recursive function P, combining roots
func P(r []*common.Hash, l *common.Hash, n int) []*common.Hash <span class="cov8" title="1">{
        if n &gt;= len(r) </span><span class="cov8" title="1">{
                return append(r, l)
        }</span>
        <span class="cov8" title="1">if n &lt; len(r) &amp;&amp; r[n] == nil </span><span class="cov0" title="0">{
                return R(r, n, l)
        }</span>
        <span class="cov8" title="1">return P(R(r, n, nil), hashConcat(r[n], l), n+1)</span>
}

// Function R for updating Peaks
func R(r []*common.Hash, i int, t *common.Hash) []*common.Hash <span class="cov8" title="1">{
        s := make([]*common.Hash, len(r))
        for j := 0; j &lt; len(r); j++ </span><span class="cov8" title="1">{
                if i == j </span><span class="cov8" title="1">{
                        if t == nil </span><span class="cov8" title="1">{
                                s[j] = nil
                        }</span> else<span class="cov0" title="0"> {
                                s[j] = t
                        }</span>
                } else<span class="cov8" title="1"> {
                        s[j] = r[j]
                }</span>
        }
        <span class="cov8" title="1">return s</span>
}

func (M MMR) Encode() []byte <span class="cov0" title="0">{
        T := M.Peaks
        if len(T) == 0 </span><span class="cov0" title="0">{
                return []byte{0}
        }</span>

        <span class="cov0" title="0">encoded, err := types.Encode(uint(len(T)))
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">for i := 0; i &lt; len(T); i++ </span><span class="cov0" title="0">{
                if T[i] == nil </span><span class="cov0" title="0">{
                        encoded = append(encoded, 0)
                }</span> else<span class="cov0" title="0"> {
                        encoded = append(encoded, 1)
                        encodedTi, err := types.Encode(T[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">encoded = append(encoded, encodedTi...)</span>
                }
        }
        <span class="cov0" title="0">return encoded</span>
}

func (M MMR) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                M.Peaks = []*common.Hash{}
                return M, 0
        }</span>

        <span class="cov0" title="0">peaks_len, length, err := types.Decode(data, reflect.TypeOf(uint(0)))
        if err != nil </span><span class="cov0" title="0">{
                M.Peaks = []*common.Hash{}
                return M, 0
        }</span>

        <span class="cov0" title="0">if peaks_len.(uint) == 0 </span><span class="cov0" title="0">{
                M.Peaks = []*common.Hash{}
                return M, length
        }</span>

        <span class="cov0" title="0">peaks := make([]*common.Hash, peaks_len.(uint))
        for i := 0; i &lt; int(peaks_len.(uint)); i++ </span><span class="cov0" title="0">{
                if length &gt;= uint32(len(data)) </span><span class="cov0" title="0">{
                        M.Peaks = []*common.Hash{}
                        return M, 0
                }</span>

                <span class="cov0" title="0">if data[length] == 0 </span><span class="cov0" title="0">{
                        peaks[i] = nil
                        length++
                }</span> else<span class="cov0" title="0"> if data[length] == 1 </span><span class="cov0" title="0">{
                        length++
                        decoded, l, err := types.Decode(data[length:], reflect.TypeOf(&amp;common.Hash{}))
                        if err != nil </span><span class="cov0" title="0">{
                                M.Peaks = []*common.Hash{}
                                return M, 0
                        }</span>
                        <span class="cov0" title="0">peaks[i] = decoded.(*common.Hash)
                        length += l</span>
                } else<span class="cov0" title="0"> {
                        M.Peaks = []*common.Hash{}
                        return M, 0
                }</span>
        }
        <span class="cov0" title="0">M.Peaks = peaks
        return M, length</span>
}

func (M MMR) SuperPeak() *common.Hash <span class="cov0" title="0">{
        // Helper function to compute SuperPeak recursively
        var computeSuperPeak func(hashes []*common.Hash) *common.Hash
        computeSuperPeak = func(hashes []*common.Hash) *common.Hash </span><span class="cov0" title="0">{
                // Remove nil values from hashes
                nonNilHashes := make([]*common.Hash, 0)
                for _, h := range hashes </span><span class="cov0" title="0">{
                        if h != nil </span><span class="cov0" title="0">{
                                nonNilHashes = append(nonNilHashes, h)
                        }</span>
                }

                // Base cases
                <span class="cov0" title="0">if len(nonNilHashes) == 0 </span><span class="cov0" title="0">{
                        // Return empty hash (e.g., zero hash)
                        zeroHash := keccak256([]byte{})
                        return &amp;zeroHash
                }</span>
                <span class="cov0" title="0">if len(nonNilHashes) == 1 </span><span class="cov0" title="0">{
                        // Return the single hash
                        return nonNilHashes[0]
                }</span>

                // Recursive computation
                <span class="cov0" title="0">left := computeSuperPeak(nonNilHashes[:len(nonNilHashes)-1])
                right := nonNilHashes[len(nonNilHashes)-1]
                combined := append([]byte("node"), append(left.Bytes(), right.Bytes()...)...)
                superPeakHash := keccak256(combined)
                return &amp;superPeakHash</span>
        }

        // Start computation on the current MMR peaks
        <span class="cov0" title="0">return computeSuperPeak(M.Peaks)</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package trie

import (
        "bytes"
        "errors"
        "fmt"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

// Node represents a node in the Merkle Tree
type MMRNode struct {
        Hash  []byte
        Value []byte
        Left  *MMRNode
        Right *MMRNode
}

// MerkleMountainRange represents the MMR structure
type MerkleMountainRange struct {
        peaks    []*MMRNode
        hashType string
}

// NewMMR creates a new Merkle Mountain Range
func NewMMR_stanley(hashTypes ...string) *MerkleMountainRange <span class="cov0" title="0">{
        hashType := types.Blake2b
        if len(hashTypes) != 0 &amp;&amp; hashTypes[0] == types.Keccak </span><span class="cov0" title="0">{
                hashType = types.Keccak
        }</span>
        <span class="cov0" title="0">return &amp;MerkleMountainRange{
                peaks:    make([]*MMRNode, 0),
                hashType: hashType,
        }</span>
}

// Append adds a new leaf to the MMR
func (mmr *MerkleMountainRange) Append(value []byte) <span class="cov0" title="0">{
        leaf := &amp;MMRNode{
                // Hash:  computeHash(value),
                Hash:  value,
                Value: value,
        }
        mmr.peaks = append(mmr.peaks, leaf)
        mmr.rebalance()
}</span>

// rebalance maintains the MMR properties
func (mmr *MerkleMountainRange) rebalance() <span class="cov0" title="0">{
        for len(mmr.peaks) &gt; 1 </span><span class="cov0" title="0">{
                lastPeakSize := mmr.nodeSize(mmr.peaks[len(mmr.peaks)-1])
                secondLastPeakSize := mmr.nodeSize(mmr.peaks[len(mmr.peaks)-2])
                if lastPeakSize == secondLastPeakSize &amp;&amp; isPowerOfTwo(lastPeakSize) </span><span class="cov0" title="0">{
                        left := mmr.peaks[len(mmr.peaks)-2]
                        right := mmr.peaks[len(mmr.peaks)-1]
                        combined := &amp;MMRNode{
                                Hash:  computeHash(append(left.Hash, right.Hash...), mmr.hashType),
                                Left:  left,
                                Right: right,
                        }
                        mmr.peaks = mmr.peaks[:len(mmr.peaks)-2]
                        mmr.peaks = append(mmr.peaks, combined)
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
}

// Root returns the root hash of the MMR
func (mmr *MerkleMountainRange) Root() common.Hash <span class="cov0" title="0">{
        if len(mmr.peaks) == 0 </span><span class="cov0" title="0">{
                return common.BytesToHash([]byte{})
        }</span>
        <span class="cov0" title="0">combined := mmr.peaks[0].Hash
        for i := 1; i &lt; len(mmr.peaks); i++ </span><span class="cov0" title="0">{
                combined = append(combined, mmr.peaks[i].Hash...)
        }</span>
        <span class="cov0" title="0">fmt.Printf("Compute Root Hash(%x): %x\n", combined, computeHash(combined, mmr.hashType))
        return common.BytesToHash(computeHash(combined, mmr.hashType))</span>
}

// Get returns the value of the leaf at the given index
func (mmr *MerkleMountainRange) Get(index int) ([]byte, error) <span class="cov0" title="0">{
        if index &lt; 0 </span><span class="cov0" title="0">{
                return nil, errors.New("index out of range")
        }</span>

        <span class="cov0" title="0">currentIndex := 0
        for _, peak := range mmr.peaks </span><span class="cov0" title="0">{
                value, err := getLeafAtIndex(peak, index, &amp;currentIndex)
                if err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("index out of range")</span>
}

func getLeafAtIndex(node *MMRNode, targetIndex int, currentIndex *int) ([]byte, error) <span class="cov0" title="0">{
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                if *currentIndex == targetIndex </span><span class="cov0" title="0">{
                        return node.Value, nil
                }</span>
                <span class="cov0" title="0">*currentIndex++
                return nil, errors.New("index not found")</span>
        }

        <span class="cov0" title="0">if node.Left != nil </span><span class="cov0" title="0">{
                value, err := getLeafAtIndex(node.Left, targetIndex, currentIndex)
                if err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        <span class="cov0" title="0">if node.Right != nil </span><span class="cov0" title="0">{
                value, err := getLeafAtIndex(node.Right, targetIndex, currentIndex)
                if err == nil </span><span class="cov0" title="0">{
                        return value, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, errors.New("index not found")</span>
}

// PrintTree prints the structure of the MMR
func (mmr *MerkleMountainRange) PrintTree() <span class="cov0" title="0">{
        fmt.Println("Merkle Mountain Range Structure:")
        for i, peak := range mmr.peaks </span><span class="cov0" title="0">{
                fmt.Printf("Peak %d (Hash: %s, Size: %d):\n", i, common.Bytes2Hex(peak.Hash), mmr.nodeSize(peak))
                mmr.printNode(peak, "  ")
        }</span>
}

func (mmr *MerkleMountainRange) printNode(node *MMRNode, indent string) <span class="cov0" title="0">{
        if node.Left != nil &amp;&amp; node.Right != nil </span><span class="cov0" title="0">{
                fmt.Printf("%sBranch Node: %s\n", indent, common.Bytes2Hex(node.Hash))
                fmt.Printf("%sLeft:\n", indent)
                mmr.printNode(node.Left, indent+"  ")
                fmt.Printf("%sRight:\n", indent)
                mmr.printNode(node.Right, indent+"  ")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%sLeaf Node: %s\n", indent, common.Bytes2Hex(node.Hash))
        }</span>
}

// nodeSize calculates the size of a given node
func (mmr *MerkleMountainRange) nodeSize(node *MMRNode) int <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return mmr.nodeSize(node.Left) + mmr.nodeSize(node.Right)</span>
}

// MerkleProof represents the proof needed to verify an entry in the MMR
type MerkleProof struct {
        LeafHash        []byte
        RootHash        []byte
        PeakHashes      [][]byte
        SiblingHashes   [][]byte
        SiblingPosition []string
}

// Trace generates a Merkle proof for the given value
func (mmr *MerkleMountainRange) Trace(value []byte) *MerkleProof <span class="cov0" title="0">{
        // leafHash := computeHash(value)
        leafHash := value
        var siblingHashes [][]byte
        var siblingPositions []string

        for _, peak := range mmr.peaks </span><span class="cov0" title="0">{
                if tracePath, pos := traceNode(peak, leafHash); tracePath != nil </span><span class="cov0" title="0">{
                        siblingHashes = append(siblingHashes, tracePath...)
                        siblingPositions = append(siblingPositions, pos...)
                        break</span>
                }
        }

        <span class="cov0" title="0">var peakHashes [][]byte
        for _, peak := range mmr.peaks </span><span class="cov0" title="0">{
                peakHashes = append(peakHashes, peak.Hash)
        }</span>

        <span class="cov0" title="0">return &amp;MerkleProof{
                LeafHash:        leafHash,
                RootHash:        mmr.Root().Bytes(),
                PeakHashes:      peakHashes,
                SiblingHashes:   siblingHashes,
                SiblingPosition: siblingPositions,
        }</span>
}

func traceNode(node *MMRNode, hash []byte) ([][]byte, []string) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">if bytes.Equal(node.Hash, hash) </span><span class="cov0" title="0">{
                return [][]byte{}, []string{}
        }</span>
        <span class="cov0" title="0">if node.Left != nil </span><span class="cov0" title="0">{
                leftPath, leftPos := traceNode(node.Left, hash)
                if leftPath != nil </span><span class="cov0" title="0">{
                        return append(leftPath, node.Right.Hash), append(leftPos, "right")
                }</span>
        }
        <span class="cov0" title="0">if node.Right != nil </span><span class="cov0" title="0">{
                rightPath, rightPos := traceNode(node.Right, hash)
                if rightPath != nil </span><span class="cov0" title="0">{
                        return append(rightPath, node.Left.Hash), append(rightPos, "left")
                }</span>
        }
        <span class="cov0" title="0">return nil, nil</span>
}

// Verify verifies the given value against the provided Merkle proof
func (mmr *MerkleMountainRange) Verify(value []byte, proof *MerkleProof) bool <span class="cov0" title="0">{
        // hash := computeHash(value)
        hash := value
        for i, siblingHash := range proof.SiblingHashes </span><span class="cov0" title="0">{
                if proof.SiblingPosition[i] == "left" </span><span class="cov0" title="0">{
                        fmt.Printf("Compute Hash(%x, %x): %x\n", siblingHash, hash, computeHash(append(siblingHash, hash...), mmr.hashType))
                        hash = computeHash(append(siblingHash, hash...), mmr.hashType)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("Compute Hash(%x, %x): %x\n", hash, siblingHash, computeHash(append(hash, siblingHash...), mmr.hashType))
                        hash = computeHash(append(hash, siblingHash...), mmr.hashType)
                }</span>
        }

        <span class="cov0" title="0">var combined []byte
        for _, peakHash := range proof.PeakHashes </span><span class="cov0" title="0">{
                if bytes.Equal(peakHash, proof.LeafHash) </span><span class="cov0" title="0">{
                        combined = append(combined, hash...)
                }</span> else<span class="cov0" title="0"> {
                        combined = append(combined, peakHash...)
                }</span>
        }
        <span class="cov0" title="0">fmt.Printf("Compute finalHash(%x): %x\n", combined, computeHash(combined, mmr.hashType))
        finalHash := computeHash(combined, mmr.hashType)
        return bytes.Equal(finalHash, proof.RootHash)</span>
}

// isPowerOfTwo checks if a number is a power of two
func isPowerOfTwo(x int) bool <span class="cov0" title="0">{
        return (x &amp; (x - 1)) == 0
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package trie

import (
        "errors"
        "fmt"
        "math"
        "strings"

        "github.com/colorfulnotion/jam/common"
        "github.com/colorfulnotion/jam/types"
)

// WBTNode represents a node in the WBT
type WBTNode struct {
        Hash  []byte
        Value []byte
        Left  *WBTNode
        Right *WBTNode
}

// WellBalancedTree represents the WBT structure
type WellBalancedTree struct {
        root     *WBTNode
        leaves   []*WBTNode
        hashType string
}

// buildWellBalancedTree constructs a well-balanced binary tree from the given leaves
func (wbt *WellBalancedTree) buildWellBalancedTree() <span class="cov8" title="1">{
        if len(wbt.leaves) == 0 </span><span class="cov0" title="0">{
                // If no leaves, return hash of 0
                wbt.root = &amp;WBTNode{Hash: computeHash([]byte{0}, wbt.hashType)}
                return
        }</span>
        <span class="cov8" title="1">wbt.root = buildTreeRecursive(wbt.leaves, wbt.hashType)</span>
}

func (tree *WellBalancedTree) Root() []byte <span class="cov8" title="1">{
        return tree.root.Hash
}</span>

func (tree *WellBalancedTree) RootHash() common.Hash <span class="cov8" title="1">{
        return common.Hash(tree.root.Hash)
}</span>

// buildTreeRecursive recursively constructs the tree and returns the root node
func buildTreeRecursive(nodes []*WBTNode, hashType string) *WBTNode <span class="cov8" title="1">{
        if len(nodes) == 1 </span><span class="cov8" title="1">{
                return nodes[0]
        }</span>

        <span class="cov8" title="1">mid := int(math.Round(float64(len(nodes)) / 2))
        left := buildTreeRecursive(nodes[:mid], hashType)
        right := buildTreeRecursive(nodes[mid:], hashType)

        combinedValue := append(left.Hash, right.Hash...)
        hash := computeNode(combinedValue, hashType)

        return &amp;WBTNode{
                Hash:  hash,
                Left:  left,
                Right: right,
        }</span>
}

// NewWellBalancedTree creates a new well-balanced tree with the given values
func NewWellBalancedTree(values [][]byte, hashTypes ...string) *WellBalancedTree <span class="cov8" title="1">{
        leaves := make([]*WBTNode, len(values))
        hashType := types.Blake2b
        if len(hashTypes) &gt; 0 &amp;&amp; hashTypes[0] == types.Keccak </span><span class="cov8" title="1">{
                hashType = types.Keccak
        }</span>
        <span class="cov8" title="1">for i, value := range values </span><span class="cov8" title="1">{
                leaves[i] = &amp;WBTNode{
                        Hash:  computeLeaf(value, hashType),
                        Value: value,
                }
        }</span>
        <span class="cov8" title="1">wbt := &amp;WellBalancedTree{leaves: leaves, hashType: hashType}
        wbt.buildWellBalancedTree()
        return wbt</span>
}

// Get returns the value of the leaf at the given index
func (tree *WellBalancedTree) Get(index int) ([]byte, error) <span class="cov8" title="1">{
        if index &lt; 0 || index &gt;= len(tree.leaves) </span><span class="cov8" title="1">{
                return nil, errors.New("index out of leaf range")
        }</span>
        <span class="cov8" title="1">return tree.leaves[index].Value, nil</span>
}

// PrintTree prints the tree structure for debugging
func (tree *WellBalancedTree) PrintTree() <span class="cov0" title="0">{
        printNode(tree.root, 0, "Root")
}</span>

func printNode(node *WBTNode, level int, pos string) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">prefix := strings.Repeat("  ", level)
        if node.Left == nil &amp;&amp; node.Right == nil </span><span class="cov0" title="0">{
                fmt.Printf("%s[Leaf %s]: %s\n", prefix, pos, common.Bytes2Hex(node.Hash))
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("%s[Branch %s]: %s\n", prefix, pos, common.Bytes2Hex(node.Hash))
        }</span>
        <span class="cov0" title="0">printNode(node.Left, level+1, "Left")
        printNode(node.Right, level+1, "Right")</span>
}

// Trace returns the proof path for a given value
func (tree *WellBalancedTree) Trace(index int) (int, common.Hash, []common.Hash, bool, error) <span class="cov8" title="1">{
        treeLen, leafHash, path, isFound, err := tree.trace(index)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Get proof path error: %v\n", err)
                return treeLen, common.Hash{}, nil, false, err
        }</span>
        <span class="cov8" title="1">return treeLen, leafHash, path, isFound, nil</span>
}

func (tree *WellBalancedTree) trace(index int) (int, common.Hash, []common.Hash, bool, error) <span class="cov8" title="1">{
        treeLen := len(tree.leaves)
        if index &lt; 0 || index &gt;= len(tree.leaves) </span><span class="cov0" title="0">{
                return treeLen, common.Hash{}, nil, false, errors.New("index out of leaf range")
        }</span>

        <span class="cov8" title="1">tracePath := make([]common.Hash, 0)
        currentNode := tree.leaves[index]
        leafHash := common.Hash(computeLeaf(currentNode.Value, tree.hashType))
        for currentNode != tree.root </span><span class="cov8" title="1">{
                parent := findWBTParent(tree.root, currentNode) // Find parent node
                sibling := findWBTSibling(parent, currentNode)  // Find sibling node

                if sibling != nil </span><span class="cov8" title="1">{
                        tracePath = append(tracePath, common.BytesToHash(sibling.Hash)) // Add sibling hash
                }</span> else<span class="cov0" title="0"> {
                        tracePath = append(tracePath, BytesToHash(make([]byte, 32))) // If sibling is nil, add empty hash
                }</span>
                <span class="cov8" title="1">currentNode = parent</span>
        }
        <span class="cov8" title="1">return treeLen, leafHash, tracePath, true, nil</span>
}

func VerifyWBT(treeLen int, index int, erasureRoot common.Hash, leafHash common.Hash, tracePath []common.Hash, hashTypes ...string) (common.Hash, bool, error) <span class="cov8" title="1">{
        hashType := types.Blake2b
        if len(hashTypes) != 0 &amp;&amp; hashTypes[0] == types.Keccak </span><span class="cov0" title="0">{
                hashType = types.Keccak
        }</span>
        <span class="cov8" title="1">if index &lt; 0 || index &gt;= treeLen </span><span class="cov0" title="0">{
                return common.Hash{}, false, errors.New("index out of range")
        }</span>
        <span class="cov8" title="1">start, end := 0, treeLen-1
        currentHash := leafHash

        // Compute the direction of the path
        direction := computeDirection(index, start, end, tracePath)
        direction = reverse(direction)
        //fmt.Printf("Index :%d, Direction: %v\n", index, direction)

        // Compute the root hash
        for i, dir := range direction </span><span class="cov8" title="1">{
                siblingHash := tracePath[i]

                if dir == 0 </span><span class="cov8" title="1">{
                        currentHash = common.BytesToHash(computeNode(append(currentHash[:], siblingHash[:]...), hashType))
                }</span> else<span class="cov8" title="1"> {
                        currentHash = common.BytesToHash(computeNode(append(siblingHash[:], currentHash[:]...), hashType))
                }</span>
        }
        <span class="cov8" title="1">isValid := erasureRoot.String() == currentHash.String()

        return currentHash, isValid, nil</span>
}

func computeDirection(index, start, end int, tracePath []common.Hash) []int <span class="cov8" title="1">{
        direction := []int{}
        for i := 0; i &lt; len(tracePath); i++ </span><span class="cov8" title="1">{
                mid := (start + end) / 2

                if index &lt;= mid </span><span class="cov8" title="1">{
                        end = mid
                        direction = append(direction, 0)
                }</span> else<span class="cov8" title="1"> {
                        start = mid + 1
                        direction = append(direction, 1)
                }</span>
        }
        <span class="cov8" title="1">return direction</span>
}

func reverse(direction []int) []int <span class="cov8" title="1">{
        for i := 0; i &lt; len(direction)/2; i++ </span><span class="cov8" title="1">{
                j := len(direction) - i - 1
                direction[i], direction[j] = direction[j], direction[i]
        }</span>
        <span class="cov8" title="1">return direction</span>
}

// findParent finds the parent of the given node
func findWBTParent(root, node *WBTNode) *WBTNode <span class="cov8" title="1">{
        if root == nil || root == node </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if root.Left == node || root.Right == node </span><span class="cov8" title="1">{
                return root
        }</span>

        <span class="cov8" title="1">if leftParent := findWBTParent(root.Left, node); leftParent != nil </span><span class="cov8" title="1">{
                return leftParent
        }</span>
        <span class="cov8" title="1">return findWBTParent(root.Right, node)</span>
}

func findWBTSibling(parent, node *WBTNode) *WBTNode <span class="cov8" title="1">{
        if parent == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if parent.Left == node </span><span class="cov8" title="1">{
                return parent.Right
        }</span>
        <span class="cov8" title="1">return parent.Left</span>
}

func ComputeExpectedWBTCopathSize(numLeaves int) int <span class="cov0" title="0">{
        if numLeaves &lt;= 1 </span><span class="cov0" title="0">{
                // If there's only one leaf, the co-path size is 0 (no siblings).
                return 0
        }</span>

        // Calculate the number of levels in the tree (log2 of the number of leaves, rounded up)
        <span class="cov0" title="0">return int(math.Ceil(math.Log2(float64(numLeaves))))</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package types

import (
        "fmt"

        "github.com/colorfulnotion/jam/common"
)

type AccumulationQueue struct {
        WorkReports     []WorkReport  `json:"work_reports"`
        WorkPackageHash []common.Hash `json:"work_package_hash"`
}

type AccumulationHistory struct {
        WorkPackageHash []common.Hash `json:"work_package_hash"`
}

// Types for Kai
type Kai_state struct {
        Kai_m uint32            `json:"chi_m"` // The index of the bless service
        Kai_a uint32            `json:"chi_a"` // The index of the designate service
        Kai_v uint32            `json:"chi_v"` // The index of the assign service
        Kai_g map[uint32]uint32 `json:"chi_g"` // g is a small dictionary containing the indices of services which automatically accumulate in each block together with a basic amount of gas with which each accumulates
}

// fixed size for the authorization queue
type AuthorizationQueue [TotalCores][MaxAuthorizationQueueItems]common.Hash

// U: The set of partial state, used during accumulation. See equation 170.
type PartialState struct {
        D                  map[uint32]*ServiceAccount `json:"D"`
        UpcomingValidators Validators                 `json:"upcoming_validators"`
        QueueWorkReport    AuthorizationQueue         `json:"authorizations_pool"`
        PrivilegedState    Kai_state                  `json:"privileged_state"`
}

func (U PartialState) Dump(prefix string, id uint16) <span class="cov0" title="0">{
        fmt.Printf("[N%d] Partial State Dump -- %s\n", id, prefix)
        for serviceIndex, serviceAccount := range U.D </span><span class="cov0" title="0">{
                fmt.Printf("[N%d] Service %d =&gt; Dirty %v %s\n", id, serviceIndex, serviceAccount.Dirty, serviceAccount.String())
        }</span>
        <span class="cov0" title="0">fmt.Printf("[N%d]\n\n", id)</span>
}

/*
   func (U *PartialState) Clone() (V *PartialState) {
        V = &amp;PartialState{
                D: make(map[uint32]*ServiceAccount),
        }
        for serviceIndex, serviceAccount := range U.D {
                V.D[serviceIndex] = serviceAccount.Clone()
        }
        newV := U.UpcomingValidators
        V.UpcomingValidators = newV
        tmpPrivilegedState := U.PrivilegedState
        V.PrivilegedState = tmpPrivilegedState
        return V
}
*/

type XContext struct {
        D map[uint32]*ServiceAccount `json:"D"`
        I uint32                     `json:"I"`
        S uint32                     `json:"S"`
        U *PartialState              `json:"U"`
        T []DeferredTransfer         `json:"T"`
}

// returns back X.U.D[s] where s is the current service index
func (X *XContext) GetX_s() (xs *ServiceAccount, s uint32) <span class="cov0" title="0">{
        // This is Mutable
        return X.U.D[X.S], X.S
}</span>
func (X *XContext) Clone() (Y XContext) <span class="cov0" title="0">{
        Y = XContext{
                D: make(map[uint32]*ServiceAccount),
                I: X.I,
                S: X.S,
                T: make([]DeferredTransfer, len(X.T)),
        }
        for serviceIndex, service := range X.D </span><span class="cov0" title="0">{
                Y.D[serviceIndex] = service.Clone()
        }</span>
        <span class="cov0" title="0">for i, t := range X.T </span><span class="cov0" title="0">{
                Y.T[i] = t.Clone()
        }</span>
        <span class="cov0" title="0">return</span>
}

// T: The set of deferred transfers.
type DeferredTransfer struct {
        SenderIndex   uint32    `json:"sender_index"`
        ReceiverIndex uint32    `json:"receiver_index"`
        Amount        uint64    `json:"amount"`
        Memo          [128]byte `json:"memo"`
        GasLimit      uint64    `json:"gas_limit"`
}

func (d DeferredTransfer) Clone() DeferredTransfer <span class="cov0" title="0">{
        return DeferredTransfer{
                SenderIndex:   d.SenderIndex,
                ReceiverIndex: d.ReceiverIndex,
                Amount:        d.Amount,
                Memo:          d.Memo, // Arrays are copied by value in Go, so this will be a deep copy
                GasLimit:      d.GasLimit,
        }
}</span>

// wrangled operand tuples,
// 175
// O: The accumulation operand element, corresponding to a single work result.
type AccumulateOperandElements struct {
        Results         Result      `json:"results"` //o
        Payload         common.Hash `json:"lookup"`  //l
        WorkPackageHash common.Hash `json:"k"`       //k
        AuthOutput      []byte      `json:"a"`       //a
}

func (a *DeferredTransfer) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package types

import (
        "crypto/ed25519"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

// TrancheAnnouncement should probably just be [trancheIdx]AnnounceBucket
// given [trancheIdx], get your currAnnouncementBucket and PrevAnnouncementBucket
type TrancheAnnouncement struct {
        AnnouncementBucket map[uint32]AnnounceBucket
}

func (T *TrancheAnnouncement) PutAnnouncement(a Announcement) error <span class="cov0" title="0">{
        if T.AnnouncementBucket == nil </span><span class="cov0" title="0">{
                T.AnnouncementBucket = make(map[uint32]AnnounceBucket)
        }</span>
        <span class="cov0" title="0">bucket := T.AnnouncementBucket[a.Tranche]
        bucket.PutAnnouncement(a)
        T.AnnouncementBucket[a.Tranche] = bucket
        return nil</span>
}

// Announcement  Section 17.3 Equations (196)-(199) TBD
type Announcement struct {
        HeaderHash          common.Hash          `json:"header_hash"`
        Tranche             uint32               `json:"tranche"`
        Selected_WorkReport []AnnouncementReport `json:"selected_work_report"`
        Signature           Ed25519Signature     `json:"signature"`
        ValidatorIndex      uint32               `json:"validator_index"`
}
type AnnouncementReport struct {
        Core           uint16      `json:"core"`
        WorkReportHash common.Hash `json:"work_report_hash"`
}

func (a *Announcement) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return enc</span>
}

func (a *Announcement) Hash() common.Hash <span class="cov0" title="0">{
        data := a.Bytes()
        return common.Blake2Hash(data)
}</span>

// computeAnnouncementBytes abstracts the process of generating the bytes to be signed or verified.
func (a *Announcement) UnsignedBytes() []byte <span class="cov0" title="0">{
        // eq 214
        var signtext_n []byte
        for _, w := range a.Selected_WorkReport </span><span class="cov0" title="0">{
                c, _ := Encode(w.Core)
                signtext_n = append(signtext_n, c...)
                signtext_n = append(signtext_n, w.WorkReportHash.Bytes()...)
        }</span>
        <span class="cov0" title="0">signtext, _ := Encode(a.Tranche)
        signtext = append(signtext, signtext_n...)
        signtext = append(signtext, a.HeaderHash.Bytes()...)
        return signtext</span>
}

func (a *Announcement) UnsignedBytesWithSalt() []byte <span class="cov0" title="0">{
        signtext := a.UnsignedBytes()
        return append([]byte(X_I), signtext...)
}</span>
func (a *Announcement) Sign(Ed25519Secret []byte) <span class="cov0" title="0">{
        signtext := a.UnsignedBytesWithSalt()
        a.Signature = Ed25519Signature(ed25519.Sign(Ed25519Secret, signtext))
}</span>

func (a *Announcement) Verify(key Ed25519Key) error <span class="cov0" title="0">{
        announcementBytes := a.UnsignedBytesWithSalt()

        if !ed25519.Verify(key.PublicKey(), announcementBytes, a.Signature.Bytes()) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature by signature %v", a.Signature)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a *Announcement) GetWorkReportHashes() []common.Hash <span class="cov0" title="0">{
        report_hashes := make([]common.Hash, len(a.Selected_WorkReport))
        for idx, report := range a.Selected_WorkReport </span><span class="cov0" title="0">{
                report_hashes[idx] = report.WorkReportHash
        }</span>
        <span class="cov0" title="0">return report_hashes</span>
}

// func (a *Announcement) Bytes() []byte {
//         enc := Encode(a)
//         return enc
// }

// func (a *Announcement) Hash() common.Hash {
//         data := a.Bytes()
//         if data == nil {
//                 return common.Hash{}
//         }
//         return common.Blake2Hash(data)
// }

// eq 198
type AnnounceBucket struct {
        Tranche            uint32                         //?
        Announcements      map[common.Hash][]Announcement `json:"reports"`
        KnownAnnouncements map[common.Hash]bool           // use identifier to filter duplicate A
}

func (W *AnnounceBucket) GetLen(w common.Hash) int <span class="cov0" title="0">{
        return len(W.Announcements[w])
}</span>

func (W *AnnounceBucket) PutAnnouncement(a Announcement) <span class="cov0" title="0">{
        if W.Announcements == nil </span><span class="cov0" title="0">{
                W.Announcements = make(map[common.Hash][]Announcement)
        }</span>
        <span class="cov0" title="0">if W.KnownAnnouncements == nil </span><span class="cov0" title="0">{
                W.KnownAnnouncements = make(map[common.Hash]bool)
        }</span>
        <span class="cov0" title="0">if W.KnownAnnouncements[a.Hash()] </span><span class="cov0" title="0">{
                return
        }</span>
        // W.Announcements[a.WorkReportHash] = append(W.Announcements[a.WorkReportHash], a)
        <span class="cov0" title="0">for _, w := range a.Selected_WorkReport </span><span class="cov0" title="0">{
                W.Announcements[w.WorkReportHash] = append(W.Announcements[w.WorkReportHash], a)
        }</span>
        <span class="cov0" title="0">W.KnownAnnouncements[a.Hash()] = true</span>
}

func (W *AnnounceBucket) HaveMadeAnnouncement(a Announcement) bool <span class="cov0" title="0">{
        if W.KnownAnnouncements == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return W.KnownAnnouncements[a.Hash()]</span>
}

// Deep copy of AnnounceBucket
func (W *AnnounceBucket) DeepCopy() (AnnounceBucket, error) <span class="cov0" title="0">{
        var copiedAnnounceBucket AnnounceBucket

        // Serialize the original AnnounceBucket to JSON
        data, err := Encode(W)
        if err != nil </span><span class="cov0" title="0">{
                return copiedAnnounceBucket, err
        }</span>

        // Deserialize the JSON back into a new AnnounceBucket instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(AnnounceBucket{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedAnnounceBucket, err
        }</span>
        <span class="cov0" title="0">copiedAnnounceBucket = decoded.(AnnounceBucket)

        return copiedAnnounceBucket, nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package types

import (
        "crypto/ed25519"
        "encoding/json"
        "errors"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

/*
11.2.1. The Assurances Extrinsic. ${\bf E}_A$  The assurances extrinsic is a *sequence* of assurance values, at most one per validator. Each assurance:
* is a sequence of binary values (i.e. a bitstring), one per core, together with
* a signature and
* the index of the validator who is assuring

A value of 1 (or ⊺, if interpreted as a Boolean) at any given index implies that the validator assures they are contributing to its availability.  See equations 123-128.

`Assurance` ${\bf E}_A$:
*/
//Validators, in their role as availability assurers, should index such chunks according to the index of the segmentstree whose reconstruction they facilitate.
// Since the data for segment chunks is so small at 12 bytes, fixed communications costs should be kept to a bare minimum.
// A good network protocol (out of scope at present) will allow guarantors to specify only the segments-tree root and index together with a Boolean
// to indicate whether the proof chunk need be supplied.

// Assurance represents an assurance value.
type Assurance struct {
        // H_p - see Eq 124
        Anchor common.Hash `json:"anchor"`
        // f - 1 means "available"
        Bitfield       [Avail_bitfield_bytes]byte `json:"bitfield"`
        ValidatorIndex uint16                     `json:"validator_index"`
        Signature      Ed25519Signature           `json:"signature"`
}

func (a *Assurance) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (a *Assurance) Hash() common.Hash <span class="cov0" title="0">{
        data := a.Bytes()
        return common.Blake2Hash(data)
}</span>

func (A *Assurance) BitFieldToBytes() []byte <span class="cov0" title="0">{
        return A.Bitfield[:]
}</span>

func (A *Assurance) ValidBitfield(HadRho []bool) bool <span class="cov0" title="0">{
        for i, rho := range HadRho </span><span class="cov0" title="0">{
                if A.GetBitFieldBit(uint16(i)) &amp;&amp; !rho </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (A *Assurance) CheckTimeout(IsRhoTimeOut []bool) bool <span class="cov0" title="0">{
        for i, timeout := range IsRhoTimeOut </span><span class="cov0" title="0">{
                if A.GetBitFieldBit(uint16(i)) &amp;&amp; timeout </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

func (A *Assurance) SetBitFieldBit(index uint16, value bool) <span class="cov0" title="0">{
        byteIndex := index / 8   // Determine which byte in the array the bit is in
        bitPosition := index % 8 // Determine the position within the byte

        if value </span><span class="cov0" title="0">{
                A.Bitfield[byteIndex] |= 1 &lt;&lt; bitPosition
        }</span> else<span class="cov0" title="0"> {
                A.Bitfield[byteIndex] &amp;= ^(1 &lt;&lt; bitPosition)
        }</span>
}

func (A *Assurance) GetBitFieldBit(index uint16) bool <span class="cov0" title="0">{
        byteIndex := index / 8   // Determine which byte in the array the bit is in
        bitPosition := index % 8 // Determine the position within the byte

        return (A.Bitfield[byteIndex] &amp; (1 &lt;&lt; bitPosition)) != 0
}</span>

func (a *Assurance) UnsignedBytes() []byte <span class="cov0" title="0">{
        signtext := common.ComputeHash(append(a.Anchor.Bytes(), a.Bitfield[0])) // this bitfield is a byte, TODO: check if this is correct
        return signtext
}</span>

// computeAssuranceBytes abstracts the process of generating the bytes to be signed or verified.
func (a *Assurance) UnsignedBytesWithSalt() []byte <span class="cov0" title="0">{
        signtext := a.UnsignedBytes()
        return append([]byte(X_A), signtext...)
}</span>

func (a *Assurance) Sign(Ed25519Secret []byte) <span class="cov0" title="0">{
        assuranceBytes := a.UnsignedBytesWithSalt()
        sig := ed25519.Sign(Ed25519Secret, assuranceBytes)
        copy(a.Signature[:], sig)
}</span>

func (a *Assurance) Verify(validator Validator) error <span class="cov0" title="0">{
        if len(a.Signature) == 0 </span><span class="cov0" title="0">{
                return errors.New("signature is empty")
        }</span>
        <span class="cov0" title="0">signtext := a.UnsignedBytesWithSalt()
        //verify the signature
        if !Ed25519Verify(Ed25519Key(validator.Ed25519), signtext, a.Signature) </span><span class="cov0" title="0">{
                return errors.New("invalid signature")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (a Assurance) DeepCopy() (Assurance, error) <span class="cov0" title="0">{
        var copiedAssurance Assurance

        // Serialize the original Assurance to JSON
        data, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return copiedAssurance, err
        }</span>

        // Deserialize the JSON back into a new Assurance instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Assurance{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedAssurance, err
        }</span>
        <span class="cov0" title="0">copiedAssurance = decoded.(Assurance)

        return copiedAssurance, nil</span>
}

// Bytes returns the bytes of the Assurance
// func (a *Assurance) Bytes() []byte {
//         enc := Encode(a)
//         return enc
// }

// func (a *Assurance) Hash() common.Hash {
//         data := a.Bytes()
//         if data == nil {
//                 // Handle the error case
//                 return common.Hash{}
//         }
//         return common.Blake2Hash(data)
// }

func (a *Assurance) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Anchor         common.Hash `json:"anchor"`
                Bitfield       string      `json:"bitfield"`
                ValidatorIndex uint16      `json:"validator_index"`
                Signature      string      `json:"signature"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Convert Bitstring from hex string to []byte
        <span class="cov8" title="1">bitfieldBytes := common.FromHex(s.Bitfield)
        // Convert Signature from hex string to Ed25519Signature
        signatureBytes := common.FromHex(s.Signature)
        var bitfield [Avail_bitfield_bytes]byte
        copy(bitfield[:], bitfieldBytes)

        var signature Ed25519Signature
        copy(signature[:], signatureBytes)

        // Return the converted Assurance struct
        a.Anchor = s.Anchor
        a.Bitfield = bitfield
        a.ValidatorIndex = s.ValidatorIndex
        a.Signature = signature

        return nil</span>
}

func (a Assurance) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Convert Bitfield from []byte to hex string
        bitfield := common.HexString(a.Bitfield[:])
        // Convert Signature from Ed25519Signature to hex string
        signature := common.HexString(a.Signature[:])

        // Create a struct to hold the converted Assurance struct
        s := struct {
                Anchor         common.Hash `json:"anchor"`
                Bitfield       string      `json:"bitfield"`
                ValidatorIndex uint16      `json:"validator_index"`
                Signature      string      `json:"signature"`
        }{
                Anchor:         a.Anchor,
                Bitfield:       bitfield,
                ValidatorIndex: a.ValidatorIndex,
                Signature:      signature,
        }

        // Marshal the struct to JSON
        return json.Marshal(&amp;s)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package types

import (
        "encoding/json"
        //"errors"
        "fmt"
        //"reflect"

        "github.com/colorfulnotion/jam/common"
)

type BandersnatchKey common.Hash
type BandersnatchVrfSignature [IETFSignatureLen]byte
type BandersnatchRingSignature [ExtrinsicSignatureInBytes]byte

func (b BandersnatchKey) Hash() common.Hash <span class="cov0" title="0">{
        return common.Hash(b)
}</span>

func HexToBandersnatchKey(hexStr string) BandersnatchKey <span class="cov0" title="0">{
        b := common.Hex2Bytes(hexStr)
        var pubkey BandersnatchKey
        copy(pubkey[:], b)
        return pubkey
}</span>

func (k BandersnatchKey) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(common.Hash(k).Hex())
}</span>

func (k *BandersnatchKey) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var hexStr string
        if err := json.Unmarshal(data, &amp;hexStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*k = BandersnatchKey(common.HexToHash(hexStr))
        return nil</span>
}

func (s BandersnatchVrfSignature) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(common.Bytes2Hex(s[:]))
}</span>

func (s *BandersnatchVrfSignature) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var hexStr string
        if err := json.Unmarshal(data, &amp;hexStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">bytes := common.FromHex(hexStr)
        if len(bytes) != len(s) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid length for BandersnatchVrfSignature: expected %d bytes, got %d bytes", len(s), len(bytes))
        }</span>
        <span class="cov0" title="0">copy(s[:], bytes)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

type Block struct {
        Header    BlockHeader   `json:"header"`
        Extrinsic ExtrinsicData `json:"extrinsic"`
}

type CBlock struct {
        Header    CBlockHeader  `json:"header"`
        Extrinsic ExtrinsicData `json:"extrinsic"`
}

func NewBlock() *Block <span class="cov0" title="0">{
        //var b Block
        b := &amp;Block{}
        return b
}</span>

// StateCopy returns a state copy that is necessary for generating the next block
func (b *Block) Copy() *Block <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">c := NewBlock()

        // Copy Header fields
        c.Header.ParentHeaderHash = b.Header.ParentHeaderHash
        c.Header.ParentStateRoot = b.Header.ParentStateRoot
        c.Header.ExtrinsicHash = b.Header.ExtrinsicHash
        c.Header.Slot = b.Header.Slot

        if b.Header.EpochMark != nil </span><span class="cov0" title="0">{
                epochMarkCopy := *b.Header.EpochMark
                c.Header.EpochMark = &amp;epochMarkCopy
        }</span>

        <span class="cov0" title="0">c.Header.TicketsMark = b.Header.TicketsMark

        // if b.Header.VerdictsMarkers != nil {
        //         judgementsMarkersCopy := *b.Header.VerdictsMarkers
        //         c.Header.VerdictsMarkers = &amp;judgementsMarkersCopy
        // }

        if b.Header.OffendersMark != nil </span><span class="cov0" title="0">{
                c.Header.OffendersMark = b.Header.OffendersMark
        }</span>

        <span class="cov0" title="0">c.Header.AuthorIndex = b.Header.AuthorIndex

        copy(c.Header.EntropySource[:], b.Header.EntropySource[:])

        copy(c.Header.Seal[:], b.Header.Seal[:])

        // Copy ExtrinsicData fields
        c.Extrinsic.Tickets = make([]Ticket, len(b.Extrinsic.Tickets))
        copy(c.Extrinsic.Tickets, b.Extrinsic.Tickets)

        c.Extrinsic.Preimages = make([]Preimages, len(b.Extrinsic.Preimages))
        copy(c.Extrinsic.Preimages, b.Extrinsic.Preimages)

        c.Extrinsic.Guarantees = make([]Guarantee, len(b.Extrinsic.Guarantees))
        copy(c.Extrinsic.Guarantees, b.Extrinsic.Guarantees)

        c.Extrinsic.Assurances = make([]Assurance, len(b.Extrinsic.Assurances))
        copy(c.Extrinsic.Assurances, b.Extrinsic.Assurances)

        c.Extrinsic.Disputes.Verdict = make([]Verdict, len(b.Extrinsic.Disputes.Verdict))
        copy(c.Extrinsic.Disputes.Verdict, b.Extrinsic.Disputes.Verdict)
        c.Extrinsic.Disputes.Culprit = make([]Culprit, len(b.Extrinsic.Disputes.Culprit))
        copy(c.Extrinsic.Disputes.Culprit, b.Extrinsic.Disputes.Culprit)
        c.Extrinsic.Disputes.Fault = make([]Fault, len(b.Extrinsic.Disputes.Fault))
        copy(c.Extrinsic.Disputes.Fault, b.Extrinsic.Disputes.Fault)

        return c</span>
}

/*func (b *Block) ConvertToSafroleHeader() SafroleHeader {
        return b.Header.ConvertToSafroleHeader()
} */

func (b *Block) GetHeader() BlockHeader <span class="cov0" title="0">{
        return b.Header
}</span>

func (b *Block) TimeSlot() uint32 <span class="cov0" title="0">{
        return b.GetHeader().Slot
}</span>

func (b *Block) EpochMark() *EpochMark <span class="cov0" title="0">{
        return b.GetHeader().EpochMark
}</span>

func BlockFromBytes(data []byte) (*Block, error) <span class="cov0" title="0">{
        var b Block
        decoded, _, err := Decode(data, reflect.TypeOf(Block{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b = decoded.(Block)
        return &amp;b, nil</span>
}

// Bytes returns the bytes of the block.
func (b *Block) Bytes() []byte <span class="cov0" title="0">{
        cb, err := b.toCBlock()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">enc, err := Encode(cb)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

// Hash returns the hash of the block.
func (b *Block) Hash() common.Hash <span class="cov0" title="0">{
        blockBytes := b.Bytes()
        if blockBytes == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(blockBytes)</span>
}

// ParentHash returns the headerhash of the parent.
func (b *Block) GetParentHeaderHash() common.Hash <span class="cov0" title="0">{
        return b.Header.ParentHeaderHash
}</span>

func (b *Block) Str() string <span class="cov0" title="0">{
        out := fmt.Sprintf("[N%d] ", b.Header.AuthorIndex)
        out += fmt.Sprintf("H_t=%d ", b.Header.Slot)
        out += fmt.Sprintf("H_r=%s ", common.Str(b.Header.ParentStateRoot))
        if b.Header.EpochMark != nil </span><span class="cov0" title="0">{
                out += b.Header.EpochMark.String()
        }</span>
        <span class="cov0" title="0">if len(b.Header.TicketsMark) &gt; 0 </span><span class="cov0" title="0">{
                out += fmt.Sprintf(" \033[32m WinningTickets\033[0m(%d)", len(b.Header.TicketsMark))
        }</span>
        <span class="cov0" title="0">if len(b.Extrinsic.Tickets) &gt; 0 </span><span class="cov0" title="0">{
                out += fmt.Sprintf(" \033[34m |E_T|=%d\033[0m", len(b.Extrinsic.Tickets))
        }</span>
        <span class="cov0" title="0">if len(b.Extrinsic.Guarantees) &gt; 0 </span><span class="cov0" title="0">{
                out += fmt.Sprintf(" \033[31m |E_G|=%d\033[0m", len(b.Extrinsic.Guarantees))
        }</span>
        /*if len(b.Extrinsic.Disputes) &gt; 0 {
                out += fmt.Sprintf(" \032[32m |E_D|=%d\033[0m %d", len(b.Extrinsic.Disputes))
        } */
        <span class="cov0" title="0">if len(b.Extrinsic.Preimages) &gt; 0 </span><span class="cov0" title="0">{
                out += fmt.Sprintf(" \033[31m |E_P|=%d\033[0m", len(b.Extrinsic.Preimages))
        }</span>
        <span class="cov0" title="0">if len(b.Extrinsic.Assurances) &gt; 0 </span><span class="cov0" title="0">{
                out += fmt.Sprintf(" \033[31m |E_A|=%d\033[0m", len(b.Extrinsic.Assurances))
        }</span>
        <span class="cov0" title="0">return out</span>
}

func (b *Block) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(b, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}

func (b *Block) Tickets() []Ticket <span class="cov0" title="0">{
        extrinsicData := b.Extrinsic
        return extrinsicData.Tickets
}</span>

func (b *Block) PreimageLookups() []Preimages <span class="cov0" title="0">{
        extrinsicData := b.Extrinsic
        return extrinsicData.Preimages
}</span>

func (b *Block) Guarantees() []Guarantee <span class="cov0" title="0">{
        extrinsicData := b.Extrinsic
        return extrinsicData.Guarantees
}</span>

func (b *Block) Assurances() []Assurance <span class="cov0" title="0">{
        extrinsicData := b.Extrinsic
        return extrinsicData.Assurances
}</span>

func (b *Block) Disputes() Dispute <span class="cov0" title="0">{
        extrinsicData := b.Extrinsic
        return extrinsicData.Disputes
}</span>

// type casting CBlock -&gt; Block
func (b *Block) fromCBlock(cb *CBlock) <span class="cov8" title="1">{
        if cb == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert CBlockHeader to BlockHeader
        <span class="cov8" title="1">b.Header.fromCBlockHeader(&amp;cb.Header)

        // Copy the Extrinsic field directly
        b.Extrinsic = cb.Extrinsic</span>
}

// type casting Block -&gt; CBlock
func (b *Block) toCBlock() (*CBlock, error) <span class="cov8" title="1">{
        // Convert BlockHeader to CBlockHeader
        cbh, err := b.Header.toCBlockHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Create the CBlock
        <span class="cov8" title="1">cb := &amp;CBlock{
                Header:    *cbh,
                Extrinsic: b.Extrinsic,
        }

        return cb, nil</span>
}

func (b Block) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Convert Block to CBlock
        cb, err := b.toCBlock()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Marshal CBlock to JSON
        <span class="cov8" title="1">return json.Marshal(cb)</span>
}

func (b *Block) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        // Unmarshal data into a CBlock
        var cb CBlock
        if err := json.Unmarshal(data, &amp;cb); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Convert CBlock to Block
        <span class="cov8" title="1">b.fromCBlock(&amp;cb)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "github.com/colorfulnotion/jam/common"
        "io"
)

type BlockAnnouncement struct {
        HeaderHash     common.Hash `json:"headerHash"`
        Timeslot       uint32      `json:"slot"`
        Header         BlockHeader `json:"header"`
        ValidatorIndex uint16      `json:"validator_index"`
}

// ToBytes for JAMSNPBlockAnnouncement
func (ann *BlockAnnouncement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // Serialize HeaderHash (32 bytes for common.Hash)
        if _, err := buf.Write(ann.HeaderHash[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Serialize Timeslot (4 bytes)
        <span class="cov0" title="0">if err := binary.Write(buf, binary.BigEndian, ann.Timeslot); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Serialize Header
        <span class="cov0" title="0">headerBytes, err := ann.Header.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if _, err := buf.Write(headerBytes); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// FromBytes for JAMSNPBlockAnnouncement
func (ann *BlockAnnouncement) FromBytes(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // Deserialize HeaderHash (32 bytes)
        if _, err := io.ReadFull(buf, ann.HeaderHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deserialize Timeslot (4 bytes)
        <span class="cov0" title="0">if err := binary.Read(buf, binary.BigEndian, &amp;ann.Timeslot); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deserialize Header
        <span class="cov0" title="0">headerBytes, err := ann.Header.Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := io.ReadFull(buf, headerBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "os"
        "reflect"
        "sort"
)

type CustomEncoder interface {
        Encode() []byte
}

type CustomDecoder interface {
        Decode(data []byte) (interface{}, uint32)
}

func powerOfTwo(exp uint32) uint64 <span class="cov8" title="1">{
        var result uint64 = 1
        for i := uint32(0); i &lt; exp; i++ </span><span class="cov8" title="1">{
                result *= 2
        }</span>
        <span class="cov8" title="1">return result</span>
}

// GP v0.3.6 eq(271)  E_l - Integer Encoding
func E_l(x uint64, l uint32) []byte <span class="cov8" title="1">{
        if l == 0 </span><span class="cov8" title="1">{
                return []byte{}
        }</span> else<span class="cov8" title="1"> {
                encoded := []byte{byte(x % 256)}
                encoded = append(encoded, E_l(x/256, l-1)...)
                return encoded
        }</span>
}

// GP v0.3.6 eq(271)  E_l - Integer Decoding
func DecodeE_l(encoded []byte) uint64 <span class="cov8" title="1">{
        var x uint64 = 0
        for i := len(encoded) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                x = x*256 + uint64(encoded[i])
        }</span>
        <span class="cov8" title="1">return x</span>
}

// GP v0.3.6 eq(272)  E - Integer Encoding: general natural number serialization up to 2^64
func E(x uint64) []byte <span class="cov8" title="1">{
        if x == 0 </span><span class="cov8" title="1">{
                return []byte{0}
        }</span>
        <span class="cov8" title="1">for l := uint32(0); l &lt; 8; l++ </span><span class="cov8" title="1">{
                if x &gt;= powerOfTwo(7*l) &amp;&amp; x &lt; powerOfTwo(7*(l+1)) </span><span class="cov8" title="1">{
                        encoded := []byte{byte(powerOfTwo(8) - powerOfTwo(8-l) + x/powerOfTwo(8*l))}
                        encoded = append(encoded, E_l(x%powerOfTwo(8*l), l)...)
                        return encoded
                }</span>
        }
        <span class="cov0" title="0">encoded := []byte{byte(powerOfTwo(8) - 1)}
        encoded = append(encoded, E_l(x, 8)...)
        return encoded</span>
}

// GP v0.3.6 eq(272) E - Integer Decoding: general natural number serialization up to 2^64
func DecodeE(encoded []byte) (uint64, uint32) <span class="cov8" title="1">{
        firstByte := encoded[0]
        if firstByte == 0 </span><span class="cov8" title="1">{
                return 0, 1
        }</span>
        <span class="cov8" title="1">if firstByte == 255 </span><span class="cov0" title="0">{
                return DecodeE_l(encoded[1:9]), 9
        }</span>
        <span class="cov8" title="1">var l uint32
        for l = 0; l &lt; 8; l++ </span><span class="cov8" title="1">{
                if firstByte &gt;= byte(256-powerOfTwo(8-l)) &amp;&amp; firstByte &lt; byte(256-powerOfTwo(8-(l+1))) </span><span class="cov8" title="1">{
                        x1 := uint64(firstByte) - uint64(256-powerOfTwo(8-l))
                        x2 := DecodeE_l(encoded[1 : 1+l])
                        x := x1*powerOfTwo(8*l) + x2
                        return x, l + 1
                }</span>
        }

        <span class="cov0" title="0">return 0, 0</span>
}

// GP v0.3.6 eq(274) ↕x≡(|x|,x) - Length Discriminator Encoding. Maybe Reuqired later [DO NOT DELETE]
func LengthE(x []uint64) []byte <span class="cov0" title="0">{
        encoded := E(uint64(len(x)))
        for i := 0; i &lt; len(x); i++ </span><span class="cov0" title="0">{
                encoded = append(encoded, E(x[i])...)
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

// GP v0.3.6 eq(274) ↕x≡(|x|,x) - Length Discriminator Decoding. Maybe Reuqired later [DO NOT DELETE]
func DecodeLengthE(encoded []byte) ([]uint64, uint32) <span class="cov0" title="0">{
        length, l := DecodeE([]byte{encoded[0]})
        var T []uint64
        for i := 0; i &lt; int(length); i++ </span><span class="cov0" title="0">{
                x, len := DecodeE(encoded[l:])
                T = append(T, x)
                l += len
        }</span>
        <span class="cov0" title="0">return T, l</span>
}

func CheckCustomEncode(data interface{}) (bool, []byte) <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                return false, []byte{}
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Println(r)
                }</span>
        }()

        <span class="cov8" title="1">if encoder, ok := data.(CustomEncoder); ok </span><span class="cov8" title="1">{
                return true, encoder.Encode()
        }</span>

        <span class="cov8" title="1">return false, []byte{}</span>
}

func CheckCustomDecode(data []byte, t reflect.Type) (bool, interface{}, uint32) <span class="cov8" title="1">{
        instance := reflect.New(t).Elem().Interface()

        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        fmt.Println(r)
                }</span>
        }()

        <span class="cov8" title="1">if decoder, ok := instance.(CustomDecoder); ok </span><span class="cov8" title="1">{
                decoded, length := decoder.Decode(data)
                return true, decoded, length
        }</span>

        <span class="cov8" title="1">return false, nil, 0</span>
}

func Encode(data interface{}) ([]byte, error) <span class="cov8" title="1">{
        // fmt.Printf("Encode type: %v\n", reflect.TypeOf(data))
        // fmt.Printf("Encode data: %v\n", data)
        v := reflect.ValueOf(data)
        customEncodeRequired, customEncoded := CheckCustomEncode(data)
        if customEncodeRequired </span><span class="cov8" title="1">{
                // fmt.Printf("\n\nCustom Encode\n\n\n")
                if len(customEncoded) == 0 </span><span class="cov0" title="0">{
                        return []byte{}, nil
                }</span>
                <span class="cov8" title="1">return customEncoded, nil</span>
        }

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                if v.Bool() </span><span class="cov8" title="1">{
                        return []byte{1}, nil
                }</span>
                <span class="cov8" title="1">return []byte{0}, nil</span>
        case reflect.Uint:<span class="cov0" title="0">
                return E(v.Uint()), nil</span>
        case reflect.Uint8:<span class="cov8" title="1">
                return E_l(uint64(v.Uint()), 1), nil</span>
        case reflect.Uint16:<span class="cov8" title="1">
                return E_l(uint64(v.Uint()), 2), nil</span>
        case reflect.Uint32:<span class="cov8" title="1">
                return E_l(uint64(v.Uint()), 4), nil</span>
        case reflect.Uint64:<span class="cov8" title="1">
                return E_l(uint64(v.Uint()), 8), nil</span>
        case reflect.String:<span class="cov0" title="0">
                uint64Slice := make([]uint64, 0)
                for _, c := range v.String() </span><span class="cov0" title="0">{
                        uint64Slice = append(uint64Slice, uint64(c))
                }</span>
                <span class="cov0" title="0">encoded := E(uint64(len(uint64Slice)))
                for i := 0; i &lt; len(uint64Slice); i++ </span><span class="cov0" title="0">{
                        encoded = append(encoded, E(uint64Slice[i])...)
                }</span>
                <span class="cov0" title="0">return encoded, nil</span>

        // GP v0.3.6 eq(273) Sequence Encoding
        case reflect.Array:<span class="cov8" title="1">
                var encoded []byte
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        // GP v0.3.6 eq(268)  "The serialization of an octet-sequence as itself"
                        if v.Index(i).Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                                encoded = append(encoded, []byte{byte(v.Index(i).Uint())}...)
                        }</span> else<span class="cov8" title="1"> {
                                encodedVi, err := Encode(v.Index(i).Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">encoded = append(encoded, encodedVi...)</span>
                        }
                }
                <span class="cov8" title="1">return encoded, nil</span>

        case reflect.Slice:<span class="cov8" title="1">
                // GP v0.3.6 eq(274) Length Discriminator Encoding
                encoded := E(uint64(v.Len()))
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        if v.Index(i).Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                                encoded = append(encoded, []byte{byte(v.Index(i).Uint())}...)
                        }</span> else<span class="cov8" title="1"> {
                                encodedVi, err := Encode(v.Index(i).Interface())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">encoded = append(encoded, encodedVi...)</span>
                        }
                }
                <span class="cov8" title="1">return encoded, nil</span>

        // GP v0.3.6 eq(269) Concatenation Rule
        case reflect.Struct:<span class="cov8" title="1">
                var encoded []byte
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                        encodedVi, err := Encode(v.Field(i).Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">encoded = append(encoded, encodedVi...)</span>
                }
                <span class="cov8" title="1">return encoded, nil</span>

        // GP v0.3.6 eq(270) Tuples Rule
        case reflect.Ptr:<span class="cov8" title="1">
                if v.IsNil() </span><span class="cov0" title="0">{
                        return []byte{0}, nil
                }</span>
                <span class="cov8" title="1">return Encode(v.Elem().Interface())</span>
        case reflect.Map:<span class="cov0" title="0">
                keys := v.MapKeys()
                if len(keys) == 0 </span><span class="cov0" title="0">{
                        return []byte{0}, nil
                }</span>

                <span class="cov0" title="0">sort.Slice(keys, func(i, j int) bool </span><span class="cov0" title="0">{
                        switch keys[i].Kind() </span>{
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                                return keys[i].Int() &lt; keys[j].Int()</span>
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                                return keys[i].Uint() &lt; keys[j].Uint()</span>
                        case reflect.String:<span class="cov0" title="0">
                                return keys[i].String() &lt; keys[j].String()</span>
                        default:<span class="cov0" title="0">
                                return fmt.Sprintf("%v", keys[i]) &lt; fmt.Sprintf("%v", keys[j])</span>
                        }
                })

                <span class="cov0" title="0">type kvPair struct {
                        Key   interface{}
                        Value interface{}
                }
                var sortedKVPairs []kvPair
                for _, key := range keys </span><span class="cov0" title="0">{
                        sortedKVPairs = append(sortedKVPairs, kvPair{
                                Key:   key.Interface(),
                                Value: v.MapIndex(key).Interface(),
                        })
                }</span>
                // fmt.Println("sortedKVPairs:", sortedKVPairs)
                <span class="cov0" title="0">return Encode(sortedKVPairs)</span>

        default:<span class="cov0" title="0">
                return []byte{}, fmt.Errorf("unsupported type: %s", v.Kind().String())</span>
        }
}

func Decode(data []byte, t reflect.Type) (interface{}, uint32, error) <span class="cov8" title="1">{
        // fmt.Printf("\n\nt: %v\n", t)
        // fmt.Printf("data: %x\n\n\n", data)
        length := uint32(0)
        v := reflect.New(t).Elem()
        customDecodeRequired, decoded, customLength := CheckCustomDecode(data, t)
        if customDecodeRequired </span><span class="cov8" title="1">{
                // fmt.Printf("\n\nCustom Decode\n\n\n")
                if len(data) &lt; int(customLength) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for custom decode")
                }</span>
                <span class="cov8" title="1">return decoded, customLength, nil</span>
        }

        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                if len(data) &lt; 1 </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for bool")
                }</span>
                <span class="cov8" title="1">v.SetBool(data[0] == 1)
                length = 1</span>
        case reflect.Uint:<span class="cov0" title="0">
                x, l := DecodeE(data)
                if len(data) &lt; int(l) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for uint")
                }</span>
                <span class="cov0" title="0">v.SetUint(x)
                length = l</span>
        case reflect.Uint8:<span class="cov8" title="1">
                if len(data) &lt; 1 </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for uint8")
                }</span>
                <span class="cov8" title="1">x := DecodeE_l(data)
                v.SetUint(x)
                length = 1</span>
        case reflect.Uint16:<span class="cov8" title="1">
                if len(data) &lt; 2 </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for uint16")
                }</span>
                <span class="cov8" title="1">x := DecodeE_l(data)
                v.SetUint(x)
                length = 2</span>
        case reflect.Uint32:<span class="cov8" title="1">
                if len(data) &lt; 4 </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for uint32")
                }</span>
                <span class="cov8" title="1">x := DecodeE_l(data)
                v.SetUint(x)
                length = 4</span>
        case reflect.Uint64:<span class="cov8" title="1">
                if len(data) &lt; 8 </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for uint64")
                }</span>
                <span class="cov8" title="1">x := DecodeE_l(data)
                v.SetUint(x)
                length = 8</span>
        case reflect.String:<span class="cov0" title="0">
                str_len, l := DecodeE(data)
                if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for decoding string length")
                }</span>
                <span class="cov0" title="0">length += l
                var T []uint64
                for i := 0; i &lt; int(str_len); i++ </span><span class="cov0" title="0">{
                        if len(data) &lt; int(length+1) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for string character")
                        }</span>
                        <span class="cov0" title="0">x, l := DecodeE(data[length:])
                        if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for string character decoding")
                        }</span>
                        <span class="cov0" title="0">T = append(T, x)
                        length += l</span>
                }
                <span class="cov0" title="0">var str string
                for _, c := range T </span><span class="cov0" title="0">{
                        str += string(rune(c))
                }</span>
                <span class="cov0" title="0">v.SetString(str)</span>
        case reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        if len(data) &lt; int(length+1) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for array element")
                        }</span>
                        <span class="cov8" title="1">if v.Index(i).Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                                v.Index(i).Set(reflect.ValueOf(data[length]))
                                length++
                        }</span> else<span class="cov8" title="1"> {
                                if len(data[length:]) &lt; 1 </span><span class="cov0" title="0">{
                                        return nil, 0, fmt.Errorf("data length insufficient for array element decoding")
                                }</span>
                                <span class="cov8" title="1">elem, l, err := Decode(data[length:], v.Index(i).Type())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, 0, err
                                }</span>
                                <span class="cov8" title="1">if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                                        return nil, 0, fmt.Errorf("data length insufficient for array element decoding")
                                }</span>
                                <span class="cov8" title="1">if elem != nil </span><span class="cov8" title="1">{
                                        v.Index(i).Set(reflect.ValueOf(elem))
                                }</span>
                                <span class="cov8" title="1">length += l</span>
                        }
                }
        case reflect.Slice:<span class="cov8" title="1">
                item_len, l := DecodeE(data)
                if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for slice length")
                }</span>
                <span class="cov8" title="1">v.Set(reflect.MakeSlice(t, int(item_len), int(item_len)))
                length += l
                for i := 0; i &lt; int(item_len); i++ </span><span class="cov8" title="1">{
                        if len(data) &lt; int(length+1) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for slice element")
                        }</span>
                        <span class="cov8" title="1">if v.Index(i).Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                                v.Index(i).Set(reflect.ValueOf(data[length]))
                                length++
                        }</span> else<span class="cov8" title="1"> {
                                if len(data[length:]) &lt; 1 </span><span class="cov0" title="0">{
                                        return nil, 0, fmt.Errorf("data length insufficient for slice element decoding")
                                }</span>
                                <span class="cov8" title="1">elem, l, err := Decode(data[length:], v.Index(i).Type())
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, 0, err
                                }</span>
                                <span class="cov8" title="1">if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                                        return nil, 0, fmt.Errorf("data length insufficient for slice element decoding")
                                }</span>
                                <span class="cov8" title="1">if elem != nil </span><span class="cov8" title="1">{
                                        v.Index(i).Set(reflect.ValueOf(elem))
                                }</span>
                                <span class="cov8" title="1">length += l</span>
                        }
                }
        case reflect.Struct:<span class="cov8" title="1">
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                        if len(data[length:]) &lt; 1 </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for struct field")
                        }</span>
                        <span class="cov8" title="1">elem, l, err := Decode(data[length:], v.Field(i).Type())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, 0, err
                        }</span>
                        <span class="cov8" title="1">if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for struct field decoding")
                        }</span>
                        <span class="cov8" title="1">if elem != nil </span><span class="cov8" title="1">{
                                v.Field(i).Set(reflect.ValueOf(elem))
                        }</span>
                        <span class="cov8" title="1">length += l</span>
                }
        case reflect.Ptr:<span class="cov0" title="0">
                if len(data) &lt; int(length+1) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("data length insufficient for pointer indicator")
                }</span>
                <span class="cov0" title="0">if data[length] == 0 </span><span class="cov0" title="0">{
                        length++
                        v.Set(reflect.Zero(t))
                }</span> else<span class="cov0" title="0"> {
                        ptrType := t.Elem()
                        if len(data[length:]) &lt; 1 </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for pointer content decoding")
                        }</span>
                        <span class="cov0" title="0">ptr := reflect.New(ptrType)
                        elem, l, err := Decode(data[length:], ptrType)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, 0, err
                        }</span>
                        <span class="cov0" title="0">if len(data) &lt; int(length+l) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("data length insufficient for pointer content")
                        }</span>
                        <span class="cov0" title="0">if elem != nil </span><span class="cov0" title="0">{
                                ptr.Elem().Set(reflect.ValueOf(elem))
                        }</span>
                        <span class="cov0" title="0">v.Set(ptr)
                        length += l</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                keyType := t.Key()
                valueType := t.Elem()

                kvPairType := reflect.StructOf([]reflect.StructField{
                        {
                                Name: "Key",
                                Type: keyType,
                                Tag:  reflect.StructTag(`json:"key"`),
                        },
                        {
                                Name: "Value",
                                Type: valueType,
                                Tag:  reflect.StructTag(`json:"value"`),
                        },
                })

                kvPairSliceType := reflect.SliceOf(kvPairType)

                decoded, l, err := Decode(data, kvPairSliceType)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, 0, err
                }</span>

                <span class="cov0" title="0">length += l

                v.Set(reflect.MakeMap(t))

                kvPairs := reflect.ValueOf(decoded)
                for i := 0; i &lt; kvPairs.Len(); i++ </span><span class="cov0" title="0">{
                        kv := kvPairs.Index(i)
                        key := kv.FieldByName("Key")
                        value := kv.FieldByName("Value")
                        v.SetMapIndex(key, value)
                }</span>

        }
        <span class="cov8" title="1">return v.Interface(), length, nil</span>
}

func SaveObject(path string, obj interface{}) error <span class="cov0" title="0">{
        jsonPath := fmt.Sprintf("%s.json", path)
        codecPath := fmt.Sprintf("%s.bin", path)

        switch v := obj.(type) </span>{
        default:<span class="cov0" title="0">
                jsonEncode, _ := json.MarshalIndent(v, "", "    ")
                codecEncode, err := Encode(v)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error encoding object: %v\n", err)
                }</span>
                <span class="cov0" title="0">err = os.WriteFile(jsonPath, jsonEncode, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error writing json file: %v\n", err)
                }</span>
                <span class="cov0" title="0">err = os.WriteFile(codecPath, codecEncode, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("Error writing codec file: %v\n", err)
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package types

import (
        "encoding/json"
        "fmt"
)

type CommandConfig struct {
        Help            bool   `json:"help"`
        NodeName        string `json:"nodename"`
        DataDir         string `json:"datadir"`
        Epoch0Timestamp int    `json:"ts"`
        Port            int    `json:"port"`
        Genesis         string `json:"genesis"`
        Ed25519         string `json:"genesis"`
        Bls             string `json:"bls"`
        Bandersnatch    string `json:"bandersnatch"`
}

// String method returns the CommandConfig as a formatted JSON string
func (c *CommandConfig) String() string <span class="cov0" title="0">{
        jsonData, err := json.MarshalIndent(c, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(jsonData)</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">package types

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "sort"

        "github.com/colorfulnotion/jam/common"
)

type SOffendersMark struct {
        OffenderKey []string `json:"offender_mark"`
}

type VerdictMarker struct {
        WorkReportHash []common.Hash `json:"verdict_mark"` // WorkReportHash (ByteArray32 in disputes.asn)
}

type OffenderMarker struct {
        OffenderKey []Ed25519Key `json:"offender_mark"`
}

type SOffenderMarker struct {
        OffenderKey []string `json:"offender_mark"`
}

/*
Section 10.2.  The disputes extrinsic, ${\bf E}_D$, may contain one or more verdicts ${\bf v}$.

Dispute` ${\bf E}_D$:
*/
// Disputes represents a one or or more verdicts.
type Dispute struct {
        Verdict []Verdict `json:"verdicts"`
        Culprit []Culprit `json:"culprits"`
        Fault   []Fault   `json:"faults"`
}

type Verdict struct {
        Target common.Hash                   `json:"target"`
        Epoch  uint32                        `json:"age"`
        Votes  [ValidatorsSuperMajority]Vote `json:"votes"`
}

func (v *Verdict) Verify(validators []Validator) error <span class="cov0" title="0">{
        target := v.Target
        for _, vote := range v.Votes </span><span class="cov0" title="0">{
                signtext := vote.UnsignedBytesWithSalt(target)
                if Ed25519Verify(validators[vote.Index].Ed25519, signtext, vote.Signature) == false </span><span class="cov0" title="0">{
                        return errors.New(fmt.Sprintf("Invalid signature for vote %d", vote.Index))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (v *Vote) UnsignedBytesWithSalt(target common.Hash) []byte <span class="cov0" title="0">{
        signtext := target.Bytes()
        if v.Voting </span><span class="cov0" title="0">{
                signtext = append([]byte(X_True), signtext...)
        }</span> else<span class="cov0" title="0"> {
                signtext = append([]byte(X_False), signtext...)
        }</span>
        <span class="cov0" title="0">return signtext</span>
}

type Culprit struct {
        Target    common.Hash      `json:"target"`
        Key       Ed25519Key       `json:"key"`
        Signature Ed25519Signature `json:"signature"`
}

func (c *Culprit) Verify() bool <span class="cov0" title="0">{
        signtext := c.UnsignedBytesWithSalt()
        return Ed25519Verify(c.Key, signtext, c.Signature)
}</span>

func (c *Culprit) UnsignedBytesWithSalt() []byte <span class="cov0" title="0">{
        signtext := c.Target.Bytes()
        signtext = append([]byte(X_G), signtext...)
        return signtext
}</span>

type Fault struct {
        Target    common.Hash      `json:"target"`
        Voting    bool             `json:"vote"`
        Key       Ed25519Key       `json:"key"`
        Signature Ed25519Signature `json:"signature"`
}

func (f *Fault) Verify() bool <span class="cov0" title="0">{
        signtext := f.UnsignedBytesWithSalt()
        return Ed25519Verify(f.Key, signtext, f.Signature)
}</span>

func (f *Fault) UnsignedBytesWithSalt() []byte <span class="cov0" title="0">{
        signtext := f.Target.Bytes()
        if f.Voting </span><span class="cov0" title="0">{
                signtext = append([]byte(X_True), signtext...)
        }</span> else<span class="cov0" title="0"> {
                signtext = append([]byte(X_False), signtext...)
        }</span>
        <span class="cov0" title="0">return signtext</span>
}

func (t Dispute) DeepCopy() (Dispute, error) <span class="cov0" title="0">{
        var copiedDispute Dispute

        // Serialize the original Dispute to JSON
        data, err := Encode(t)
        if err != nil </span><span class="cov0" title="0">{
                return copiedDispute, err
        }</span>

        // Deserialize the JSON back into a new Dispute instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Dispute{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedDispute, err
        }</span>
        <span class="cov0" title="0">copiedDispute = decoded.(Dispute)

        return copiedDispute, nil</span>
}

// Bytes returns the bytes of the Dispute
func (a *Dispute) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (a *Dispute) Hash() common.Hash <span class="cov0" title="0">{
        data := a.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}

func (a *Dispute) Print() <span class="cov0" title="0">{
        // print json
        enc, err := json.MarshalIndent(a, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(enc))</span>
}

func (a *Culprit) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Target    common.Hash `json:"target"`
                Key       string      `json:"key"`
                Signature string      `json:"signature"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a.Target = s.Target
        keyBytes := common.FromHex(s.Key)
        copy(a.Key[:], keyBytes)
        signatureBytes := common.FromHex(s.Signature)
        copy(a.Signature[:], signatureBytes)

        return nil</span>
}

type Vote struct {
        Voting    bool             `json:"vote"`      // true for the work report is good, false for the work report is bad
        Index     uint16           `json:"index"`     // validator index
        Signature Ed25519Signature `json:"signature"` // signature of the vote (ByteArray64 in disputes.asn)
}

func (t Vote) DeepCopy() (Vote, error) <span class="cov0" title="0">{
        var copiedVote Vote

        // Serialize the original Dispute to JSON
        data, err := Encode(t)
        if err != nil </span><span class="cov0" title="0">{
                return copiedVote, err
        }</span>

        // Deserialize the JSON back into a new Dispute instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Vote{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedVote, err
        }</span>
        <span class="cov0" title="0">copiedVote = decoded.(Vote)
        return copiedVote, nil</span>
}

// func (v *Vote) Bytes() []byte {
//         enc := Encode(v)
//         return enc
// }

// func (v *Vote) Hash() common.Hash {
//         data := v.Bytes()
//         if data == nil {
//                 // Handle the error case
//                 return common.Hash{}
//         }
//         return common.Blake2Hash(data)
// }

func FormDispute(v map[common.Hash]Vote) Dispute <span class="cov0" title="0">{
        //return nil dispute
        _ = v
        return Dispute{}
}</span>

func (a *Vote) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Voting    bool   `json:"vote"`
                Index     uint16 `json:"index"`
                Signature string `json:"signature"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.Voting = s.Voting
        a.Index = s.Index
        a.Signature = Ed25519Signature(common.FromHex(s.Signature))
        return nil</span>
}

func (a Vote) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(struct {
                Voting    bool   `json:"vote"`
                Index     uint16 `json:"index"`
                Signature string `json:"signature"`
        }{
                Voting:    a.Voting,
                Index:     a.Index,
                Signature: common.HexString(a.Signature[:]),
        })
}</span>

func (v *Vote) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (v *Vote) Hash() common.Hash <span class="cov0" title="0">{
        data := v.Bytes()
        return common.Blake2Hash(data)
}</span>

func (a *Fault) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Target    common.Hash `json:"target"`
                Voting    bool        `json:"vote"`
                Key       string      `json:"key"`
                Signature string      `json:"signature"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.Target = s.Target
        a.Voting = s.Voting
        a.Key = Ed25519Key(common.FromHex(s.Key))
        a.Signature = Ed25519Signature(common.FromHex(s.Signature))

        return nil</span>
}

func (a Culprit) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                Target    common.Hash `json:"target"`
                Key       string      `json:"key"`
                Signature string      `json:"signature"`
        }{
                Target:    a.Target,
                Key:       common.HexString(a.Key[:]),
                Signature: common.HexString(a.Signature[:]),
        })
}</span>

func (a Fault) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                Target    common.Hash `json:"target"`
                Voting    bool        `json:"vote"`
                Key       string      `json:"key"`
                Signature string      `json:"signature"`
        }{
                Target:    a.Target,
                Voting:    a.Voting,
                Key:       common.HexString(a.Key[:]),
                Signature: common.HexString(a.Signature[:]),
        })
}</span>

func (c *Culprit) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (c *Culprit) Hash() common.Hash <span class="cov0" title="0">{
        data := c.Bytes()
        return common.Blake2Hash(data)
}</span>

func (f *Fault) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (f *Fault) Hash() common.Hash <span class="cov0" title="0">{
        data := f.Bytes()
        return common.Blake2Hash(data)
}</span>

func (d *Dispute) FormatDispute() <span class="cov0" title="0">{
        // verdicts, culprits, faults
        // verdicts : order by target, votes : order by index
        d.Verdict = SortVerdicts(d.Verdict)
        // culprits : order by target
        d.Culprit = SortCulprits(d.Culprit)
        // faults : order by target
        d.Fault = SortFaults(d.Fault)
}</span>

func SortVerdicts(verdicts []Verdict) []Verdict <span class="cov0" title="0">{
        // Sort the verdicts by target
        sort.Slice(verdicts, func(i, j int) bool </span><span class="cov0" title="0">{
                return bytes.Compare(verdicts[i].Target.Bytes(), verdicts[j].Target.Bytes()) &lt; 0
        }</span>)
        <span class="cov0" title="0">for _, v := range verdicts </span><span class="cov0" title="0">{
                v.Votes = SortVotes(v.Votes)
        }</span>
        <span class="cov0" title="0">return verdicts</span>
}

func SortVotes(votes [ValidatorsSuperMajority]Vote) [ValidatorsSuperMajority]Vote <span class="cov0" title="0">{
        // Sort the votes by index
        voteSlice := votes[:]
        sort.Slice(voteSlice, func(i, j int) bool </span><span class="cov0" title="0">{
                return voteSlice[i].Index &lt; voteSlice[j].Index
        }</span>)
        <span class="cov0" title="0">copy(votes[:], voteSlice)
        return votes</span>
}

func SortCulprits(culprits []Culprit) []Culprit <span class="cov0" title="0">{
        // Sort the culprits by target
        sort.Slice(culprits, func(i, j int) bool </span><span class="cov0" title="0">{
                return bytes.Compare(culprits[i].Target.Bytes(), culprits[j].Target.Bytes()) &lt; 0
        }</span>)
        <span class="cov0" title="0">return culprits</span>
}

func SortFaults(faults []Fault) []Fault <span class="cov0" title="0">{
        // Sort the faults by target
        sort.Slice(faults, func(i, j int) bool </span><span class="cov0" title="0">{
                return bytes.Compare(faults[i].Target.Bytes(), faults[j].Target.Bytes()) &lt; 0
        }</span>)
        <span class="cov0" title="0">return faults</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package types

import (
        //        "bytes"
        "crypto/ed25519"
        "encoding/json"

        //        "errors"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

const (
        Ed25519PubkeySize     = 32
        Ed25519PrivateKeySize = 64 // 32 byte seeds + 32 pub concatenated
        Ed25519SignatureSize  = 64 // 32 byte R + 32 byte S
)

type Ed25519Key common.Hash
type Ed25519Priv ed25519.PrivateKey
type Ed25519Signature [Ed25519SignatureSize]byte

func (k Ed25519Key) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(common.Hash(k).Hex())
}</span>

func GenerateRandomEd25519Signature() Ed25519Signature <span class="cov0" title="0">{
        var s Ed25519Signature
        // TODO
        return s
}</span>

func (k *Ed25519Key) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        var hexStr string
        if err := json.Unmarshal(data, &amp;hexStr); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">*k = Ed25519Key(common.HexToHash(hexStr))
        return nil</span>
}

func (k Ed25519Key) String() string <span class="cov0" title="0">{
        return common.Hash(k).Hex()
}</span>

func (pk Ed25519Key) Bytes() []byte <span class="cov0" title="0">{
        return pk[:]
}</span>

func (pk Ed25519Key) PublicKey() ed25519.PublicKey <span class="cov8" title="1">{
        return ed25519.PublicKey(pk[:])
}</span>

func BytesToFixedLength(sig []byte) (interface{}, error) <span class="cov0" title="0">{
        length := len(sig)

        // Dynamically create a fixed-size array type of the appropriate length
        fixedLengthArrayType := reflect.ArrayOf(length, reflect.TypeOf(byte(0)))
        fixedLengthArray := reflect.New(fixedLengthArrayType).Elem()

        if len(sig) != length </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid byte slice length: expected %d bytes, got %d", length, len(sig))
        }</span>

        // Copy bytes to the fixed-length array
        <span class="cov0" title="0">reflect.Copy(fixedLengthArray, reflect.ValueOf(sig))

        // Return as an interface{} since the actual type is not known until runtime
        return fixedLengthArray.Interface(), nil</span>
}

func HexToEd25519Sig(hexStr string) Ed25519Signature <span class="cov0" title="0">{
        b := common.Hex2Bytes(hexStr)
        var signature Ed25519Signature
        copy(signature[:], b)
        return signature
}</span>

// Ed25519Signature to byte
func (e *Ed25519Signature) Bytes() []byte <span class="cov0" title="0">{
        return e[:]
}</span>

func HexToEd25519Key(hexStr string) Ed25519Key <span class="cov0" title="0">{
        b := common.Hex2Bytes(hexStr)
        var pubkey Ed25519Key
        copy(pubkey[:], b)
        return pubkey
}</span>

func InitEd25519Key(seed []byte) (Ed25519Key, []byte, error) <span class="cov0" title="0">{
        // Check if the seed length is 32 bytes
        if len(seed) != ed25519.SeedSize </span><span class="cov0" title="0">{
                return Ed25519Key{}, nil, fmt.Errorf("seed length must be %d bytes", ed25519.SeedSize)
        }</span>

        // Generate the private key from the seed
        <span class="cov0" title="0">ed25519_priv := ed25519.NewKeyFromSeed(seed)

        // The public key is the second half of the private key
        ed25519_pub := ed25519_priv.Public().(ed25519.PublicKey)

        return Ed25519Key(ed25519_pub), ed25519_priv, nil</span>
}

func BytesToEd25519Priv(b []byte) (Ed25519Priv, error) <span class="cov0" title="0">{
        if len(b) != Ed25519PrivateKeySize </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid byte slice length: expected %d bytes, got %d", Ed25519PrivateKeySize, len(b))
        }</span>
        <span class="cov0" title="0">var priv Ed25519Priv
        copy(priv[:], b)
        return priv, nil</span>
}

func Ed25519Sign(priv Ed25519Priv, msg []byte) Ed25519Signature <span class="cov0" title="0">{
        signature := ed25519.Sign(ed25519.PrivateKey(priv), msg)
        var ed25519Signature Ed25519Signature
        copy(ed25519Signature[:], signature)
        return ed25519Signature
}</span>

func Ed25519SignByBytes(priv []byte, msg []byte) Ed25519Signature <span class="cov0" title="0">{
        signature := ed25519.Sign(ed25519.PrivateKey(priv), msg)
        var ed25519Signature Ed25519Signature
        copy(ed25519Signature[:], signature)
        return ed25519Signature
}</span>

func Ed25519Verify(pub Ed25519Key, msg []byte, sig Ed25519Signature) bool <span class="cov8" title="1">{
        return ed25519.Verify(pub.PublicKey(), msg, sig[:])
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package types

import (
        "fmt"
        "github.com/colorfulnotion/jam/common"
        "reflect"
)

// EpochMark (see 6.4 Epoch change Signal) represents the descriptor for parameters to be used in the next epoch
type EpochMark struct {
        // Randomness accumulator snapshot
        Entropy        common.Hash `json:"entropy"`
        TicketsEntropy common.Hash `json:"tickets_entropy"`
        // List of authorities scheduled for next epoch
        Validators [TotalValidators]common.Hash `json:"validators"` //bandersnatch keys
}

func (e EpochMark) String() string <span class="cov0" title="0">{
        entropyShort := common.Str(e.Entropy)
        ticketsEntropyShort := common.Str(e.TicketsEntropy)
        /*validatorsShort := ""
        q := ""
        for _, validator := range e.Validators {
                validatorsShort += q + common.Str(validator)
                q = ", "
        } */
        return fmt.Sprintf("\033[32m EpochMarker\033[0m(η1'=%s, η2'=%s)", entropyShort, ticketsEntropyShort) // validatorsShort
}</span>

func (E *EpochMark) Encode() []byte <span class="cov8" title="1">{
        if E == nil </span><span class="cov8" title="1">{
                return []byte{0}
        }</span>
        <span class="cov8" title="1">encoded := []byte{1}
        encodedEpochMark, err := Encode(*E)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov8" title="1">encoded = append(encoded, encodedEpochMark...)
        return encoded</span>
}

func (target *EpochMark) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        if data[0] == 0 </span><span class="cov8" title="1">{
                return nil, 1
        }</span>
        <span class="cov8" title="1">length := uint32(1)
        entropy, l, err := Decode(data[length:], reflect.TypeOf(common.Hash{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, length
        }</span>
        <span class="cov8" title="1">length += l
        ticketsentropy, l, err := Decode(data[length:], reflect.TypeOf(common.Hash{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, length
        }</span>
        <span class="cov8" title="1">length += l
        validators, l, err := Decode(data[length:], reflect.TypeOf([TotalValidators]common.Hash{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, length
        }</span>
        <span class="cov8" title="1">decoded := EpochMark{
                Entropy:        entropy.(common.Hash),
                TicketsEntropy: ticketsentropy.(common.Hash),
                Validators:     validators.([TotalValidators]common.Hash),
        }
        length += l
        return &amp;decoded, length</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package types

import (
        "sync"

        "github.com/colorfulnotion/jam/common"
)

type ExtrinsicPool struct {
        // assurances queue storage
        queuedAssurances map[common.Hash]map[uint16]*Assurance
        assuranceMutex   sync.Mutex
        // guarantees queue storage
        queuedGuarantees map[uint32]map[uint16]*Guarantee // use timeslot to store guarantees, and core index to distinguish
        guaranteeMutex   sync.Mutex
        // tickets queue storage
        queuedTickets map[common.Hash]map[common.Hash]*Ticket // use entropy hash to store tickets, and ticket id to distinguish
        ticketMutex   sync.Mutex
        // preimage queue storage
        queuedPreimages map[common.Hash]*Preimages // use AccountPreimageHash hash to store preimages
        knownPreimages  map[common.Hash]*uint32    // use AccountPreimageHash hash to store preimages
        preimageMutex   sync.Mutex
}

func NewExtrinsicPool() *ExtrinsicPool <span class="cov0" title="0">{
        return &amp;ExtrinsicPool{
                queuedAssurances: make(map[common.Hash]map[uint16]*Assurance),
                queuedGuarantees: make(map[uint32]map[uint16]*Guarantee),
                queuedTickets:    make(map[common.Hash]map[common.Hash]*Ticket),
                queuedPreimages:  make(map[common.Hash]*Preimages),
                knownPreimages:   make(map[common.Hash]*uint32),
        }
}</span>

func (ep *ExtrinsicPool) RemoveUsedExtrinsicFromPool(block *Block, used_entropy common.Hash, IsTicketSubmissionClosed bool) <span class="cov0" title="0">{
        parent_hash := block.Header.ParentHeaderHash
        // Remove assurances
        ep.RemoveAssurancesFromPool(parent_hash)
        // Remove guarantees
        for _, guarantee := range block.Extrinsic.Guarantees </span><span class="cov0" title="0">{
                ep.RemoveOldGuarantees(guarantee)
        }</span>
        // Remove tickets
        <span class="cov0" title="0">if IsTicketSubmissionClosed </span><span class="cov0" title="0">{ // if ticket submission is closed, remove all tickets from useless entropy
                ep.RemoveTicketsFromPool(used_entropy)
        }</span> else<span class="cov0" title="0"> {
                ep.RemoveOldTickets(block.Extrinsic.Tickets, used_entropy)
        }</span>
        // Remove preimages
        <span class="cov0" title="0">ep.RemoveOldPreimages(block.Extrinsic.Preimages, block.Header.Slot)</span>

}

func (ep *ExtrinsicPool) AddAssuranceToPool(assurance Assurance) error <span class="cov0" title="0">{
        ep.assuranceMutex.Lock()
        defer ep.assuranceMutex.Unlock()
        // Store the assurance in the tip's queued assurance
        // Ensure the map for this anchor exists
        if _, exists := ep.queuedAssurances[assurance.Anchor]; !exists </span><span class="cov0" title="0">{
                ep.queuedAssurances[assurance.Anchor] = make(map[uint16]*Assurance)
        }</span>
        // Store the assurance in the appropriate map
        <span class="cov0" title="0">ep.queuedAssurances[assurance.Anchor][assurance.ValidatorIndex] = &amp;assurance
        return nil</span> // Success
}

func (ep *ExtrinsicPool) GetAssurancesFromPool(parentHash common.Hash) []Assurance <span class="cov0" title="0">{
        assurances := make([]Assurance, 0)
        ep.assuranceMutex.Lock()
        defer ep.assuranceMutex.Unlock()
        if _, exists := ep.queuedAssurances[parentHash]; exists </span><span class="cov0" title="0">{
                for _, assurance := range ep.queuedAssurances[parentHash] </span><span class="cov0" title="0">{
                        assurances = append(assurances, *assurance)
                }</span>
        }
        <span class="cov0" title="0">return assurances</span>
}

func (ep *ExtrinsicPool) RemoveOldAssurances(assurance Assurance) error <span class="cov0" title="0">{
        ep.assuranceMutex.Lock()
        defer ep.assuranceMutex.Unlock()
        if _, exists := ep.queuedAssurances[assurance.Anchor]; exists </span><span class="cov0" title="0">{
                if _, exists := ep.queuedAssurances[assurance.Anchor][assurance.ValidatorIndex]; exists </span><span class="cov0" title="0">{
                        delete(ep.queuedAssurances[assurance.Anchor], assurance.ValidatorIndex)
                }</span>
        }
        <span class="cov0" title="0">return nil</span> // Success
}

func (ep *ExtrinsicPool) RemoveAssurancesFromPool(parentHash common.Hash) error <span class="cov0" title="0">{
        ep.assuranceMutex.Lock()
        defer ep.assuranceMutex.Unlock()
        if _, exists := ep.queuedAssurances[parentHash]; exists </span><span class="cov0" title="0">{
                delete(ep.queuedAssurances, parentHash)
        }</span>
        <span class="cov0" title="0">return nil</span> // Success
}

func (ep *ExtrinsicPool) AddGuaranteeToPool(guarantee Guarantee) error <span class="cov0" title="0">{
        ep.guaranteeMutex.Lock()
        defer ep.guaranteeMutex.Unlock()
        // Store the guarantee in the tip's queued guarantee
        if _, exists := ep.queuedGuarantees[guarantee.Slot]; !exists </span><span class="cov0" title="0">{
                ep.queuedGuarantees[guarantee.Slot] = make(map[uint16]*Guarantee)
        }</span>
        <span class="cov0" title="0">ep.queuedGuarantees[guarantee.Slot][guarantee.Report.CoreIndex] = &amp;guarantee
        return nil</span> // Success
}

/*
Get the guarantees for the given accepted slot
any guarantee that is younger than the accepted slot will be removed
*/
func (ep *ExtrinsicPool) GetGuaranteesFromPool(accepted_slot uint32) []Guarantee <span class="cov0" title="0">{
        guarantees := make([]Guarantee, 0)
        ep.guaranteeMutex.Lock()
        defer ep.guaranteeMutex.Unlock()
        for slot, guaranteesMap := range ep.queuedGuarantees </span><span class="cov0" title="0">{
                if slot &gt; accepted_slot </span><span class="cov0" title="0">{
                        for _, guarantee := range guaranteesMap </span><span class="cov0" title="0">{
                                guarantees = append(guarantees, *guarantee)
                        }</span>
                } else<span class="cov0" title="0"> {
                        delete(ep.queuedGuarantees, slot)
                }</span>
        }
        <span class="cov0" title="0">return guarantees</span>
}

// remove the guarantees that are already used by the block
func (ep *ExtrinsicPool) RemoveOldGuarantees(guarantee Guarantee) error <span class="cov0" title="0">{
        ep.guaranteeMutex.Lock()
        defer ep.guaranteeMutex.Unlock()
        if _, exists := ep.queuedGuarantees[guarantee.Slot]; exists </span><span class="cov0" title="0">{
                if _, exists := ep.queuedGuarantees[guarantee.Slot][guarantee.Report.CoreIndex]; exists </span><span class="cov0" title="0">{
                        delete(ep.queuedGuarantees[guarantee.Slot], guarantee.Report.CoreIndex)
                }</span>
        }
        <span class="cov0" title="0">return nil</span> // Success
}

// we need to remove the tickets that are already useless (outdated)
func (ep *ExtrinsicPool) RemoveGuaranteesFromPool(accepted_slot uint32) error <span class="cov0" title="0">{
        ep.guaranteeMutex.Lock()
        defer ep.guaranteeMutex.Unlock()
        if _, exists := ep.queuedGuarantees[accepted_slot]; exists </span><span class="cov0" title="0">{
                delete(ep.queuedGuarantees, accepted_slot)
        }</span>
        <span class="cov0" title="0">return nil</span> // Success
}

func (ep *ExtrinsicPool) AddTicketToPool(ticket Ticket, used_entropy common.Hash) error <span class="cov0" title="0">{
        ep.ticketMutex.Lock()
        defer ep.ticketMutex.Unlock()
        // Store the ticket in the tip's queued ticket
        // Ensure the map for this anchor exists
        if _, exists := ep.queuedTickets[used_entropy]; !exists </span><span class="cov0" title="0">{
                ep.queuedTickets[used_entropy] = make(map[common.Hash]*Ticket)
        }</span>
        // Store the ticket in the appropriate map
        <span class="cov0" title="0">id, err := ticket.TicketID()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ep.queuedTickets[used_entropy][id] = &amp;ticket
        return nil</span> // Success
}

// get the tickets for the given used_entropy
func (ep *ExtrinsicPool) GetTicketsFromPool(used_entropy common.Hash) []Ticket <span class="cov0" title="0">{
        tickets := make([]Ticket, 0)
        ep.ticketMutex.Lock()
        defer ep.ticketMutex.Unlock()
        if _, exists := ep.queuedTickets[used_entropy]; exists </span><span class="cov0" title="0">{
                for _, ticket := range ep.queuedTickets[used_entropy] </span><span class="cov0" title="0">{
                        tickets = append(tickets, *ticket)
                }</span>
        }
        <span class="cov0" title="0">return tickets</span>
}

// remove the tickets that are already used by the block
func (ep *ExtrinsicPool) RemoveOldTickets(tickets []Ticket, entropy common.Hash) error <span class="cov0" title="0">{
        ep.ticketMutex.Lock()
        defer ep.ticketMutex.Unlock()
        if _, exists := ep.queuedTickets[entropy]; exists </span><span class="cov0" title="0">{
                for _, ticket := range tickets </span><span class="cov0" title="0">{
                        id, err := ticket.TicketID()
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if _, exists := ep.queuedTickets[entropy][id]; exists </span><span class="cov0" title="0">{
                                delete(ep.queuedTickets[entropy], id)
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span> // Success
}

// this function is used to remove all tickets generated by used_entropy from the pool
func (ep *ExtrinsicPool) RemoveTicketsFromPool(used_entropy common.Hash) error <span class="cov0" title="0">{
        ep.ticketMutex.Lock()
        defer ep.ticketMutex.Unlock()
        if _, exists := ep.queuedTickets[used_entropy]; exists </span><span class="cov0" title="0">{
                delete(ep.queuedTickets, used_entropy)
        }</span>
        <span class="cov0" title="0">return nil</span> // Success
}

func (ep *ExtrinsicPool) AddPreimageToPool(preimage Preimages) error <span class="cov0" title="0">{
        ep.preimageMutex.Lock()
        defer ep.preimageMutex.Unlock()
        // Store the preimage in the tip's queued preimage
        account_preimage_hash := preimage.AccountPreimageHash()
        // if already known, do not add it to the pool
        if _, exists := ep.knownPreimages[account_preimage_hash]; exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">ep.queuedPreimages[account_preimage_hash] = &amp;preimage
        return nil</span> // Success
}

func (ep *ExtrinsicPool) GetPreimageFromPool() []*Preimages <span class="cov0" title="0">{
        ep.preimageMutex.Lock()
        defer ep.preimageMutex.Unlock()
        preimages := make([]*Preimages, 0)
        for _, preimage := range ep.queuedPreimages </span><span class="cov0" title="0">{
                if _, exists := ep.knownPreimages[preimage.AccountPreimageHash()]; exists </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">preimages = append(preimages, preimage)</span>
        }
        <span class="cov0" title="0">return preimages</span>
}

// remove preimages from the pool that are already known or used by the block
func (ep *ExtrinsicPool) RemoveOldPreimages(block_EPs []Preimages, timeslot uint32) error <span class="cov0" title="0">{
        ep.preimageMutex.Lock()
        defer ep.preimageMutex.Unlock()
        for _, block_EP := range block_EPs </span><span class="cov0" title="0">{
                account_preimage_hash := block_EP.AccountPreimageHash()
                if _, exists := ep.queuedPreimages[account_preimage_hash]; exists </span><span class="cov0" title="0">{
                        delete(ep.queuedPreimages, account_preimage_hash)
                }</span>
                <span class="cov0" title="0">if _, exists := ep.knownPreimages[account_preimage_hash]; exists </span><span class="cov0" title="0">{
                        delete(ep.knownPreimages, account_preimage_hash)
                }</span>
                <span class="cov0" title="0">timeslot_tmp := timeslot
                ep.knownPreimages[account_preimage_hash] = &amp;timeslot_tmp</span>
        }
        // remove the known preimages by time slot
        <span class="cov0" title="0">for account_preimage_hash, ts := range ep.knownPreimages </span><span class="cov0" title="0">{
                if *ts &lt; timeslot-2*EpochLength </span><span class="cov0" title="0">{
                        delete(ep.knownPreimages, account_preimage_hash)
                }</span>
        }
        <span class="cov0" title="0">return nil</span> // Success
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package types

import (
        "github.com/colorfulnotion/jam/common"
)

// T.P.G.A.D
type ExtrinsicData struct {
        Tickets    []Ticket    `json:"tickets"`
        Preimages  []Preimages `json:"preimages"`
        Guarantees []Guarantee `json:"guarantees"`
        Assurances []Assurance `json:"assurances"`
        Disputes   Dispute     `json:"disputes"`
}

func NewExtrinsic() ExtrinsicData <span class="cov0" title="0">{
        return ExtrinsicData{}
}</span>

func (e *ExtrinsicData) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(e)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (e *ExtrinsicData) Hash() common.Hash <span class="cov0" title="0">{
        data := e.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "bytes"
        "encoding/binary"
        "io"

        "github.com/colorfulnotion/jam/common"
)

/*
Section 11.4 - Work Report Guarantees. See Equations 136 - 143. The guarantees extrinsic, ${\bf E}_G$, a *series* of guarantees, at most one for each core, each of which is a tuple of:
* core index
* work-report
* $a$, credential
* $t$, its corresponding timeslot.

The core index of each guarantee must be unique and guarantees must be in ascending order of this.
*/

// Guaranteed Work Report`

type Guarantee struct {
        Report     WorkReport            `json:"report"`
        Slot       uint32                `json:"slot"`
        Signatures []GuaranteeCredential `json:"signatures"`
}

/*
Section 11.4 - Work Report Guarantees. See Equations 136 - 143. The guarantees extrinsic, ${\bf E}_G$, a *series* of guarantees, at most one for each core, each of which is a tuple of:
* core index
* work-report
* $a$, credential
* $t$, its corresponding timeslot.

The core index of each guarantee must be unique and guarantees must be in ascending order of this.
*/
// Credential represents a series of tuples of a signature and a validator index.
type GuaranteeCredential struct {
        ValidatorIndex uint16           `json:"validator_index"`
        Signature      Ed25519Signature `json:"signature"`
}

// ToBytes serializes the GuaranteeCredential struct into a byte array
func (cred *GuaranteeCredential) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // Serialize ValidatorIndex (2 bytes)
        if err := binary.Write(buf, binary.BigEndian, cred.ValidatorIndex); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Serialize Signature (64 bytes for Ed25519Signature)
        <span class="cov0" title="0">if _, err := buf.Write(cred.Signature[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// FromBytes deserializes a byte array into a GuaranteeCredential struct
func (cred *GuaranteeCredential) FromBytes(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // Deserialize ValidatorIndex (2 bytes)
        if err := binary.Read(buf, binary.BigEndian, &amp;cred.ValidatorIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deserialize Signature (64 bytes)
        <span class="cov0" title="0">if _, err := io.ReadFull(buf, cred.Signature[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (g Guarantee) DeepCopy() (Guarantee, error) <span class="cov0" title="0">{
        var copiedGuarantee Guarantee

        // Serialize the original Guarantee to JSON
        data, err := Encode(g)
        if err != nil </span><span class="cov0" title="0">{
                return copiedGuarantee, err
        }</span>

        // Deserialize the JSON back into a new Guarantee instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Guarantee{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedGuarantee, err
        }</span>
        <span class="cov0" title="0">copiedGuarantee = decoded.(Guarantee)

        return copiedGuarantee, nil</span>
}

// Bytes returns the bytes of the Guarantee.
func (g *Guarantee) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(g)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (g *Guarantee) Hash() common.Hash <span class="cov0" title="0">{
        data := g.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}

func (g *GuaranteeCredential) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type Alias GuaranteeCredential
        aux := &amp;struct {
                *Alias
                Signature string `json:"signature"`
        }{
                Alias: (*Alias)(g),
        }
        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sigBytes := common.FromHex(aux.Signature)
        copy(g.Signature[:], sigBytes)
        return nil</span>
}

func (g *Guarantee) Verify(CurrV []Validator) error <span class="cov0" title="0">{
        signtext := g.Report.computeWorkReportBytes()
        emptyHash := common.Hash{}
        if g.Report.AvailabilitySpec.WorkPackageHash == emptyHash </span><span class="cov0" title="0">{
                return fmt.Errorf("WorkPackageHash is empty")
        }</span>
        //fmt.Printf("[guarantee:Verify] Verifying Guarantee %s\nSigntext:[%s]\n", g.String(), common.Bytes2Hex(signtext))
        //verify the signature
        <span class="cov0" title="0">numErrors := 0
        for _, i := range g.Signatures </span><span class="cov0" title="0">{
                //verify the signature
                // [i.ValidatorIndex].Ed25519
                validatorKey := CurrV[i.ValidatorIndex].GetEd25519Key()
                if !Ed25519Verify(validatorKey, signtext, i.Signature) </span><span class="cov0" title="0">{

                        numErrors++
                        //fmt.Printf("[guarantee:Verify] ERR %d invalid signature in guarantee by validator %v [PubKey: %s]\n", numErrors, i.ValidatorIndex, common.Bytes2Hex(validatorKey[:]))
                        //fmt.Printf("work report hash : %s\n", g.Report.Hash().String())
                        //fmt.Printf("sign salt : %s\n", common.Bytes2Hex(signtext))
                        //fmt.Printf("signature : %s\n", common.Bytes2Hex(i.Signature[:]))
                }</span>
        }
        <span class="cov0" title="0">if numErrors &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s", "invalid signature")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (g GuaranteeCredential) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias GuaranteeCredential
        sig := common.HexString(g.Signature[:])
        return json.Marshal(&amp;struct {
                *Alias
                Signature string `json:"signature"`
        }{
                Alias:     (*Alias)(&amp;g),
                Signature: sig,
        })
}</span>

// helper function to print the Guarantee
func (g *Guarantee) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(g, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package types

import (
        "encoding/json"
        "fmt"
)

type GuarantorAssignment struct {
        CoreIndex uint16    `json:"core_index"`
        Validator Validator `json:"validator"`
}

func (ga *GuarantorAssignment) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(struct {
                CoreIndex uint16    `json:"core_index"`
                Validator Validator `json:"validator"`
        }{
                CoreIndex: ga.CoreIndex,
                Validator: ga.Validator,
        })
}</span>
func (ga *GuarantorAssignment) String() string <span class="cov0" title="0">{
        data, err := json.Marshal(ga)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("GuarantorAssignment{CoreIndex: %d, Validator: %v}", ga.CoreIndex, ga.Validator)
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}

type GuarantorAssignments []GuarantorAssignment

func (g GuarantorAssignments) String() string <span class="cov0" title="0">{
        data, err := json.Marshal(g)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("GuarantorAssignments: %v", []GuarantorAssignment(g))
        }</span>
        <span class="cov0" title="0">return string(data)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

type BlockHeader struct {
        // H_p
        ParentHeaderHash common.Hash `json:"parent"`
        // H_r
        ParentStateRoot common.Hash `json:"parent_state_root"`
        // H_x
        ExtrinsicHash common.Hash `json:"extrinsic_hash"`
        // H_t
        Slot uint32 `json:"slot"`
        // H_e
        EpochMark *EpochMark `json:"epoch_mark,omitempty"`
        // H_w
        TicketsMark []*TicketBody `json:"tickets_mark,omitempty"`
        // H_o
        OffendersMark []Ed25519Key `json:"offenders_mark"`
        // H_i
        AuthorIndex uint16 `json:"author_index"`
        // H_v
        EntropySource BandersnatchVrfSignature `json:"entropy_source"`
        // H_s
        Seal BandersnatchVrfSignature `json:"seal"`
        // H_j
        // VerdictsMarkers *VerdictMarker `json:"verdict_markers"` // renamed from judgement
}

// BlockHeaderWithoutSig represents the BlockHeader without signature fields.
type BlockHeaderWithoutSig struct {
        ParentHeaderHash common.Hash              `json:"parent_hash"`
        PriorStateRoot   common.Hash              `json:"prior_state_root"`
        ExtrinsicHash    common.Hash              `json:"extrinsic_hash"`
        TimeSlot         uint32                   `json:"timeslot"`
        EpochMark        *EpochMark               `json:"epoch_mark"`
        TicketsMark      *TicketsMark             `json:"tickets_mark"`
        OffendersMark    []Ed25519Key             `json:"offenders_mark"`
        AuthorIndex      uint16                   `json:"block_author_key"`
        EntropySource    BandersnatchVrfSignature `json:"entropy_source"`
}

func (b *BlockHeaderWithoutSig) String() string <span class="cov0" title="0">{
        jsonByte, _ := json.Marshal(b)
        return string(jsonByte)
}</span>

// for codec
type CBlockHeader struct {
        ParentHeaderHash common.Hash              `json:"parent"`
        ParentStateRoot  common.Hash              `json:"parent_state_root"`
        ExtrinsicHash    common.Hash              `json:"extrinsic_hash"`
        Slot             uint32                   `json:"slot"`
        EpochMark        *EpochMark               `json:"epoch_mark,omitempty"`
        TicketsMark      *TicketsMark             `json:"tickets_mark"`
        OffendersMark    []Ed25519Key             `json:"offenders_mark"`
        AuthorIndex      uint16                   `json:"author_index"`
        EntropySource    BandersnatchVrfSignature `json:"entropy_source"`
        Seal             BandersnatchVrfSignature `json:"seal"`
}

// NewBlockHeader returns a fresh block header from scratch.
func NewBlockHeader() *BlockHeader <span class="cov0" title="0">{
        return &amp;BlockHeader{}
}</span>

// Encode returns Scale encoded version of the block.
func (b *BlockHeader) Bytes() ([]byte, error) <span class="cov0" title="0">{
        return b.BytesWithSig(), nil
}</span>

// UnsignedHash returns the hash of the block in unsigned form.
func (b *BlockHeader) UnsignedHash() common.Hash <span class="cov0" title="0">{
        unsignedBytes := b.BytesWithoutSig()
        return common.Blake2Hash(unsignedBytes)
}</span>

func (b *BlockHeader) HeaderHash() common.Hash <span class="cov0" title="0">{
        return b.Hash()
}</span>

// Hash returns the hash of the block in unsigned form.
func (b *BlockHeader) Hash() common.Hash <span class="cov0" title="0">{
        data := b.BytesWithSig()
        return common.Blake2Hash(data)
}</span>

func (b *BlockHeader) BytesWithSig() []byte <span class="cov0" title="0">{
        cb, _ := b.toCBlockHeader()
        enc, err := Encode(cb)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (b BlockHeader) Encode() []byte <span class="cov8" title="1">{
        cb, _ := b.toCBlockHeader()
        enc, err := Encode(cb)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return enc</span>
}

func (b BlockHeader) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        decoded, dataLen, err := Decode(data, reflect.TypeOf(CBlockHeader{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0
        }</span>
        <span class="cov8" title="1">cbh := decoded.(CBlockHeader)
        b.fromCBlockHeader(&amp;cbh)
        return b, dataLen</span>
}

// TODO FOR SEAN: why is ticet mark empty
// BytesWithoutSig returns the bytes of a block without the signature.
func (b *BlockHeader) BytesWithoutSig() []byte <span class="cov0" title="0">{
        // Create an instance of the new struct without the signature fields.
        bwoSig := BlockHeaderWithoutSig{
                ParentHeaderHash: b.ParentHeaderHash,
                PriorStateRoot:   b.ParentStateRoot,
                ExtrinsicHash:    b.ExtrinsicHash,
                TimeSlot:         b.Slot,
                EpochMark:        b.EpochMark,
                // TicketsMark:    b.TicketsMark,
                OffendersMark: b.OffendersMark,
                AuthorIndex:   b.AuthorIndex,
                EntropySource: b.EntropySource,
        }

        ticketMark, ok, _ := b.ConvertTicketsMark()
        if ok &amp;&amp; ticketMark != nil </span><span class="cov0" title="0">{
                bwoSig.TicketsMark = ticketMark
        }</span>

        // Marshal the new struct to codec
        <span class="cov0" title="0">enc, err := Encode(bwoSig)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (b *BlockHeader) ConvertTicketsMark() (*TicketsMark, bool, error) <span class="cov8" title="1">{

        var ticketsMark TicketsMark
        ticketCnt := 0

        // Handle TicketsMark conversion
        if len(b.TicketsMark) &gt; 0 </span><span class="cov8" title="1">{
                if len(b.TicketsMark) &gt; EpochLength </span><span class="cov0" title="0">{
                        return nil, false, fmt.Errorf("TicketsMark length exceeds EpochLength")
                }</span>

                <span class="cov8" title="1">if len(b.TicketsMark) != EpochLength </span><span class="cov0" title="0">{
                        return nil, false, fmt.Errorf("TicketsMark length mismatch")
                }</span>

                <span class="cov8" title="1">for i := 0; i &lt; len(b.TicketsMark); i++ </span><span class="cov8" title="1">{
                        //ticketsMark[i] = *b.TicketsMark[i]
                        if b.TicketsMark[i] != nil </span><span class="cov8" title="1">{
                                ticketCnt++
                                ticketsMark[i] = *b.TicketsMark[i]
                        }</span> else<span class="cov0" title="0"> {
                                ticketsMark[i] = TicketBody{}
                        }</span>
                }
                <span class="cov8" title="1">if ticketCnt != EpochLength </span><span class="cov0" title="0">{
                        return nil, false, fmt.Errorf("TicketsMark containing nil ticket")
                }</span>
                <span class="cov8" title="1">return &amp;ticketsMark, true, nil</span>
        }
        <span class="cov8" title="1">return nil, true, nil</span>
}

// type casting BlockHeader -&gt; CBlockHeader
func (b *BlockHeader) toCBlockHeader() (*CBlockHeader, error) <span class="cov8" title="1">{
        cbh := &amp;CBlockHeader{
                ParentHeaderHash: b.ParentHeaderHash,
                ParentStateRoot:  b.ParentStateRoot,
                ExtrinsicHash:    b.ExtrinsicHash,
                Slot:             b.Slot,
                EpochMark:        b.EpochMark,
                //TicketsMark:     nil,
                OffendersMark: b.OffendersMark,
                AuthorIndex:   b.AuthorIndex,
                EntropySource: b.EntropySource,
                Seal:          b.Seal,
        }

        ticketMark, ok, _ := b.ConvertTicketsMark()
        if ok &amp;&amp; ticketMark != nil </span><span class="cov8" title="1">{
                cbh.TicketsMark = ticketMark
        }</span>
        <span class="cov8" title="1">return cbh, nil</span>
}

// type casting CBlockHeader -&gt; BlockHeader
func (b *BlockHeader) fromCBlockHeader(cbh *CBlockHeader) <span class="cov8" title="1">{
        b.ParentHeaderHash = cbh.ParentHeaderHash
        b.ParentStateRoot = cbh.ParentStateRoot
        b.ExtrinsicHash = cbh.ExtrinsicHash
        b.Slot = cbh.Slot
        b.EpochMark = cbh.EpochMark
        b.OffendersMark = cbh.OffendersMark
        b.AuthorIndex = cbh.AuthorIndex
        b.EntropySource = cbh.EntropySource
        b.Seal = cbh.Seal

        // Handle TicketsMark conversion
        if cbh.TicketsMark != nil </span><span class="cov8" title="1">{
                ticketsMark := make([]*TicketBody, 0, EpochLength)
                for i := 0; i &lt; len(cbh.TicketsMark); i++ </span><span class="cov8" title="1">{
                        // Create a copy of the TicketBody
                        ticket := cbh.TicketsMark[i]
                        ticketsMark = append(ticketsMark, &amp;ticket)
                }</span>
                <span class="cov8" title="1">b.TicketsMark = ticketsMark</span>
        } else<span class="cov8" title="1"> {
                b.TicketsMark = nil
        }</span>
}

func (b BlockHeader) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        cbh, err := b.toCBlockHeader()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return json.Marshal(cbh)</span>
}

func (b *BlockHeader) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var cbh CBlockHeader
        if err := json.Unmarshal(data, &amp;cbh); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.fromCBlockHeader(&amp;cbh)
        return nil</span>
}

func (a *CBlockHeader) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                ParentHeaderHash common.Hash  `json:"parent"`
                ParentStateRoot  common.Hash  `json:"parent_state_root"`
                ExtrinsicHash    common.Hash  `json:"extrinsic_hash"`
                Slot             uint32       `json:"slot"`
                EpochMark        *EpochMark   `json:"epoch_mark"`
                TicketsMark      *TicketsMark `json:"tickets_mark"`
                OffenderMarker   []string     `json:"offenders_mark"`
                AuthorIndex      uint16       `json:"author_index"`
                EntropySource    string       `json:"entropy_source"`
                Seal             string       `json:"seal"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.ParentHeaderHash = s.ParentHeaderHash
        a.ParentStateRoot = s.ParentStateRoot
        a.ExtrinsicHash = s.ExtrinsicHash
        a.Slot = s.Slot
        a.EpochMark = s.EpochMark
        a.TicketsMark = s.TicketsMark

        offendersMark := make([]Ed25519Key, len(s.OffenderMarker))
        for i, v := range s.OffenderMarker </span><span class="cov8" title="1">{
                offendersMark[i] = Ed25519Key(common.FromHex(v))
        }</span>
        <span class="cov8" title="1">a.OffendersMark = offendersMark

        a.AuthorIndex = s.AuthorIndex

        entropySourceByte := common.FromHex(s.EntropySource)
        var entropySource BandersnatchVrfSignature
        copy(entropySource[:], entropySourceByte)
        a.EntropySource = entropySource

        sealByte := common.FromHex(s.Seal)
        var seal BandersnatchVrfSignature
        copy(seal[:], sealByte)
        a.Seal = seal

        return nil</span>
}

func (a *CBlockHeader) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        offendersMark := []string{}
        for _, v := range a.OffendersMark </span><span class="cov8" title="1">{
                offendersMark = append(offendersMark, common.HexString(v[:]))
        }</span>

        <span class="cov8" title="1">return json.Marshal(&amp;struct {
                ParentHeaderHash common.Hash  `json:"parent"`
                ParentStateRoot  common.Hash  `json:"parent_state_root"`
                ExtrinsicHash    common.Hash  `json:"extrinsic_hash"`
                Slot             uint32       `json:"slot"`
                EpochMark        *EpochMark   `json:"epoch_mark"`
                TicketsMark      *TicketsMark `json:"tickets_mark"`
                OffenderMarker   []string     `json:"offenders_mark"`
                AuthorIndex      uint16       `json:"author_index"`
                EntropySource    string       `json:"entropy_source"`
                Seal             string       `json:"seal"`
        }{
                ParentHeaderHash: a.ParentHeaderHash,
                ParentStateRoot:  a.ParentStateRoot,
                ExtrinsicHash:    a.ExtrinsicHash,
                Slot:             a.Slot,
                EpochMark:        a.EpochMark,
                TicketsMark:      a.TicketsMark,
                OffenderMarker:   offendersMark,
                AuthorIndex:      a.AuthorIndex,
                EntropySource:    common.HexString(a.EntropySource[:]),
                Seal:             common.HexString(a.Seal[:]),
        })</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package types

import (
        "crypto/ed25519"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

type Judgement struct {
        Judge          bool             `json:"judge"`
        WorkReportHash common.Hash      `json:"work_report"`
        Validator      uint16           `json:"validator"`
        Signature      Ed25519Signature `json:"signature"`
}

func (j Judgement) DeepCopy() (Judgement, error) <span class="cov0" title="0">{
        var copiedJudgement Judgement

        // Serialize the original Judgement to JSON
        data, err := Encode(j)
        if err != nil </span><span class="cov0" title="0">{
                return copiedJudgement, err
        }</span>

        // Deserialize the JSON back into a new Judgement instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Judgement{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedJudgement, err
        }</span>
        <span class="cov0" title="0">copiedJudgement = decoded.(Judgement)

        return copiedJudgement, nil</span>
}

func (j *Judgement) UnsignedBytesWithSalt() []byte <span class="cov0" title="0">{
        var signtext []byte
        if j.Judge </span><span class="cov0" title="0">{
                signtext = append([]byte(X_True), j.WorkReportHash.Bytes()...)
        }</span> else<span class="cov0" title="0"> {
                signtext = append([]byte(X_False), j.WorkReportHash.Bytes()...)
        }</span>
        <span class="cov0" title="0">return signtext</span>
}

func (j *Judgement) Sign(Ed25519Secret []byte) <span class="cov0" title="0">{
        signtext := j.UnsignedBytesWithSalt()

        j.Signature = Ed25519Signature(ed25519.Sign(Ed25519Secret, signtext))
}</span>

func (j *Judgement) Verify(key Ed25519Key) error <span class="cov0" title="0">{
        signtext := j.UnsignedBytesWithSalt()

        if !ed25519.Verify(key.PublicKey(), signtext, j.Signature.Bytes()) </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid signature by validator %v", j.Validator)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// func (j *Judgement) Bytes() []byte {
//         enc := Encode(j)
//         return enc
// }

// func (j *Judgement) Hash() common.Hash {
//         data := j.Bytes()
//         if data == nil {
//                 return common.Hash{}

//         }
//         return common.Blake2Hash(data)
// }

type JudgeBucket struct {
        Judgements      map[common.Hash][]Judgement `json:"judgements"`
        KnownJudgements map[common.Hash]bool        // use identifier to filter duplicate J
}

func (J *JudgeBucket) PutJudgement(j Judgement) <span class="cov0" title="0">{
        //consider adding a separate judgementHash to avoid unnecessary duplication check
        if J.Judgements == nil </span><span class="cov0" title="0">{
                J.Judgements = make(map[common.Hash][]Judgement)
        }</span>
        <span class="cov0" title="0">if J.KnownJudgements == nil </span><span class="cov0" title="0">{
                J.KnownJudgements = make(map[common.Hash]bool)
        }</span>
        <span class="cov0" title="0">workReportHash := j.WorkReportHash
        coreJudgements, exists := J.Judgements[workReportHash]
        if !exists </span><span class="cov0" title="0">{
                coreJudgements = make([]Judgement, 0)
        }</span>
        // if judgement already exists within workPackageHash, exit
        <span class="cov0" title="0">if J.KnownJudgements[j.Hash()] </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, jj := range coreJudgements </span><span class="cov0" title="0">{
                if jj.Validator == j.Validator </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">J.KnownJudgements[j.Hash()] = true
        coreJudgements = append(coreJudgements, j)
        J.Judgements[workReportHash] = coreJudgements</span>
}

func (J *JudgeBucket) GetLen(w common.Hash) int <span class="cov0" title="0">{
        return len(J.Judgements[w])
}</span>

func (J *JudgeBucket) HaveMadeJudgement(j Judgement) bool <span class="cov0" title="0">{
        if J.KnownJudgements == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return J.KnownJudgements[j.Hash()]</span>
}

func (J *JudgeBucket) HaveMadeJudgementByValidator(workreporthash common.Hash, validator uint16) bool <span class="cov0" title="0">{
        for _, j := range J.Judgements[workreporthash] </span><span class="cov0" title="0">{
                if j.Validator == validator </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (J *JudgeBucket) GetJudgementByValidator(workreporthash common.Hash, validator uint16) (Judgement, error) <span class="cov0" title="0">{
        for _, j := range J.Judgements[workreporthash] </span><span class="cov0" title="0">{
                if j.Validator == validator </span><span class="cov0" title="0">{
                        return j, nil
                }</span>
        }
        <span class="cov0" title="0">return Judgement{}, fmt.Errorf("validator %v has not made judgement on work report %v", validator, workreporthash)</span>
}

// func (J *JudgeBucket) GetJudgement(w common.Hash, core uint16) (Judgement, bool) {
//         for _, j := range J.Judgements[w] {
//                 if j.Core == core {
//                         return j, true
//                 }
//         }
//         return Judgement{}, false
// }

func (J *JudgeBucket) GetTrueCount(W common.Hash) int <span class="cov0" title="0">{
        count := 0
        for _, j := range J.Judgements[W] </span><span class="cov0" title="0">{
                if j.Judge </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

func (J *JudgeBucket) GetFalseCount(W common.Hash) int <span class="cov0" title="0">{
        count := 0
        for _, j := range J.Judgements[W] </span><span class="cov0" title="0">{
                if !j.Judge </span><span class="cov0" title="0">{
                        count++
                }</span>
        }
        <span class="cov0" title="0">return count</span>
}

func (J *JudgeBucket) GetTrueJudgement(W common.Hash) []Judgement <span class="cov0" title="0">{
        judgements := make([]Judgement, 0)
        for _, j := range J.Judgements[W] </span><span class="cov0" title="0">{
                if j.Judge </span><span class="cov0" title="0">{
                        judgements = append(judgements, j)
                }</span>
        }
        <span class="cov0" title="0">return judgements[:ValidatorsSuperMajority]</span>
}

func (J *JudgeBucket) GetFalseJudgement(W common.Hash) []Judgement <span class="cov0" title="0">{
        judgements := make([]Judgement, 0)
        for _, j := range J.Judgements[W] </span><span class="cov0" title="0">{
                if !j.Judge </span><span class="cov0" title="0">{
                        judgements = append(judgements, j)
                }</span>
        }
        <span class="cov0" title="0">if len(judgements) &lt; WonkyFalseThreshold </span><span class="cov0" title="0">{
                return judgements
        }</span>
        <span class="cov0" title="0">return judgements[:ValidatorsSuperMajority]</span>
}

func (J *JudgeBucket) GetWonkeyJudgement(W common.Hash) []Judgement <span class="cov0" title="0">{
        judgements := make([]Judgement, 0)
        trueCount := 0
        falseCount := 0
        for _, j := range J.Judgements[W] </span><span class="cov0" title="0">{
                if !j.Judge </span><span class="cov0" title="0">{
                        if falseCount &gt;= WonkyFalseThreshold </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">judgements = append(judgements, j)
                        falseCount++</span>
                } else<span class="cov0" title="0"> {
                        if trueCount &gt;= WonkyTrueThreshold </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">judgements = append(judgements, j)
                        trueCount++</span>
                }
        }

        <span class="cov0" title="0">return judgements[:ValidatorsSuperMajority]</span>
}

func (j *Judgement) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(j)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (j *Judgement) Hash() common.Hash <span class="cov0" title="0">{
        data := j.Bytes()
        return common.Blake2Hash(data)
}</span>
</pre>
		
		<pre class="file" id="file56" style="display: none">package types

import (
        "encoding/json"
        //        "errors"
        //        "fmt"
        //        "reflect"

        "github.com/colorfulnotion/jam/common"
)

// WBT justification helper
type Justification struct {
        Root     common.Hash `json:"root"`
        ShardIdx int         `json:"shard_index"`
        TreeLen  int         `json:"len"`
        //Leaf     []byte        `json:"leaf"`
        LeafHash common.Hash   `json:"leaf_hash"`
        Path     []common.Hash `json:"path"`
}

func (j *Justification) CompactPath() []byte <span class="cov0" title="0">{
        return common.CompactPath(j.Path)
}</span>

func (j *Justification) Marshal() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(j)
}</span>

func (j *Justification) Unmarshal(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, j)
}</span>

func (j *Justification) Bytes() []byte <span class="cov0" title="0">{
        jsonData, _ := j.Marshal()
        return jsonData
}</span>

func (j *Justification) String() string <span class="cov0" title="0">{
        return string(j.Bytes())
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package types

import (
        "github.com/colorfulnotion/jam/common"
        "reflect"
)

type MMR struct {
        Peaks Peaks `json:"peaks"`
}

type Peaks []*common.Hash

// C3 RecentBlocks
func (T Peaks) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return Peaks{}, 0
        }</span>
        <span class="cov0" title="0">peaks_len, length, err := Decode(data, reflect.TypeOf(uint(0)))
        if err != nil </span><span class="cov0" title="0">{
                return Peaks{}, 0
        }</span>
        <span class="cov0" title="0">if peaks_len.(uint) == 0 </span><span class="cov0" title="0">{
                return Peaks{}, length
        }</span>
        <span class="cov0" title="0">peaks := make([]*common.Hash, peaks_len.(uint))
        for i := 0; i &lt; int(peaks_len.(uint)); i++ </span><span class="cov0" title="0">{
                if data[length] == 0 </span><span class="cov0" title="0">{
                        peaks[i] = nil
                        length++
                }</span> else<span class="cov0" title="0"> if data[length] == 1 </span><span class="cov0" title="0">{
                        length++
                        decoded, l, err := Decode(data[length:], reflect.TypeOf(common.Hash{}))
                        if err != nil </span><span class="cov0" title="0">{
                                return Peaks{}, 0
                        }</span>
                        <span class="cov0" title="0">peak := decoded.(common.Hash)
                        peaks[i] = &amp;peak
                        length += l</span>
                }
        }
        <span class="cov0" title="0">return peaks, length</span>
}

// C3
func (T Peaks) Encode() []byte <span class="cov0" title="0">{
        if len(T) == 0 </span><span class="cov0" title="0">{
                return []byte{0}
        }</span>
        <span class="cov0" title="0">encoded, err := Encode(uint(len(T)))
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(T); i++ </span><span class="cov0" title="0">{
                if T[i] == nil </span><span class="cov0" title="0">{
                        encoded = append(encoded, []byte{0}...)
                }</span> else<span class="cov0" title="0"> {
                        encoded = append(encoded, []byte{1}...)
                        encodedTi, err := Encode(T[i])
                        if err != nil </span><span class="cov0" title="0">{
                                return []byte{}
                        }</span>
                        <span class="cov0" title="0">encoded = append(encoded, encodedTi...)</span>
                }
        }
        <span class="cov0" title="0">return encoded</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "github.com/colorfulnotion/jam/common"
)

type PreimageAnnouncement struct {
        ValidatorIndex uint16
        ServiceIndex   uint32
        PreimageHash   common.Hash
        PreimageLen    uint32
}

func (req *PreimageAnnouncement) String() string <span class="cov0" title="0">{
        return fmt.Sprintf(" Preimage: (s=%d, h=%v, l=%d)", req.ServiceIndex, req.PreimageHash, req.PreimageLen)
}</span>

func (req *PreimageAnnouncement) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)

        // Write MaximumBlocks (4 bytes)
        if err := binary.Write(buf, binary.LittleEndian, req.ServiceIndex); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Write HeaderHash (32 bytes for common.Hash)
        <span class="cov0" title="0">if _, err := buf.Write(req.PreimageHash[:]); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Write MaximumBlocks (4 bytes)
        <span class="cov0" title="0">if err := binary.Write(buf, binary.LittleEndian, req.PreimageLen); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// Deserialize function to convert a byte array back into a JAMSNPBlockRequest struct
func (req *PreimageAnnouncement) FromBytes(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // Read ServiceID (4 bytes)
        if err := binary.Read(buf, binary.LittleEndian, &amp;req.ServiceIndex); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Read PreimageHash (32 bytes)
        <span class="cov0" title="0">if _, err := buf.Read(req.PreimageHash[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Read PreimageLen (4 bytes)
        <span class="cov0" title="0">if err := binary.Read(buf, binary.LittleEndian, &amp;req.PreimageLen); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package types

import (
        //"encoding/binary"
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

/*
Section 12.1. Preimage Integration. Prior to accumulation, we must first integrate all preimages provided in the lookup extrinsic. The lookup extrinsic is a sequence of pairs of service indices and data. These pairs must be ordered and without duplicates (equation 154 requires this). The data must have been solicited by a service but not yet be provided.  See equations 153-155.

`PreimageExtrinsic` ${\bf E}_P$:
*/
// LookupEntry represents a single entry in the lookup extrinsic.
type Preimages struct {
        Requester uint32 `json:"requester"`
        Blob      []byte `json:"blob"`
}

func (p *Preimages) BlobHash() common.Hash <span class="cov0" title="0">{
        return common.BytesToHash(common.ComputeHash(p.Blob))
}</span>

func (p *Preimages) BlobLength() uint32 <span class="cov0" title="0">{
        return uint32(len(p.Blob))
}</span>

func (p *Preimages) Service_Index() uint32 <span class="cov0" title="0">{
        return p.Requester
}</span>

func (p *Preimages) String() string <span class="cov0" title="0">{
        s := fmt.Sprintf("ServiceIndex=%v, (h,z)=(%v,%v), a_l=%v, a_p=%v\n", p.Service_Index(), p.BlobHash(), p.BlobLength(), p.AccountLookupHash(), p.AccountPreimageHash())
        return s
}</span>

// A_l --- C(s, (E4(l) ⌢ (¬h4:))
func (p *Preimages) AccountLookupHash() common.Hash <span class="cov0" title="0">{
        s := p.Requester
        blob_hash := p.BlobHash().Bytes()
        blob_len := p.BlobLength()
        return ComputeAL(s, blob_hash, blob_len)
}</span>

// A_p --- c(s, H(p))
func (p *Preimages) AccountPreimageHash() common.Hash <span class="cov0" title="0">{
        s := p.Requester
        blob_hash := p.BlobHash().Bytes()
        return ComputeAP(s, blob_hash)
}</span>

func ComputeAP(s uint32, blob_hash []byte) common.Hash <span class="cov0" title="0">{
        blobHash := common.Blake2Hash(blob_hash)
        ap_internal_key := common.Compute_preimageBlob_internal(blobHash)
        account_preimage_hash := common.ComputeC_sh(s, ap_internal_key)
        return account_preimage_hash
}</span>

func ComputeAL(s uint32, blob_hash []byte, blob_len uint32) common.Hash <span class="cov0" title="0">{
        blobHash := common.Blake2Hash(blob_hash)
        al_internal_key := common.Compute_preimageLookup_internal(blobHash, blob_len)
        account_lookuphash := common.ComputeC_sh(s, al_internal_key) // C(s, (h,l))
        return account_lookuphash
}</span>

func (p Preimages) DeepCopy() (Preimages, error) <span class="cov0" title="0">{
        var copiedPreimageLookup Preimages

        // Serialize the original PreimageLookup to JSON
        data, err := Encode(p)
        if err != nil </span><span class="cov0" title="0">{
                return copiedPreimageLookup, err
        }</span>

        // Deserialize the JSON back into a new PreimageLookup instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Preimages{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedPreimageLookup, err
        }</span>
        <span class="cov0" title="0">copiedPreimageLookup = decoded.(Preimages)

        return copiedPreimageLookup, nil</span>
}

// Bytes returns the bytes of the PreimageLookup.
func (p *Preimages) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (p *Preimages) Hash() common.Hash <span class="cov0" title="0">{
        data := p.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}

func (a *Preimages) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type Alias Preimages
        aux := &amp;struct {
                *Alias
                Blob string `json:"blob"`
        }{
                Alias: (*Alias)(a),
        }
        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">blobBytes := common.FromHex(aux.Blob)
        a.Blob = blobBytes
        return nil</span>
}

func (a Preimages) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias Preimages
        blob := common.HexString(a.Blob)
        return json.Marshal(&amp;struct {
                *Alias
                Blob string `json:"blob"`
        }{
                Alias: (*Alias)(&amp;a),
                Blob:  blob,
        })
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">package types

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "fmt"

        "github.com/colorfulnotion/jam/common"
)

const (
        ServiceAccountPrefix = 255
)

const (
        EntryPointRefine        = 5
        EntryPointAccumulate    = 10
        EntryPointOnTransfer    = 15
        EntryPointAuthorization = 0
        EntryPointGeneric       = 255
)

// ServiceAccount represents a service account.
type ServiceAccount struct {
        ServiceIndex    uint32      `json:"service_index"`
        CodeHash        common.Hash `json:"code_hash"`    //a_c - account code hash c
        Balance         uint64      `json:"balance"`      //a_b - account balance b, which must be greater than a_t (The threshold needed in terms of its storage footprint)
        GasLimitG       uint64      `json:"min_item_gas"` //a_g - the minimum gas required in order to execute the Accumulate entry-point of the service's code,
        GasLimitM       uint64      `json:"min_memo_gas"` //a_m - the minimum required for the On Transfer entry-point.
        StorageSize     uint64      `json:"code_size"`    //a_l - total number of octets used in storage (9.3)
        NumStorageItems uint32      `json:"items"`        //a_i - the number of items in storage (9.3)

        // X.D will have Mutable=false, but X.D.U will have Mutable=True
        Mutable bool `json:"mutable"`

        Dirty    bool
        Storage  map[common.Hash]StorageObject  `json:"s_map"` // arbitrary_k -&gt; v. if v=[]byte. use as delete
        Lookup   map[common.Hash]LookupObject   `json:"l_map"` // (h,l) -&gt; anchor
        Preimage map[common.Hash]PreimageObject `json:"p_map"` // H(p)  -&gt; p
}

func (s *ServiceAccount) Clone() *ServiceAccount <span class="cov0" title="0">{
        // Start by cloning primitive fields directly
        clone := ServiceAccount{
                ServiceIndex:    s.ServiceIndex,
                CodeHash:        s.CodeHash,
                Balance:         s.Balance,
                GasLimitG:       s.GasLimitG,
                GasLimitM:       s.GasLimitM,
                StorageSize:     s.StorageSize,
                NumStorageItems: s.NumStorageItems,
                Dirty:           s.Dirty,
                Mutable:         false, // must use ALLOW_MUTABLE explicitly
        }

        // Clone the Storage map
        clone.Storage = make(map[common.Hash]StorageObject, len(s.Storage))
        for k, v := range s.Storage </span><span class="cov0" title="0">{
                clone.Storage[k] = v.Clone() // Assuming StorageObject has a Clone method
        }</span>

        // Clone the Lookup map
        <span class="cov0" title="0">clone.Lookup = make(map[common.Hash]LookupObject, len(s.Lookup))
        for k, v := range s.Lookup </span><span class="cov0" title="0">{
                clone.Lookup[k] = v.Clone() // Assuming LookupObject has a Clone method
        }</span>

        // Clone the Preimage map
        <span class="cov0" title="0">clone.Preimage = make(map[common.Hash]PreimageObject, len(s.Preimage))
        for k, v := range s.Preimage </span><span class="cov0" title="0">{
                clone.Preimage[k] = v.Clone() // Assuming PreimageObject has a Clone method
        }</span>

        <span class="cov0" title="0">return &amp;clone</span>
}

type StorageObject struct {
        Deleted bool
        Dirty   bool
        Value   []byte `json:"value"`  // v
        RawKey  []byte `json:"rawkey"` // rawKey
}

func (o StorageObject) Clone() StorageObject <span class="cov0" title="0">{
        // Deep copy the Value slice
        valueCopy := make([]byte, len(o.Value))
        copy(valueCopy, o.Value)

        return StorageObject{
                Deleted: o.Deleted,
                Dirty:   o.Dirty,
                Value:   valueCopy,
        }
}</span>

type LookupObject struct {
        Deleted bool
        Dirty   bool
        Z       uint32   `json:"z"` // z
        T       []uint32 `json:"t"` // t
}

func (o LookupObject) Clone() LookupObject <span class="cov0" title="0">{
        // Deep copy the T slice
        tCopy := make([]uint32, len(o.T))
        copy(tCopy, o.T)

        return LookupObject{
                Deleted: o.Deleted,
                Dirty:   o.Dirty,
                Z:       o.Z,
                T:       tCopy,
        }
}</span>

type PreimageObject struct {
        Deleted  bool
        Dirty    bool
        Preimage []byte `json:"preimage"` // p
}

func (o PreimageObject) Clone() PreimageObject <span class="cov0" title="0">{
        // Deep copy the Preimage slice
        preimageCopy := make([]byte, len(o.Preimage))
        copy(preimageCopy, o.Preimage)

        return PreimageObject{
                Deleted:  o.Deleted,
                Dirty:    o.Dirty,
                Preimage: preimageCopy,
        }
}</span>

// Convert the ServiceAccount to a byte slice.
// ac ⌢ E8(ab,ag,am,al) ⌢ E4(ai)
// 32 + 8*4 + 4 = 68
// TODO: Need codec E here

// Bytes encodes the AccountState as a byte slice
func (s *ServiceAccount) Bytes() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        if _, err := buf.Write(s.CodeHash.Bytes()); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">writeUint64 := func(value uint64) error </span><span class="cov0" title="0">{
                return binary.Write(&amp;buf, binary.LittleEndian, value)
        }</span>

        <span class="cov0" title="0">writeUint32 := func(value uint32) error </span><span class="cov0" title="0">{
                return binary.Write(&amp;buf, binary.LittleEndian, value)
        }</span>

        <span class="cov0" title="0">if err := writeUint64(s.Balance); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := writeUint64(s.GasLimitG); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := writeUint64(s.GasLimitM); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := writeUint64(s.StorageSize); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := writeUint32(s.NumStorageItems); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// Recover reconstructs an AccountState from a byte slice
func (s *ServiceAccount) Recover(data []byte) error <span class="cov0" title="0">{
        // Ensure the length of the data is correct
        expectedLen := 32 + 8*4 + 4 // 32 bytes for CodeHash, 4 * 8 bytes for uint64, 4 bytes for uint32
        if len(data) != expectedLen </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid data length: expected %d, got %d", expectedLen, len(data))
        }</span>

        // Create a reader from the data
        <span class="cov0" title="0">buf := bytes.NewReader(data)

        // Read CodeHash (32 bytes)
        codeHashBytes := make([]byte, 32)
        if _, err := buf.Read(codeHashBytes); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.CodeHash = common.BytesToHash(codeHashBytes)

        readUint64 := func() (uint64, error) </span><span class="cov0" title="0">{
                var value uint64
                err := binary.Read(buf, binary.LittleEndian, &amp;value)
                return value, err
        }</span>
        <span class="cov0" title="0">readUint32 := func() (uint32, error) </span><span class="cov0" title="0">{
                var value uint32
                err := binary.Read(buf, binary.LittleEndian, &amp;value)
                return value, err
        }</span>
        <span class="cov0" title="0">var err error
        if s.Balance, err = readUint64(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s.GasLimitG, err = readUint64(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s.GasLimitM, err = readUint64(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s.StorageSize, err = readUint64(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if s.NumStorageItems, err = readUint32(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func AccountStateFromBytes(service_index uint32, data []byte) (*ServiceAccount, error) <span class="cov0" title="0">{
        acct := ServiceAccount{}
        if err := acct.Recover(data); err != nil </span><span class="cov0" title="0">{
                fmt.Println("Error recovering:", err)
                return nil, err
        }</span>
        <span class="cov0" title="0">acct.ServiceIndex = service_index
        return &amp;acct, nil</span>
}

func (s *ServiceAccount) GetServiceIndex() uint32 <span class="cov0" title="0">{
        return s.ServiceIndex
}</span>

func (s *ServiceAccount) ALLOW_MUTABLE() <span class="cov0" title="0">{
        s.Mutable = true
}</span>

func ServiceAccountFromBytes(service_index uint32, state_data []byte) (*ServiceAccount, error) <span class="cov0" title="0">{
        // Convert the internal state from bytes
        acctState, err := AccountStateFromBytes(service_index, state_data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        // Initialize a new ServiceAccount and copy the relevant fields
        <span class="cov0" title="0">serviceAccount := &amp;ServiceAccount{
                ServiceIndex:    service_index,
                CodeHash:        acctState.CodeHash,
                Balance:         acctState.Balance,
                GasLimitG:       acctState.GasLimitG,
                GasLimitM:       acctState.GasLimitM,
                StorageSize:     acctState.StorageSize,
                NumStorageItems: acctState.NumStorageItems,
                Mutable:         false, // THIS THE DEFAULT
                // Initialize maps to avoid nil reference errors
                Storage:  make(map[common.Hash]StorageObject),
                Lookup:   make(map[common.Hash]LookupObject),
                Preimage: make(map[common.Hash]PreimageObject),
        }
        return serviceAccount, nil</span>
}

// Convert the ServiceAccount to a human-readable string.
func (s *ServiceAccount) String() string <span class="cov0" title="0">{
        // Initial account information
        str := fmt.Sprintf("ServiceAccount %d CodeHash: %v B=%v, G=%v M=%v L=%v, I=%v [Mutable: %v]\n",
                s.ServiceIndex, s.CodeHash.Hex(), s.Balance, s.GasLimitG, s.GasLimitM, s.StorageSize, s.NumStorageItems, s.Mutable)

        // Lookup entries
        str2 := ""
        for h, lo := range s.Lookup </span><span class="cov0" title="0">{
                str2 += fmt.Sprintf("  Lookup: %v =&gt; %v\n", h, lo)
        }</span>

        // Preimage entries
        <span class="cov0" title="0">str3 := ""
        for h, lo := range s.Preimage </span><span class="cov0" title="0">{
                str3 += fmt.Sprintf("  Preimage: %v =&gt; %v\n", h, lo)
        }</span>

        // Storage entries
        <span class="cov0" title="0">str4 := ""
        for h, lo := range s.Storage </span><span class="cov0" title="0">{
                str4 += fmt.Sprintf("  Storage: %v =&gt; %v\n", h, lo)
        }</span>
        <span class="cov0" title="0">return str + str2 + str3 + str4</span>
}

func (s *ServiceAccount) ReadStorage(rawK []byte, sdb HostEnv) (ok bool, v []byte) <span class="cov0" title="0">{
        serviceIndex := s.ServiceIndex
        hk := common.Compute_storageKey_internal(serviceIndex, rawK)
        storageObj, ok := s.Storage[hk]
        if storageObj.Deleted </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                var err error
                v, ok, err = sdb.ReadServiceStorage(serviceIndex, rawK)
                if err != nil || !ok </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">s.Storage[hk] = StorageObject{
                        Dirty:  false,
                        Value:  v,
                        RawKey: rawK,
                }
                return true, v</span>
        }
        <span class="cov0" title="0">return true, storageObj.Value</span>
}

func (s *ServiceAccount) ReadPreimage(blobHash common.Hash, sdb HostEnv) (ok bool, preimage []byte) <span class="cov0" title="0">{
        preimageObj, ok := s.Preimage[blobHash]
        if preimageObj.Deleted </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                var err error
                preimage, ok, err = sdb.ReadServicePreimageBlob(s.GetServiceIndex(), blobHash)
                if err != nil || !ok </span><span class="cov0" title="0">{
                        return false, preimage //, err
                }</span>
                <span class="cov0" title="0">s.Preimage[blobHash] = PreimageObject{
                        Dirty:    false,
                        Preimage: preimage,
                }
                return true, preimage</span>
        }
        <span class="cov0" title="0">return true, preimageObj.Preimage</span>
}

func (s *ServiceAccount) ReadLookup(blobHash common.Hash, z uint32, sdb HostEnv) (ok bool, anchor_timeslot []uint32) <span class="cov0" title="0">{
        lookupObj, ok := s.Lookup[blobHash]
        if lookupObj.Deleted </span><span class="cov0" title="0">{
                return false, []uint32{}
        }</span>
        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                var err error
                anchor_timeslot, ok, err = sdb.ReadServicePreimageLookup(s.GetServiceIndex(), blobHash, z)
                if err != nil || !ok </span><span class="cov0" title="0">{
                        return ok, anchor_timeslot
                }</span>
                <span class="cov0" title="0">s.Lookup[blobHash] = LookupObject{
                        Dirty: false,
                        Z:     z,
                        T:     anchor_timeslot,
                }
                return true, anchor_timeslot</span>
        }
        <span class="cov0" title="0">return true, lookupObj.T</span>
}

// a_c - account code hash c
func (s *ServiceAccount) SetCodeHash(codeHash common.Hash) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetCodeHash")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.CodeHash = codeHash</span>
}

// a_b - account balance b, which must be greater than a_t (The threshold needed in terms of its storage footprint)
// Note this could be IncBalance DecBalance instead?
func (s *ServiceAccount) DecBalance(balance uint64) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetBalance")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.Balance -= balance</span>
}
func (s *ServiceAccount) IncBalance(balance uint64) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetBalance")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.Balance += balance</span>
}

// a_g - the minimum gas required in order to execute the Accumulate entry-point of the service's code,
func (s *ServiceAccount) SetGasLimitG(g uint64) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetGasLimitG")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.GasLimitG = g</span>
}

// a_m - the minimum required for the On Transfer entry-point.
func (s *ServiceAccount) SetGasLimitM(g uint64) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetGasLimitM")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.GasLimitM = g</span>
}

// a_l - total number of octets used in storage (9.3)
func (s *ServiceAccount) SetStorageSize(storageSize uint64) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetStorageSize")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.StorageSize = storageSize</span>
}

// a_i - the number of items in storage (9.3)
func (s *ServiceAccount) SetNumStorageItems(numStorageItems uint32) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("SetNumStorageItems")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.NumStorageItems = numStorageItems</span>
}

func (s *ServiceAccount) WriteStorage(serviceIndex uint32, rawK []byte, val []byte) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("Called WriteStorage on immutable ServiceAccount")</span>
        }
        // k for original raw key, hk for hash key
        // serviceIndex := s.ServiceIndex
        <span class="cov0" title="0">hk := common.Compute_storageKey_internal(serviceIndex, rawK)
        s.Dirty = true
        s.Storage[hk] = StorageObject{
                Dirty:   true,
                Deleted: len(val) == 0,
                Value:   val,
                RawKey:  rawK,
        }</span>
}

func (s *ServiceAccount) WritePreimage(blobHash common.Hash, preimage []byte) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("Called WriteStorage on immutable ServiceAccount")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.Preimage[blobHash] = PreimageObject{
                Dirty:    true,
                Deleted:  len(preimage) == 0,
                Preimage: preimage,
        }</span>
}

func (s *ServiceAccount) WriteLookup(blobHash common.Hash, z uint32, time_slots []uint32) <span class="cov0" title="0">{
        if s.Mutable == false </span><span class="cov0" title="0">{
                panic("Called WriteStorage on immutable ServiceAccount")</span>
        }
        <span class="cov0" title="0">s.Dirty = true
        s.Lookup[blobHash] = LookupObject{
                Dirty:   true,
                Deleted: false, // WAS len(time_slots) == 0,
                Z:       z,
                T:       time_slots,
        }</span>

}

// eq 95
func (s *ServiceAccount) ComputeThreshold() uint64 <span class="cov0" title="0">{
        //BS +BI ⋅ai +BL ⋅al
        account_threshold := BaseServiceBalance + MinElectiveServiceItemBalance*uint64(s.NumStorageItems) + MinElectiveServiceOctetBalance*s.StorageSize
        return account_threshold
}</span>

func (s *ServiceAccount) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias ServiceAccount
        return json.Marshal(&amp;struct {
                *Alias
                CodeHash string                    `json:"code_hash"`
                Storage  map[string]StorageObject  `json:"s_map"`
                Lookup   map[string]LookupObject   `json:"l_map"`
                Preimage map[string]PreimageObject `json:"p_map"`
        }{
                Alias:    (*Alias)(s),
                CodeHash: s.CodeHash.Hex(),
                Storage:  convertHashMapToStringMap(s.Storage),
                Lookup:   convertHashMapToStringMap(s.Lookup),
                Preimage: convertHashMapToStringMap(s.Preimage),
        })
}</span>

func (s *ServiceAccount) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias ServiceAccount
        aux := &amp;struct {
                *Alias
                CodeHash string                    `json:"code_hash"`
                Storage  map[string]StorageObject  `json:"s_map"`
                Lookup   map[string]LookupObject   `json:"l_map"`
                Preimage map[string]PreimageObject `json:"p_map"`
        }{
                Alias: (*Alias)(s),
        }
        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">s.CodeHash = common.HexToHash(aux.CodeHash)
        s.Storage = convertStringMapToHashMap(aux.Storage)
        s.Lookup = convertStringMapToHashMap(aux.Lookup)
        s.Preimage = convertStringMapToHashMap(aux.Preimage)
        return nil</span>
}

func convertHashMapToStringMap[T any](input map[common.Hash]T) map[string]T <span class="cov0" title="0">{
        output := make(map[string]T, len(input))
        for k, v := range input </span><span class="cov0" title="0">{
                output[k.Hex()] = v
        }</span>
        <span class="cov0" title="0">return output</span>
}

func convertStringMapToHashMap[T any](input map[string]T) map[common.Hash]T <span class="cov0" title="0">{
        output := make(map[common.Hash]T, len(input))
        for k, v := range input </span><span class="cov0" title="0">{
                output[common.HexToHash(k)] = v
        }</span>
        <span class="cov0" title="0">return output</span>
}

func (s *ServiceAccount) JsonString() string <span class="cov0" title="0">{
        jsonBytes, err := s.MarshalJSON()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("Error marshalling ServiceAccount: %v", err)
        }</span>
        <span class="cov0" title="0">return string(jsonBytes)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package types

import (
        "encoding/binary"
        "io"

        "bytes"
)

type StateKeyValueList struct {
        Items []StateKeyValue
}

type StateKeyValue struct {
        Key   [31]byte `json:"key"`
        Len   uint8    `json:"len"`
        Value []byte   `json:"value"`
}

// ToBytes serializes the JAMSNPStateKeyValue struct into a byte array
func (kvs *StateKeyValueList) ToBytes() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        for _, kv := range kvs.Items </span><span class="cov0" title="0">{
                // Serialize Key (31 bytes)
                if _, err := buf.Write(kv.Key[:]); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Serialize Len (1 byte, uint8)
                <span class="cov0" title="0">if err := buf.WriteByte(kv.Len); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Serialize Value length (4 bytes for uint32 length)
                <span class="cov0" title="0">valueLength := uint32(len(kv.Value))
                if err := binary.Write(buf, binary.BigEndian, valueLength); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Serialize Value (dynamically sized based on length)
                <span class="cov0" title="0">if _, err := buf.Write(kv.Value); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// FromBytes deserializes a byte array into a JAMSNPStateKeyValue struct
func (kv *StateKeyValue) FromBytes(data []byte) error <span class="cov0" title="0">{
        buf := bytes.NewReader(data)

        // Deserialize Key (31 bytes)
        if _, err := io.ReadFull(buf, kv.Key[:]); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deserialize Len (1 byte)
        <span class="cov0" title="0">lenByte, err := buf.ReadByte()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">kv.Len = lenByte

        // Deserialize Value length (4 bytes)
        var valueLength uint32
        if err := binary.Read(buf, binary.BigEndian, &amp;valueLength); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Deserialize Value (dynamically sized)
        <span class="cov0" title="0">kv.Value = make([]byte, valueLength)
        if _, err := io.ReadFull(buf, kv.Value); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/bandersnatch"
        "github.com/colorfulnotion/jam/common"
)

/*
Section 6.7 - Equation 73.  Ticket Extrinsic is a *sequence* of proofs of valid tickets, each of which is a tuple of an entry index (a natural number less than N) and a proof of ticket validity.
*/

type Ticket struct {
        Attempt   uint8                     `json:"attempt"`
        Signature BandersnatchRingSignature `json:"signature"`
}

func (t Ticket) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias Ticket
        return json.Marshal(&amp;struct {
                *Alias
                Signature string `json:"signature"`
        }{
                Alias:     (*Alias)(&amp;t),
                Signature: common.HexString(t.Signature[:]),
        })
}</span>

func (t *Ticket) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type Alias Ticket
        aux := &amp;struct {
                *Alias
                Signature string `json:"signature"`
        }{
                Alias: (*Alias)(t),
        }
        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">sigBytes := common.FromHex(aux.Signature)
        copy(t.Signature[:], sigBytes)
        return nil</span>
}

func (t Ticket) DeepCopy() (Ticket, error) <span class="cov0" title="0">{
        var copiedTicket Ticket

        // Serialize the original Ticket to JSON
        data, err := Encode(t)
        if err != nil </span><span class="cov0" title="0">{
                return copiedTicket, err
        }</span>

        // Deserialize the JSON back into a new Ticket instance
        <span class="cov0" title="0">decoded, _, err := Decode(data, reflect.TypeOf(Ticket{}))
        if err != nil </span><span class="cov0" title="0">{
                return copiedTicket, err
        }</span>
        <span class="cov0" title="0">copiedTicket = decoded.(Ticket)

        return copiedTicket, nil</span>
}

func (t Ticket) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Ticket{Attempt: %d, Signature: %s}", t.Attempt, common.HexString(t.Signature[:]))
}</span>

func (t *Ticket) TicketIDWithCheck() (common.Hash, error) <span class="cov0" title="0">{
        ticket_id, err := bandersnatch.VRFSignedOutput(t.Signature[:])
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, fmt.Errorf("invalid ticket_id err=%v", err)
        }</span>
        <span class="cov0" title="0">return common.BytesToHash(ticket_id), err</span>
}

func (t *Ticket) TicketID() (common.Hash, error) <span class="cov0" title="0">{
        ticket_id, err := bandersnatch.VRFSignedOutput(t.Signature[:])
        if err != nil </span><span class="cov0" title="0">{
                return common.Hash{}, fmt.Errorf("invalid ticket_id err=%v", err)
        }</span>
        <span class="cov0" title="0">return common.BytesToHash(ticket_id), nil</span>
}

func (t *Ticket) Bytes() ([]byte, error) <span class="cov0" title="0">{
        return t.BytesWithSig(), nil
}</span>

func (t *Ticket) UnsignedHash() common.Hash <span class="cov0" title="0">{
        unsignedBytes := t.BytesWithoutSig()
        return common.Blake2Hash(unsignedBytes)
}</span>

func (t *Ticket) Hash() common.Hash <span class="cov0" title="0">{
        data := t.BytesWithSig()
        return common.Blake2Hash(data)
}</span>

func (t *Ticket) BytesWithSig() []byte <span class="cov0" title="0">{
        enc, err := Encode(t)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (t *Ticket) BytesWithoutSig() []byte <span class="cov0" title="0">{
        s := struct {
                Attempt uint8 `json:"attempt"`
        }{
                Attempt: t.Attempt,
        }
        enc, err := Encode(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">fmt.Printf("BytesWithoutSig %x\n", enc)
        return enc</span>
}

// shawn added ticket bucket to store tickets for node itself

type TicketBucket struct {
        Ticket         Ticket
        IsIncluded     *bool
        IsBroadcasted  *bool
        GeneratedEpoch uint32
}

func (t *Ticket) TicketToBucket(epoch uint32) TicketBucket <span class="cov0" title="0">{
        return TicketBucket{
                Ticket:         *t,
                IsIncluded:     new(bool),
                IsBroadcasted:  new(bool),
                GeneratedEpoch: epoch,
        }
}</span>

func TicketsToBuckets(tickets []Ticket, epoch uint32) []TicketBucket <span class="cov0" title="0">{
        bucket := make([]TicketBucket, len(tickets))
        for i := range tickets </span><span class="cov0" title="0">{
                bucket[i] = tickets[i].TicketToBucket(epoch)
        }</span>
        <span class="cov0" title="0">return bucket</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package types

import (
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

// TicketBody represents the structure of a ticket
type TicketBody struct {
        Id      common.Hash `json:"id"`
        Attempt uint8       `json:"attempt"`
}

type TicketsMark [EpochLength]TicketBody

func (T *TicketsMark) Encode() []byte <span class="cov8" title="1">{
        if T == nil </span><span class="cov8" title="1">{
                return []byte{0}
        }</span>
        <span class="cov8" title="1">v := reflect.ValueOf(*T)
        encoded := []byte{1}
        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                encodedV, err := Encode(v.Index(i).Interface())
                if err != nil </span><span class="cov0" title="0">{
                        return []byte{}
                }</span>
                <span class="cov8" title="1">encoded = append(encoded, encodedV...)</span>
        }
        <span class="cov8" title="1">return encoded</span>
}

func (target *TicketsMark) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        if data[0] == 0 </span><span class="cov8" title="1">{
                return nil, 1
        }</span>
        <span class="cov8" title="1">var decoded TicketsMark
        length := uint32(1)
        for i := 0; i &lt; EpochLength; i++ </span><span class="cov8" title="1">{
                elem, l, err := Decode(data[length:], reflect.TypeOf(TicketBody{}))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, length
                }</span>
                <span class="cov8" title="1">decoded[i] = elem.(TicketBody)
                length += l</span>
        }
        <span class="cov8" title="1">return &amp;decoded, length</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package types

import "reflect"

type TransferMemo struct {
        S uint32
        D uint32
        A uint32
        M uint32
        G uint32
}

// Create a TransferMemo from a byte slice.
func TransferMemoFromBytes(data []byte) (*TransferMemo, error) <span class="cov0" title="0">{
        var t TransferMemo
        // Deserialize the JSON bytes into a ServiceAccount struct
        decoded, _, err := Decode(data, reflect.TypeOf(TransferMemo{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">t = decoded.(TransferMemo)
        return &amp;t, nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">package types

import (
        "encoding/json"
        "math"

        "github.com/colorfulnotion/jam/common"
)

type BMTProof []common.Hash

const (
        // tiny
        validatorCount = 12
        // full
        // validatorCount = 1023
        coreCount      = 341
        epochLength    = 600
        rotationPeriod = 10
)

const (
        InfinityError = "∞"
        ZeroError     = "∅"
        BadError      = "BAD"
        BigError      = "BIG"
)

// ----------------------------------------------

type BlockQuery struct {
        BlockHash common.Hash `json:"block_hash"`
}

type ConformantECChunk struct {
        Data       []byte `json:"data"`
        ShardIndex uint32 `json:"shardIdx"`
}

// Marshal marshals ConformantECChunk into JSON
func (c *ConformantECChunk) Marshal() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(c)
}</span>

// Unmarshal unmarshals JSON data into DistributeECChunk
func (c *ConformantECChunk) Unmarshal(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, c)
}</span>

func (c *ConformantECChunk) Bytes() []byte <span class="cov0" title="0">{
        jsonData, _ := c.Marshal()
        return jsonData
}</span>

func (c *ConformantECChunk) String() string <span class="cov0" title="0">{
        return string(c.Bytes())
}</span>

type DistributeECChunk struct {
        SegmentRoot []byte      `json:"segment_root"`
        Data        []byte      `json:"data"`
        RootHash    common.Hash `json:"root_hash"`
        BlobMeta    []byte      `json:"blob_meta"`
}

// Marshal marshals DistributeECChunk into JSON
func (d *DistributeECChunk) Marshal() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(d)
}</span>

// Unmarshal unmarshals JSON data into DistributeECChunk
func (d *DistributeECChunk) Unmarshal(data []byte) error <span class="cov0" title="0">{
        return json.Unmarshal(data, d)
}</span>

func (d *DistributeECChunk) Bytes() []byte <span class="cov0" title="0">{
        jsonData, _ := d.Marshal()
        return jsonData
}</span>

func (d *DistributeECChunk) String() string <span class="cov0" title="0">{
        return string(d.Bytes())
}</span>

type ECChunkResponse struct {
        SegmentRoot []byte `json:"segment_root"`
        Data        []byte `json:"data"`
}

type ECChunkQuery struct {
        SegmentRoot common.Hash `json:"segment_root"`
}

// AccumulationState represents the state required for accumulation.
type AccumulationState struct {
        ServiceIndices    []int              `json:"service_indices"`
        WorkReports       []WorkReport       `json:"work_reports"`
        DeferredTransfers []DeferredTransfer `json:"deferred_transfers"`
}

// ValidatorStatistics represents the statistics tracked for each validator.
/*
type ValidatorStatistics struct {
        BlocksProduced         int `json:"blocks_produced"`
        TicketsIntroduced      int `json:"tickets_introduced"`
        PreimagesIntroduced    int `json:"preimages_introduced"`
        OctetsIntroduced       int `json:"octets_introduced"`
        ReportsGuaranteed      int `json:"reports_guaranteed"`
        AvailabilityAssurances int `json:"availability_assurances"`
}

// StatisticalReporter represents the statistics for the current and previous epochs.
type StatisticalReporter struct {
        CurrentEpochStats  []ValidatorStatistics `json:"current_epoch_stats"`
        PreviousEpochStats []ValidatorStatistics `json:"previous_epoch_stats"`
}
*/

// GasAttributable represents the gas attributable for each service.
type GasAttributable struct {
        ServiceIndex int     `json:"service_index"`
        Gas          float64 `json:"gas"`
}

func ComputeC_Base(blob_length int) int <span class="cov0" title="0">{
        c := int(math.Ceil(float64(blob_length) / float64(W_E)))
        return c
}</span>

// For BPT
type BPTNode struct {
        Value []byte `json:"value"`
        Key   []byte `json:"key"`
}

// ----------map[common.Hash]common.Hash----------

type Hash2Hash map[common.Hash]common.Hash

/*
// ---use dictionary---
// MarshalJSON serializes Hash2Hash as a map[string]string
func (h Hash2Hash) MarshalJSON() ([]byte, error) {
        stringMap := make(map[string]string)
        for k, v := range h {
                stringMap[k.Hex()] = v.Hex() // Convert keys and values to hex strings
        }
        return json.Marshal(stringMap)
}

UnmarshalJSON deserializes Hash2Hash from a map[string]string
func (h *Hash2Hash) UnmarshalJSON(data []byte) error {
        stringMap := make(map[string]string)
        if err := json.Unmarshal(data, &amp;stringMap); err != nil {
                return err
        }
        *h = make(Hash2Hash)
        for k, v := range stringMap {
                keyHash := common.HexToHash(k) // Convert hex strings back to common.Hash
                valueHash := common.HexToHash(v)
                (*h)[keyHash] = valueHash
        }
        return nil
}
*/

// ---use pair---
// MarshalJSON serializes Hash2Hash as a slice of pairs
func (h Hash2Hash) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        pairs := make([][2]common.Hash, 0, len(h))
        for k, v := range h </span><span class="cov8" title="1">{
                pairs = append(pairs, [2]common.Hash{k, v})
        }</span>
        <span class="cov8" title="1">return json.Marshal(pairs)</span>
}

// UnmarshalJSON deserializes Hash2Hash from a slice of pairs
func (h *Hash2Hash) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var pairs [][2]common.Hash
        if err := json.Unmarshal(data, &amp;pairs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">*h = make(Hash2Hash)
        for _, pair := range pairs </span><span class="cov8" title="1">{
                (*h)[pair[0]] = pair[1]
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

type Validator struct {
        Bandersnatch BandersnatchKey           `json:"bandersnatch"`
        Ed25519      Ed25519Key                `json:"ed25519"`
        Bls          [BlsPubInBytes]byte       `json:"bls"`
        Metadata     [MetadataSizeInBytes]byte `json:"metadata"`
}
type Validators []Validator

func GetValidatorsLength(v Validators) int <span class="cov0" title="0">{
        var tmp []Validator
        tmp = v
        return len(tmp)
}</span>

type ValidatorSecret struct {
        BandersnatchPub    BandersnatchKey           `json:"bandersnatch"`
        Ed25519Pub         Ed25519Key                `json:"ed25519"`
        BlsPub             [BlsPubInBytes]byte       `json:"bls"`
        Metadata           [MetadataSizeInBytes]byte `json:"metadata"`
        BandersnatchSecret []byte                    `json:"bandersnatch_priv"`
        Ed25519Secret      [Ed25519PrivInBytes]byte  `json:"ed25519_priv"`
        BlsSecret          [BlsPrivInBytes]byte      `json:"bls_priv"`
}

func (v *Validator) GetEd25519Key() Ed25519Key <span class="cov0" title="0">{
        return v.Ed25519
}</span>

func (v Validator) GetBandersnatchKey() BandersnatchKey <span class="cov0" title="0">{
        return v.Bandersnatch
}</span>

func (v Validator) Bytes() []byte <span class="cov0" title="0">{
        bytes, err := Encode(v)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return bytes</span>
}

func ValidatorFromBytes(data []byte) (Validator, error) <span class="cov0" title="0">{
        var v Validator
        decoded, _, err := Decode(data, reflect.TypeOf(v))
        if err != nil </span><span class="cov0" title="0">{
                return v, err
        }</span>
        <span class="cov0" title="0">v = decoded.(Validator)
        return v, nil</span>
}

// MarshalJSON custom marshaler to convert byte arrays to hex strings
func (v Validator) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{

        return json.Marshal(&amp;struct {
                Bandersnatch BandersnatchKey `json:"bandersnatch"`
                Ed25519      Ed25519Key      `json:"ed25519"`
                Bls          string          `json:"bls"`
                Metadata     string          `json:"metadata"`
        }{
                Bandersnatch: v.Bandersnatch,
                Ed25519:      v.Ed25519,
                Bls:          common.Bytes2Hex(v.Bls[:]),
                Metadata:     common.Bytes2Hex(v.Metadata[:]),
        })
}</span>

func (v *Validator) Print() <span class="cov0" title="0">{
        // print JSON
        jsonBytes, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
        }</span>
        <span class="cov0" title="0">fmt.Println(string(jsonBytes))</span>
}

// UnmarshalJSON custom unmarshal method to handle hex strings for byte arrays
func (v *Validator) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        type Alias struct {
                Ed25519      Ed25519Key      `json:"ed25519"`
                Bandersnatch BandersnatchKey `json:"bandersnatch"`
        }

        aux := &amp;struct {
                Alias
                Bls      string `json:"bls"`
                Metadata string `json:"metadata"`
        }{}

        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">v.Ed25519 = aux.Ed25519
        v.Bandersnatch = aux.Bandersnatch

        bls_pub := common.Hex2Bytes(aux.Bls)
        meta := common.Hex2Bytes(aux.Metadata)

        if len(bls_pub) != BlsPubInBytes </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid length for bls field")
        }</span>

        <span class="cov0" title="0">if len(meta) != MetadataSizeInBytes </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid length for metadata field")
        }</span>

        <span class="cov0" title="0">copy(v.Bls[:], bls_pub)
        copy(v.Metadata[:], meta)

        return nil</span>
}

func (b *BandersnatchVrfSignature) Bytes() []byte <span class="cov0" title="0">{
        return b[:]
}</span>

func HexToBLS(hexStr string) [BlsPubInBytes]byte <span class="cov0" title="0">{
        b := common.Hex2Bytes(hexStr)
        var bls [BlsPubInBytes]byte
        copy(bls[:], b)
        return bls
}</span>

func HexToMetadata(hexStr string) [MetadataSizeInBytes]byte <span class="cov0" title="0">{
        b := common.Hex2Bytes(hexStr)
        var meta [MetadataSizeInBytes]byte
        copy(meta[:], b)
        return meta
}</span>

func (v ValidatorSecret) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        // Define an alias without the secret fields to prevent recursion
        type Alias struct {
                BandersnatchPub BandersnatchKey `json:"bandersnatch"`
                Ed25519Pub      Ed25519Key      `json:"ed25519"`
        }

        return json.Marshal(&amp;struct {
                Alias
                Bls                string `json:"bls"`
                Metadata           string `json:"metadata"`
                BandersnatchSecret string `json:"bandersnatch_priv"`
                Ed25519Secret      string `json:"ed25519_priv"`
                BlsSecret          string `json:"bls_priv"`
        }{
                Alias: Alias{
                        BandersnatchPub: v.BandersnatchPub,
                        Ed25519Pub:      v.Ed25519Pub,
                },
                Bls:                common.Bytes2Hex(v.BlsPub[:]),
                Metadata:           common.Bytes2Hex(v.Metadata[:]),
                BandersnatchSecret: common.Bytes2Hex(v.BandersnatchSecret),
                Ed25519Secret:      common.Bytes2Hex(v.Ed25519Secret[:]),
                BlsSecret:          common.Bytes2Hex(v.BlsSecret[:]),
        })
}</span>

func (v *ValidatorSecret) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        // Define an alias without the secret fields
        type Alias struct {
                BandersnatchPub BandersnatchKey `json:"bandersnatch"`
                Ed25519Pub      Ed25519Key      `json:"ed25519"`
        }

        aux := &amp;struct {
                Alias
                Bls                string `json:"bls"`
                Metadata           string `json:"metadata"`
                BandersnatchSecret string `json:"bandersnatch_priv"`
                Ed25519Secret      string `json:"ed25519_priv"`
                BlsSecret          string `json:"bls_priv"`
        }{}

        // Unmarshal the data into the auxiliary struct
        if err := json.Unmarshal(data, aux); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Assign the public keys from Alias
        <span class="cov0" title="0">v.BandersnatchPub = aux.BandersnatchPub
        v.Ed25519Pub = aux.Ed25519Pub

        bls_pub := common.Hex2Bytes(aux.Bls)
        metadata := common.Hex2Bytes(aux.Metadata)
        bandersnatch_secret := common.Hex2Bytes(aux.BandersnatchSecret)
        ed25519_secret := common.Hex2Bytes(aux.Ed25519Secret)
        bls_secret := common.Hex2Bytes(aux.BlsSecret)

        if len(bls_pub) != BlsPubInBytes </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid BlsPub length: expected %d bytes, got %d", BlsPubInBytes, len(bls_pub))
        }</span>

        <span class="cov0" title="0">if len(metadata) != MetadataSizeInBytes </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid Metadata length: expected %d bytes, got %d", metadata, len(metadata))
        }</span>

        <span class="cov0" title="0">copy(v.BlsPub[:], bls_pub)
        copy(v.Metadata[:], metadata)
        copy(v.BandersnatchSecret, bandersnatch_secret)
        copy(v.Ed25519Secret[:], ed25519_secret)
        copy(v.BlsSecret[:], bls_secret)
        return nil</span>
}

// C2 AuthQueue
func (T AuthorizationQueue) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        authorizations_queue := [TotalCores][MaxAuthorizationQueueItems]common.Hash{}
        decoded, length, err := Decode(data, reflect.TypeOf(authorizations_queue))
        if err != nil </span><span class="cov0" title="0">{
                return AuthorizationQueue{}, 0
        }</span>
        <span class="cov0" title="0">authorizations_queue = decoded.([TotalCores][MaxAuthorizationQueueItems]common.Hash)
        for i := 0; i &lt; TotalCores; i++ </span><span class="cov0" title="0">{
                if len(T[i]) == 0 </span><span class="cov0" title="0">{
                        var temp [6]common.Hash
                        T[i] = temp //        T[i] = make([]common.Hash, MaxAuthorizationQueueItems)
                }</span>

                <span class="cov0" title="0">for j := 0; j &lt; MaxAuthorizationQueueItems; j++ </span><span class="cov0" title="0">{
                        T[i][j] = authorizations_queue[i][j]
                }</span>
        }
        <span class="cov0" title="0">return T, length</span>
}

// validators
func (T Validators) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        if len(data) == 0 </span><span class="cov0" title="0">{
                return Validators{}, 0
        }</span>
        <span class="cov0" title="0">validators, length, err := Decode(data, reflect.TypeOf([TotalValidators]Validator{}))
        if err != nil </span><span class="cov0" title="0">{
                return Validators{}, 0
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; TotalValidators; i++ </span><span class="cov0" title="0">{
                T = append(T, validators.([TotalValidators]Validator)[i])
        }</span>
        <span class="cov0" title="0">return T, length</span>
}

// validators
func (T Validators) Encode() []byte <span class="cov0" title="0">{
        var validators [TotalValidators]Validator
        if len(T) == 0 || len(T) &gt; TotalValidators </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">copy(validators[:], T)
        encoded, err := Encode(validators)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

// C2
func (T AuthorizationQueue) Encode() []byte <span class="cov0" title="0">{
        authorizations_queue := [TotalCores][MaxAuthorizationQueueItems]common.Hash{}
        if len(T) == 0 || len(T) &gt; TotalCores </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">for i := 0; i &lt; len(T); i++ </span><span class="cov0" title="0">{
                copy(authorizations_queue[i][:], T[i][:])
                // copy(authorizations_queue[i][:], T[i])
        }</span>
        <span class="cov0" title="0">encoded, err := Encode(authorizations_queue)
        if err != nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">return encoded</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package types

import (
        "encoding/json"

        "github.com/colorfulnotion/jam/common"
)

/*
A work item includes: (See Equation 175)
* $s$, the identifier of the service to which it relates
* $c$, the code hash of the service at the time of reporting  (whose preimage must be available from the perspective of the lookup anchor block)
* ${\bf y}$, a payload blob
* $g$, a gas limit and
* the three elements of its manifest:
  - ${\bf i}$, a sequence of imported data segments identified by the root of the segments tree and an index into it;
  - ${\bf x}$, a sequence of hashes of data segments to be introduced in this block (and which we assume the validator knows);
  - $e$, the number of data segments exported by this work item
*/

type ExtrinsicsBlobs [][]byte

// WorkItem represents a work item.
type WorkItem struct {
        // s: the identifier of the service to which it relates
        Service uint32 `json:"service"`
        // c: the code hash of the service at the time of reporting
        CodeHash common.Hash `json:"code_hash"`
        // y: a payload blob
        Payload []byte `json:"payload"`
        // g: a refine gas limit
        RefineGasLimit uint64 `json:"refine_gas_limit"`
        // a: an accumulate gas limit
        AccumulateGasLimit uint64 `json:"accumulate_gas_limit"`
        // i: a sequence of imported data segments
        ImportedSegments []ImportSegment `json:"import_segments"`
        // x: extrinsic
        Extrinsics []WorkItemExtrinsic `json:"extrinsic"`
        // ExtrinsicsBlobs ExtrinsicsBlobs     `json:"extrinsics"`
        ExportCount uint16 `json:"export_count"`
}

// From Sec 14: Once done, then imported segments must be reconstructed. This process may in fact be lazy as the Refine function makes no usage of the data until the ${\tt import}$ hostcall is made. Fetching generally implies that, for each imported segment, erasure-coded chunks are retrieved from enough unique validators (342, including the guarantor).  Chunks must be fetched for both the data itself and for justification metadata which allows us to ensure that the data is correct.
type ImportSegment struct {
        RequestedHash common.Hash `json:"tree_root"`
        Index         uint16      `json:"index"`
}
type WorkItemExtrinsic struct {
        Hash common.Hash `json:"hash"`
        Len  uint32      `json:"len"`
}

// Segment represents a segment of data
type Segment struct {
        Data []byte
}

func (E ExtrinsicsBlobs) Encode() []byte <span class="cov0" title="0">{
        return []byte{}
}</span>

func (E ExtrinsicsBlobs) Decode(data []byte) (interface{}, uint32) <span class="cov0" title="0">{
        return nil, 0
}</span>

func (a *WorkItem) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Service            uint32              `json:"service"`
                CodeHash           common.Hash         `json:"code_hash"`
                Payload            string              `json:"payload"`
                RefineGasLimit     uint64              `json:"refine_gas_limit"`
                AccumulateGasLimit uint64              `json:"accumulate_gas_limit"`
                ImportedSegments   []ImportSegment     `json:"import_segments"`
                Extrinsics         []WorkItemExtrinsic `json:"extrinsic"`
                ExportCount        uint16              `json:"export_count"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a.Service = s.Service
        a.CodeHash = s.CodeHash
        a.Payload = common.FromHex(s.Payload)
        a.RefineGasLimit = s.RefineGasLimit
        a.AccumulateGasLimit = s.AccumulateGasLimit
        a.ImportedSegments = s.ImportedSegments
        a.Extrinsics = s.Extrinsics
        a.ExportCount = s.ExportCount
        return nil</span>
}

func (a WorkItem) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                Service            uint32              `json:"service"`
                CodeHash           common.Hash         `json:"code_hash"`
                Payload            string              `json:"payload"`
                RefineGasLimit     uint64              `json:"refine_gas_limit"`
                AccumulateGasLimit uint64              `json:"accumulate_gas_limit"`
                ImportedSegments   []ImportSegment     `json:"import_segments"`
                Extrinsics         []WorkItemExtrinsic `json:"extrinsic"`
                ExportCount        uint16              `json:"export_count"`
        }{
                Service:            a.Service,
                CodeHash:           a.CodeHash,
                Payload:            common.HexString(a.Payload),
                RefineGasLimit:     a.RefineGasLimit,
                AccumulateGasLimit: a.AccumulateGasLimit,
                ImportedSegments:   a.ImportedSegments,
                Extrinsics:         a.Extrinsics,
                ExportCount:        a.ExportCount,
        })
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

/*
14.3. Packages and Items.  A work-package includes: (See Equation 174):
* ${\bf j}$ - a simple blob acting as an authorization token
* $h$ - the index of the service which hosts the authorization code h
* $c$ - an authorization code hash
* ${\bf p}$ - a parameterization blob
* $x$ - context
* ${\bf i}$ - a sequence of work items
*/

// WorkPackage represents a work package.
type WorkPackage struct {
        // $j$ - a simple blob acting as an authorization token
        Authorization []byte `json:"authorization"`
        // $h$ - the index of the service which hosts the authorization code
        AuthCodeHost uint32 `json:"auth_code_host"`
        // $c$ - an authorization code hash
        Authorizer Authorizer `json:"authorizer"`
        // $x$ - context
        RefineContext RefineContext `json:"context"`
        // $i$ - a sequence of work items
        WorkItems []WorkItem `json:"items"`
}

// WorkPackageBundle represents a work package.
type WorkPackageBundle struct {
        WorkPackage       WorkPackage       `json:"p"` // P: workPackage
        ExtrinsicData     []ExtrinsicsBlobs `json:"x"` // X: extrinsic data for some workitem argument w
        ImportSegmentData [][][]byte        `json:"s"` // M: import segment data, previouslly called m (each of segment is size of W_E*W_S)
        Justification     [][][]common.Hash `json:"j"` // J: justifications of segment data build using CDT
}

func (b *WorkPackageBundle) Bytes() []byte <span class="cov0" title="0">{
        encoded, err := Encode(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return encoded</span>
}

func (b *WorkPackageBundle) String() string <span class="cov0" title="0">{
        jsonByte, _ := json.Marshal(b)
        return string(jsonByte)
}</span>

func (b *WorkPackageBundle) PackageHash() common.Hash <span class="cov0" title="0">{
        return b.WorkPackage.Hash()
}</span>

func (b *WorkPackageBundle) Package() WorkPackage <span class="cov0" title="0">{
        return b.WorkPackage
}</span>

func WorkPackageBundleFromBytes(data []byte) (*WorkPackageBundle, error) <span class="cov0" title="0">{
        var b WorkPackageBundle
        decoded, _, err := Decode(data, reflect.TypeOf(WorkPackageBundle{}))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">b = decoded.(WorkPackageBundle)
        return &amp;b, nil</span>
}

type Authorizer struct {
        CodeHash common.Hash `json:"code_hash"`
        Params   []byte      `json:"params"`
}

func (a *WorkPackage) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(a, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}

// Bytes returns the bytes of the Assurance
func (a *WorkPackage) Bytes() []byte <span class="cov0" title="0">{
        encode, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return encode</span>
}

func (a *WorkPackage) Hash() common.Hash <span class="cov0" title="0">{
        data := a.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}

func (a *WorkPackage) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                Authorization string        `json:"authorization"`
                AuthCodeHost  uint32        `json:"auth_code_host"`
                Authorizer    Authorizer    `json:"authorizer"`
                RefineContext RefineContext `json:"context"`
                WorkItems     []WorkItem    `json:"items"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">a.Authorization = common.FromHex(s.Authorization)
        a.AuthCodeHost = s.AuthCodeHost
        a.Authorizer = s.Authorizer
        a.RefineContext = s.RefineContext
        a.WorkItems = s.WorkItems

        return nil</span>
}

func (a *Authorizer) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                CodeHash common.Hash `json:"code_hash"`
                Params   string      `json:"params"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a.CodeHash = s.CodeHash
        a.Params = common.FromHex(s.Params)

        return nil</span>
}

func (a WorkPackage) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        // Convert Authorization from []byte to hex string
        authorization := common.HexString(a.Authorization)

        return json.Marshal(&amp;struct {
                Authorization string        `json:"authorization"`
                AuthCodeHost  uint32        `json:"auth_code_host"`
                Authorizer    Authorizer    `json:"authorizer"`
                RefineContext RefineContext `json:"context"`
                WorkItems     []WorkItem    `json:"items"`
        }{
                Authorization: authorization,
                AuthCodeHost:  a.AuthCodeHost,
                Authorizer:    a.Authorizer,
                RefineContext: a.RefineContext,
                WorkItems:     a.WorkItems,
        })
}</span>

func (a Authorizer) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                CodeHash common.Hash `json:"code_hash"`
                Params   string      `json:"params"`
        }{
                CodeHash: a.CodeHash,
                Params:   common.HexString(a.Params),
        })
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package types

import (
        "crypto/ed25519"
        "encoding/json"
        "errors"
        "fmt"

        "github.com/colorfulnotion/jam/common"
)

/*
11.1.1. Work Report. See Equation 117. A work-report, of the set W, is defined as a tuple of:
* the work-package specification $s$,
* the refinement context $x$,
* the core-index $c$ (i.e. on which the work is done)
* the authorizer hash $a$ and
* output ${\bf o}$ and
* $r$, the results of the evaluation of each of the items in the package r, which is always at least one item and may be no more than I items.
*/
// WorkReport represents a work report.

/*
SegmentRootLookupItem ::= SEQUENCE {
    work-package-hash WorkPackageHash,
    segment-tree-root OpaqueHash
}
*/

type SegmentRootLookupItem struct {
        WorkPackageHash common.Hash `json:"work_package_hash"`
        SegmentRoot     common.Hash `json:"segment_tree_root"`
}

// SegmentRootLookup represents a list of SegmentRootLookupItem
type SegmentRootLookup []SegmentRootLookupItem

func (m *SegmentRootLookup) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        type SegmentRootLookupItemAlias struct {
                WorkPackageHash *common.Hash `json:"work_package_hash"`
                Hash            *common.Hash `json:"hash"`
                SegmentTreeRoot *common.Hash `json:"segment_tree_root"`
                ExportsRoot     *common.Hash `json:"exports_root"`
        }

        var temp []SegmentRootLookupItemAlias
        if err := json.Unmarshal(data, &amp;temp); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*m = make(SegmentRootLookup, len(temp))
        for i, item := range temp </span><span class="cov0" title="0">{

                if item.WorkPackageHash != nil </span><span class="cov0" title="0">{
                        (*m)[i].WorkPackageHash = *item.WorkPackageHash
                }</span> else<span class="cov0" title="0"> if item.Hash != nil </span><span class="cov0" title="0">{
                        (*m)[i].WorkPackageHash = *item.Hash
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("missing both work_package_hash and hash fields at index %d", i)
                }</span>

                <span class="cov0" title="0">if item.SegmentTreeRoot != nil </span><span class="cov0" title="0">{
                        (*m)[i].SegmentRoot = *item.SegmentTreeRoot
                }</span> else<span class="cov0" title="0"> if item.ExportsRoot != nil </span><span class="cov0" title="0">{
                        (*m)[i].SegmentRoot = *item.ExportsRoot
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("missing both segment_tree_root and exports_root fields at index %d", i)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// MarshalJSON serializes the SegmentRootLookup into JSON
func (s SegmentRootLookup) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal([]SegmentRootLookupItem(s))
}</span>

// // UnmarshalJSON deserializes JSON data into SegmentRootLookup
// func (s *SegmentRootLookup) UnmarshalJSON(data []byte) error {
//         var items []SegmentRootLookupItem
//         if err := json.Unmarshal(data, &amp;items); err != nil {
//                 return err
//         }
//         *s = items
//         return nil
// }

type WorkReport struct {
        AvailabilitySpec  AvailabilitySpecifier `json:"package_spec"`
        RefineContext     RefineContext         `json:"context"`
        CoreIndex         uint16                `json:"core_index"`
        AuthorizerHash    common.Hash           `json:"authorizer_hash"`
        AuthOutput        []byte                `json:"auth_output"`
        SegmentRootLookup SegmentRootLookup     `json:"segment_root_lookup"`
        Results           []WorkResult          `json:"results"`
}

// eq 190
type WorkReportNeedAudit struct {
        Q [TotalCores]WorkReport `json:"available_work_report"`
}

type WorkReportSelection struct {
        WorkReport WorkReport `json:"work_report"`
        Core       uint16     `json:"core_index"`
}

func (a *WorkReport) GetWorkPackageHash() common.Hash <span class="cov0" title="0">{
        return a.AvailabilitySpec.WorkPackageHash
}</span>

// computeWorkReportBytes abstracts the process of generating the bytes to be signed or verified.
func (a *WorkReport) computeWorkReportBytes() []byte <span class="cov0" title="0">{
        return append([]byte(X_G), common.ComputeHash(a.Bytes())...)
}</span>

func ComputeWorkReportSignBytesWithHash(a common.Hash) []byte <span class="cov0" title="0">{
        return append([]byte(X_G), a.Bytes()...)
}</span>

func (a *WorkReport) Sign(Ed25519Secret []byte, validatorIndex uint16) (gc GuaranteeCredential) <span class="cov0" title="0">{
        gc.ValidatorIndex = validatorIndex
        sig := ed25519.Sign(Ed25519Secret, a.computeWorkReportBytes())
        copy(gc.Signature[:], sig[:])
        return gc
}</span>

func (a *WorkReport) ValidateSignature(publicKey []byte, signature []byte) error <span class="cov0" title="0">{
        workReportBytes := a.computeWorkReportBytes()

        if !ed25519.Verify(publicKey, workReportBytes, signature) </span><span class="cov0" title="0">{
                return errors.New("invalid signature")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Bytes returns the bytes of the Assurance
func (a *WorkReport) Bytes() []byte <span class="cov0" title="0">{
        enc, err := Encode(a)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return enc</span>
}

func (a *WorkReport) Hash() common.Hash <span class="cov0" title="0">{
        data := a.Bytes()
        if data == nil </span><span class="cov0" title="0">{
                // Handle the error case
                return common.Hash{}
        }</span>
        <span class="cov0" title="0">return common.Blake2Hash(data)</span>
}

func (a *WorkReport) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                AvailabilitySpec  AvailabilitySpecifier `json:"package_spec"`
                RefineContext     RefineContext         `json:"context"`
                CoreIndex         uint16                `json:"core_index"`
                AuthorizerHash    common.Hash           `json:"authorizer_hash"`
                AuthOutput        string                `json:"auth_output"`
                SegmentRootLookup SegmentRootLookup     `json:"segment_root_lookup"`
                Results           []WorkResult          `json:"results"`
        }
        if err := json.Unmarshal(data, &amp;s); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">a.AvailabilitySpec = s.AvailabilitySpec
        a.RefineContext = s.RefineContext
        a.CoreIndex = s.CoreIndex
        a.AuthorizerHash = s.AuthorizerHash
        a.AuthOutput = common.FromHex(s.AuthOutput)
        a.SegmentRootLookup = s.SegmentRootLookup
        a.Results = s.Results
        return nil</span>
}

func (a WorkReport) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(&amp;struct {
                AvailabilitySpec  AvailabilitySpecifier `json:"package_spec"`
                RefineContext     RefineContext         `json:"context"`
                CoreIndex         uint16                `json:"core_index"`
                AuthorizerHash    common.Hash           `json:"authorizer_hash"`
                AuthOutput        string                `json:"auth_output"`
                SegmentRootLookup SegmentRootLookup     `json:"segment_root_lookup"`
                Results           []WorkResult          `json:"results"`
        }{
                AvailabilitySpec:  a.AvailabilitySpec,
                RefineContext:     a.RefineContext,
                CoreIndex:         a.CoreIndex,
                AuthorizerHash:    a.AuthorizerHash,
                AuthOutput:        common.HexString(a.AuthOutput),
                SegmentRootLookup: a.SegmentRootLookup,
                Results:           a.Results,
        })
}</span>

// helper function to print the WorkReport
func (a *WorkReport) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(a, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package types

import (
        "encoding/json"
        "fmt"
        "reflect"

        "github.com/colorfulnotion/jam/common"
)

const (
        RESULT_OK       = 0
        RESULT_OOG      = 1
        RESULT_PANIC    = 2
        RESULT_BAD_CODE = 3
        RESULT_OOB      = 4
        RESULT_FAULT    = 5
)

// 11.1.4. Work Result. Equation 121. We finally come to define a work result, L, which is the data conduit by which services’ states may be altered through the computation done within a work-package.
type WorkResult struct {
        ServiceID   uint32      `json:"service_id"`
        CodeHash    common.Hash `json:"code_hash"`
        PayloadHash common.Hash `json:"payload_hash"`
        Gas         uint64      `json:"accumulate_gas"`
        Result      Result      `json:"result"`
}

type Result struct {
        Ok  []byte `json:"ok,omitempty"`
        Err uint8  `json:"err,omitempty"`
}

// see 12.3 Wrangling - Eq 159
type WrangledWorkResult struct {
        // Note this is Output OR Error
        // Output Result `json:"output"`
        //Output map[string]interface{} `json:"output"`
        Output Result `json:"output"`
        // l
        PayloadHash         common.Hash `json:"payload_hash"`
        AuthorizationOutput []byte      `json:"authorization_output"`
        WorkPackageHash     common.Hash `json:"output"`

        // matched with error
        Error string `json:"error"`
}

func (R Result) Encode() []byte <span class="cov8" title="1">{
        if R.Err == RESULT_OK </span><span class="cov8" title="1">{
                ok_byte := R.Ok
                encodedOk, err := Encode(ok_byte)
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">return append([]byte{0}, encodedOk...)</span>
        } else<span class="cov8" title="1"> {
                switch R.Err </span>{
                case RESULT_OOG:<span class="cov0" title="0">
                        return []byte{1}</span>
                case RESULT_PANIC:<span class="cov8" title="1">
                        return []byte{2}</span>
                case RESULT_BAD_CODE:<span class="cov0" title="0">
                        return []byte{3}</span>
                case RESULT_OOB:<span class="cov0" title="0">
                        return []byte{4}</span>
                case RESULT_FAULT:<span class="cov0" title="0">
                        return []byte{5}</span>
                default:<span class="cov0" title="0">
                        return []byte{R.Err}</span>
                }
        }
}

func (target Result) Decode(data []byte) (interface{}, uint32) <span class="cov8" title="1">{
        length := uint32(1)
        switch data[0] </span>{
        case 0:<span class="cov8" title="1">
                ok_byte, l, err := Decode(data[length:], reflect.TypeOf([]byte{}))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, length
                }</span>
                <span class="cov8" title="1">return Result{
                        Ok:  ok_byte.([]byte),
                        Err: RESULT_OK,
                }, length + l</span>
        case 1:<span class="cov0" title="0">
                return Result{
                        Ok:  nil,
                        Err: RESULT_OOG,
                }, length</span>
        case 2:<span class="cov8" title="1">
                return Result{
                        Ok:  nil,
                        Err: RESULT_PANIC,
                }, length</span>
        case 3:<span class="cov0" title="0">
                return Result{
                        Ok:  nil,
                        Err: RESULT_BAD_CODE,
                }, length</span>
        case 4:<span class="cov0" title="0">
                return Result{
                        Ok:  nil,
                        Err: RESULT_OOB,
                }, length</span>
        case 5:<span class="cov0" title="0">
                return Result{
                        Ok:  nil,
                        Err: RESULT_FAULT,
                }, length</span>
        default:<span class="cov0" title="0">
                return Result{
                        Ok:  nil,
                        Err: data[0],
                }, length</span>
        }
}

func (a *WorkResult) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        var s struct {
                ServiceID   uint32                 `json:"service_id"`
                CodeHash    common.Hash            `json:"code_hash"`
                PayloadHash common.Hash            `json:"payload_hash"`
                Gas         uint64                 `json:"accumulate_gas"`
                Result      map[string]interface{} `json:"result"`
        }
        err := json.Unmarshal(data, &amp;s)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var result Result
        if _, ok := s.Result["ok"]; ok </span><span class="cov8" title="1">{
                result = Result{
                        Ok:  common.FromHex(s.Result["ok"].(string)),
                        Err: RESULT_OK,
                }
        }</span>
        <span class="cov8" title="1">if _, ok := s.Result["out-of-gas"]; ok </span><span class="cov0" title="0">{
                result = Result{
                        Ok:  nil,
                        Err: RESULT_OOG,
                }
        }</span>
        <span class="cov8" title="1">if _, ok := s.Result["panic"]; ok </span><span class="cov8" title="1">{
                result = Result{
                        Ok:  nil,
                        Err: RESULT_PANIC,
                }
        }</span>
        <span class="cov8" title="1">if _, ok := s.Result["bad-code"]; ok </span><span class="cov0" title="0">{
                result = Result{
                        Ok:  nil,
                        Err: RESULT_BAD_CODE,
                }
        }</span>
        <span class="cov8" title="1">if _, ok := s.Result["code-oversize"]; ok </span><span class="cov0" title="0">{
                result = Result{
                        Ok:  nil,
                        Err: RESULT_OOB,
                }
        }</span>

        <span class="cov8" title="1">a.ServiceID = s.ServiceID
        a.CodeHash = s.CodeHash
        a.PayloadHash = s.PayloadHash
        a.Gas = s.Gas
        a.Result = result

        return nil</span>
}

func (a WorkResult) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        var result map[string]interface{}
        if a.Result.Err == RESULT_OK </span><span class="cov8" title="1">{
                result = map[string]interface{}{
                        "ok": common.HexString(a.Result.Ok),
                }
        }</span> else<span class="cov8" title="1"> {
                switch a.Result.Err </span>{
                case RESULT_OOG:<span class="cov0" title="0">
                        result = map[string]interface{}{
                                "out-of-gas": nil,
                        }</span>
                case RESULT_PANIC:<span class="cov8" title="1">
                        result = map[string]interface{}{
                                "panic": nil,
                        }</span>
                case RESULT_BAD_CODE:<span class="cov0" title="0">
                        result = map[string]interface{}{
                                "bad-code": nil,
                        }</span>
                case RESULT_OOB:<span class="cov0" title="0">
                        result = map[string]interface{}{
                                "code-oversize": nil,
                        }</span>
                }
        }

        <span class="cov8" title="1">return json.Marshal(&amp;struct {
                ServiceID   uint32                 `json:"service_id"`
                CodeHash    common.Hash            `json:"code_hash"`
                PayloadHash common.Hash            `json:"payload_hash"`
                Gas         uint64                 `json:"accumulate_gas"`
                Result      map[string]interface{} `json:"result"`
        }{
                ServiceID:   a.ServiceID,
                CodeHash:    a.CodeHash,
                PayloadHash: a.PayloadHash,
                Gas:         a.Gas,
                Result:      result,
        })</span>
}

// helper function to print the WorkReport
func (a *WorkResult) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(a, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}
func (a *Result) String() string <span class="cov0" title="0">{
        enc, err := json.MarshalIndent(a, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                // Handle the error according to your needs.
                return fmt.Sprintf("Error marshaling JSON: %v", err)
        }</span>
        <span class="cov0" title="0">return string(enc)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
