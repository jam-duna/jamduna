package trie

import (
	//"bytes"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"math/rand"
	"testing"
	"time"

	"github.com/colorfulnotion/jam/common"
)

const test_leveldb_path = ""

// TestVector represents a test case in the JSON file
type TestVector struct {
	Input  map[string]string `json:"input"`
	Output string            `json:"output"`
}

func hexToBytes(hexStr string) ([]byte, error) {
	return hex.DecodeString(hexStr)
}

func hex2Bytes(hexStr string) []byte {
	bytes, err := hex.DecodeString(hexStr)
	if err != nil {
		panic(err)
	}
	return bytes
}

func TestEdgeCases(t *testing.T) {
	// t.Skip()
	// level_db_path := "../leveldb/BPT"
	data := [][2][]byte{
		{hex2Bytes("0200000000000000000000000000000000000000000000000000000000000000"), hex2Bytes("0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
	}
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	for _, item := range data {
		tree.Insert(item[0], item[1])
	}
	tree.printTree(tree.Root, 0)
	getValue, err := tree.Get(hex2Bytes("0200000000000000000000000000000000000000000000000000000000000000"))
	if err != nil {
		t.Errorf("Key: %x not found, error: %s\n", hex2Bytes("0000"), err)
	}
	fmt.Printf("getValue %x\n", getValue)
}

// TestTrace tests the tracing functionality in the Merkle tree
func TestTrace(t *testing.T) {
	// t.Skip()
	// level_db_path := "../leveldb/BPT"
	data := [][2][]byte{
		{hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"), hex2Bytes("bb11c256876fe10442213dd78714793394d2016134c28a64eb27376ddc147fc6044df72bdea44d9ec66a3ea1e6d523f7de71db1d05a980e001e9fa")},
		{hex2Bytes("df08871e8a54fde4834d83851469e635713615ab1037128df138a6cd223f1242"), hex2Bytes("b8bded4e1c")},
		{hex2Bytes("7723a8383e43a1713eb920bae44880b2ae9225ea2d38c031cf3b22434b4507e7"), hex2Bytes("e46ddd41a5960807d528f5d9282568e622a023b94b72cb63f0353baff189257d")},
		{hex2Bytes("3e7d409b9037b1fd870120de92ebb7285219ce4526c54701b888c5a13995f73c"), hex2Bytes("9bc5d0")},
	}
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	for _, item := range data {
		tree.Insert(item[0], item[1])
	}
	tree.PrintTree(tree.Root, 0)
	trace, err := tree.Trace(hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"))

	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}

	if len(trace) == 0 {
		t.Error("Expected a non-empty trace, got empty")
	}
	path, _ := tree.GetPath(hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"))
	fmt.Printf("GetPath %x\n", path)
	tree.Close()
	t.Logf("Trace path: %x\n", trace)
}

func TestMerkleTree(t *testing.T) {
	// Read the JSON file
	filePath := "../jamtestvectors/trie/trie.json"
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		t.Fatalf("Failed to read JSON file: %v", err)
	}
	// Parse the JSON file
	var testVectors []TestVector
	err = json.Unmarshal(data, &testVectors)
	if err != nil {
		t.Fatalf("Failed to parse JSON file: %v", err)
	}

	// Run each test case
	for i, testCase := range testVectors {
		// Create the Merkle Tree input from the test case
		fmt.Printf("testCase %d: %v\n", i, testCase)

		isSerialized := true
		var rootHash []byte

		// // Clear the LevelDB folder
		// dbPath := fmt.Sprintf("../leveldb/BPT_%d", i)
		// os.RemoveAll(dbPath)
		// os.Mkdir(dbPath, 0755)

		// Create an empty Merkle Tree
		test_db, _ := initLevelDB()
		tree := NewMerkleTree(nil, test_db)

		if isSerialized {
			// Insert key-value pairs one by one
			for k, v := range testCase.Input {
				key, _ := hex.DecodeString(k)
				value, _ := hex.DecodeString(v)
				tree.Insert(key, value)
				fmt.Printf("computeHash:) %x\n", computeHash(leaf(key, value)))
			}
			rootHash = tree.GetRootHash()
		}
		// Compare the computed root hash with the expected output
		tree.printTree(tree.Root, 0)
		expectedHash, _ := hex.DecodeString(testCase.Output)
		if !compareBytes(rootHash, expectedHash) {
			t.Errorf("Test case %d: Root hash mismatch for input %v: got %s, want %s", i, testCase.Input, common.Bytes2Hex(rootHash), testCase.Output)
		} else {
			t.Logf("Test case %d: Vector OK, rootHash=%x", i, expectedHash)
		}

		// Test Valid Proof for each key from the test case
		for k, v := range testCase.Input {
			key, _ := hex.DecodeString(k)
			value, _ := hex.DecodeString(v)
			// Get the proof path for the key
			path, err := tree.Trace(key)
			if err != nil {
				t.Errorf("Unable to generate Proof for key [%x].Err %v\n", key, err)
			}

			// Test Valid Proof
			if tree.Verify(key, value, expectedHash, path) {
				fmt.Printf("Proof for key [%x] is valid.\n", key)
			} else {
				t.Errorf("Proof for key [%x] is invalid.\n", key)
			}

			// Test Get
			getValue, getErr := tree.Get(key)
			if getErr != nil {
				t.Errorf("Key: %x not found, error: %s\n", key, getErr)
			} else {
				fmt.Printf("Key: %x, Value: %x\n", key, getValue)
			}
		}
		// os.RemoveAll(dbPath) // Clean up the LevelDB folder(if needed)
		tree.Close()
	}
}

func TestBPTProof(t *testing.T) {
	data := [][2][]byte{
		{hex2Bytes("f2a9fcaf8ae0ff770b0908ebdee1daf8457c0ef5e1106c89ad364236333c5fb3"), hex2Bytes("22c62f84ee5775d1e75ba6519f6dfae571eb1888768f2a203281579656b6a29097f7c7e2cf44e38da9a541d9b4c773db8b71e1d3")},
		{hex2Bytes("f3a9fcaf8ae0ff770b0908ebdee1daf8457c0ef5e1106c89ad364236333c5fb3"), hex2Bytes("44d0b26211d9d4a44e375207")},

		// {hex2Bytes("d7f99b746f23411983df92806725af8e5cb66eba9f200737accae4a1ab7f47b9"), hex2Bytes("24232437f5b3f2380ba9089bdbc45efaffbe386602cb1ecc2c17f1d0")},
		// {hex2Bytes("59ee947b94bcc05634d95efb474742f6cd6531766e44670ec987270a6b5a4211"), hex2Bytes("72fdb0c99cf47feb85b2dad01ee163139ee6d34a8d893029a200aff76f4be5930b9000a1bbb2dc2b6c79f8f3c19906c94a3472349817af21181c3eef6b")},
		// {hex2Bytes("a3dc3bed1b0727caf428961bed11c9998ae2476d8a97fad203171b628363d9a2"), hex2Bytes("8a0dafa9d6ae6177")},
		// {hex2Bytes("15207c233b055f921701fc62b41a440d01dfa488016a97cc653a84afb5f94fd5"), hex2Bytes("157b6c821169dacabcf26690df")},
		// {hex2Bytes("b05ff8a05bb23c0d7b177d47ce466ee58fd55c6a0351a3040cf3cbf5225aab19"), hex2Bytes("6a208734106f38b73880684b")},
	}
	exceptedRootHash := hex2Bytes("b9c99f66e5784879a178795b63ae178f8a49ee113652a122cd4b3b2a321418c1")
	// Create an empty Merkle Tree
	//level_db_path := "../leveldb/BPT"
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)
	fmt.Printf("initial rootHash: %x\n", tree.GetRootHash())

	// Insert key-value pairs one by one
	for index, kv := range data {
		key := kv[0]
		value := kv[1]
		fmt.Printf("insert#%d, key=%x, value=%x\n", index, key, value)
		tree.Insert(key, value)
	}
	tree.printTree(tree.Root, 0)

	wrongKey := hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522ff")
	_, err := tree.Trace(wrongKey)
	if err == nil {
		t.Errorf("Proof should not exist non arbitrary key [%x].\n", wrongKey)
	}

	key := hex2Bytes("f2a9fcaf8ae0ff770b0908ebdee1daf8457c0ef5e1106c89ad364236333c5fb3")

	path, err := tree.Trace(key)
	fmt.Printf("Proof path for key %x: \n", key)
	for i, p := range path {
		fmt.Printf("  Node %d: %x\n", i, p)
	}
	if err != nil {
		t.Errorf("Unable to generate Proof for key [%x].Err %v\n", key, err)
	}

	// Test Valid Proof
	value, _ := tree.Get(key)
	fmt.Printf("levelDBGet key=%x, value=%x\n", key, value)
	if tree.Verify(key, value, tree.GetRootHash(), path) {
		fmt.Printf("Proof for key [%x] is valid.\n", key)
	} else {
		t.Errorf("Proof for key [%x] is invalid.\n", key)
	}

	// Test Invalid Proof
	invalidValue := []byte("invalid")
	if tree.Verify(key, invalidValue, exceptedRootHash, path) {
		t.Errorf("Proof for key [%x] with invalid value is valid.\n", invalidValue)
	} else {
		fmt.Printf("Proof for key [%x] with invalid value is invalid.\n", invalidValue)
	}
	tree.Close()
}

func TestGet(t *testing.T) {
	data := [][2][]byte{
		{hex2Bytes("3dbc5f775f6156957139100c343bb5ae6589af7398db694ab6c60630a9ed0fcd"), hex2Bytes("bb11c256876fe10442213dd78714793394d2016134c28a64eb27376ddc147fc6044df72bdea44d9ec66a3ea1e6d523f7de71db1d05a980e001e9fa")},
		{hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"), hex2Bytes("b8bded4e1c")},
		{hex2Bytes("7723a8383e43a1713eb920bae44880b2ae9225ea2d38c031cf3b22434b4507e7"), hex2Bytes("e46ddd41a5960807d528f5d9282568e622a023b94b72cb63f0353baff189257d")},
	}

	// Create an empty Merkle Tree
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)
	fmt.Printf("initial rootHash: %x\n", tree.GetRootHash())

	// Insert key-value pairs one by one
	for index, kv := range data {
		key := kv[0]
		value := kv[1]
		fmt.Printf("insert#%d, key=%x, value=%x\n", index, key, value)
		tree.Insert(key, value)
	}

	keys := [][]byte{
		hex2Bytes("3dbc5f775f6156957139100c343bb5ae6589af7398db694ab6c60630a9ed0fcd"),
		hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"),
		hex2Bytes("7723a8383e43a1713eb920bae44880b2ae9225ea2d38c031cf3b22434b4507e7"),
	}
	validKeys := [][]byte{
		hex2Bytes("7723a8383e43a1713eb920bae44880b2ae9225ea2d38c031cf3b22434b4507e6"), // The invalid Key
	}
	for _, key := range keys {
		value, err := tree.Get(key)
		if err != nil {
			t.Errorf("Key: %x not found, error: %s\n", key, err)
		} else {
			fmt.Printf("Key: %x, Value: %x\n", key, value)
		}
	}
	for _, key := range validKeys {
		value, err := tree.Get(key)
		if err != nil {
			fmt.Printf("Key: %x not found, error: %s\n", key, err)
		} else {
			t.Errorf("Key: %x, Value: %x\n", key, value)
		}
	}

	tree.Close()
}

func TestModify(t *testing.T) {
	filePath := "../jamtestvectors/trie/trie.json"
	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		t.Fatalf("Failed to read JSON file: %v", err)
	}

	// Parse the JSON file
	var testVectors []TestVector
	err = json.Unmarshal(data, &testVectors)
	if err != nil {
		t.Fatalf("Failed to parse JSON file: %v", err)
	}

	// Run each test case
	for i, testCase := range testVectors {
		// Create the Merkle Tree input from the test case
		fmt.Printf("testCase %d: %v\n", i, testCase)
		var input [][2][]byte
		for k, v := range testCase.Input {
			key, _ := hex.DecodeString(k)
			value, _ := hex.DecodeString(v)
			input = append(input, [2][]byte{key, value})
		}
		fmt.Printf("input=%x (len=%v)\n", input, len(input))

		var rootHash []byte

		// Create an empty Merkle Tree
		test_db, _ := initLevelDB()
		tree := NewMerkleTree(nil, test_db)

		fmt.Printf("initial rootHash:%x \n", tree.GetRootHash())
		// Insert key-value pairs one by one
		index := 0
		rand.Seed(time.Now().UnixNano())
		/*
			for k, v := range testCase.Input {
				fmt.Printf("insert#%d, k=%v, v=%v\n", index, k, v)
				key, _ := hex.DecodeString(k)
				value, _ := hex.DecodeString(v)
				tree.Insert(key, value)
				randomValue := make([]byte, len(v))
				rand.Read(randomValue)
				fmt.Printf("insert#%d, key=%x, randomValue=%x\n", index, key, randomValue)
				tree.Insert(key, randomValue)
				index++
			}
		*/
		index = 0
		for k, v := range testCase.Input {
			fmt.Printf("insert#%d, k=%v, v=%v\n", index, k, v)
			key, _ := hex.DecodeString(k)
			value, _ := hex.DecodeString(v)
			tree.Insert(key, value)
			//tree.printTree(tree.Root, 0)
			index++
		}
		rootHash = tree.GetRootHash()

		// Compare the computed root hash with the expected output
		expectedHash, _ := hex.DecodeString(testCase.Output)
		if !compareBytes(rootHash, expectedHash) {
			tree.PrintTree(tree.Root, 0)
			t.Errorf("Test case %d: Root hash mismatch for input %v: got %s, want %s", i, testCase.Input, common.Bytes2Hex(rootHash), testCase.Output)
		} else {
			t.Logf("Test case %d: Vector OK, rootHash=%x", i, expectedHash)
		}
		tree.Close()
	}
}

// TestDelete tests the deletion of key-value pairs from the Merkle tree
func TestDelete(t *testing.T) {
	// Test data
	data := [][2][]byte{
		{hex2Bytes("d7f99b746f23411983df92806725af8e5cb66eba9f200737accae4a1ab7f47b9"), hex2Bytes("24232437f5b3f2380ba9089bdbc45efaffbe386602cb1ecc2c17f1d0")},
		{hex2Bytes("59ee947b94bcc05634d95efb474742f6cd6531766e44670ec987270a6b5a4211"), hex2Bytes("72fdb0c99cf47feb85b2dad01ee163139ee6d34a8d893029a200aff76f4be5930b9000a1bbb2dc2b6c79f8f3c19906c94a3472349817af21181c3eef6b")},
		{hex2Bytes("a3dc3bed1b0727caf428961bed11c9998ae2476d8a97fad203171b628363d9a2"), hex2Bytes("8a0dafa9d6ae6177")},
		{hex2Bytes("15207c233b055f921701fc62b41a440d01dfa488016a97cc653a84afb5f94fd5"), hex2Bytes("157b6c821169dacabcf26690df")},
		{hex2Bytes("b05ff8a05bb23c0d7b177d47ce466ee58fd55c6a0351a3040cf3cbf5225aab19"), hex2Bytes("6a208734106f38b73880684b")},
	}

	// Create a new Merkle Tree
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	// Record root hashes after each insertion
	var rootHashes [][]byte

	for _, kv := range data {
		tree.Insert(kv[0], kv[1])
		rootHash := tree.GetRootHash()
		rootHashes = append(rootHashes, rootHash)
		fmt.Printf("Inserted key: %x, value: %x, RootHash: %x\n", kv[0], kv[1], rootHash)
		// fmt.Printf("--------------------------------------------\n")
		// tree.printTree(tree.Root, 0)
		// fmt.Printf("--------------------------------------------\n")
	}

	// Check root hashes after each deletion in reverse order
	for i := len(data) - 1; i >= 0; i-- {
		kv := data[i]
		err := tree.Delete(kv[0])
		if err != nil {
			t.Fatalf("Failed to delete key: %x, error: %v", kv[0], err)
		}
		rootHash := tree.GetRootHash()
		expectedRootHash := make([]byte, 32)
		if i > 0 {
			expectedRootHash = rootHashes[i-1]
		}
		fmt.Printf("Deleted key: %x, RootHash after deletion: %x\n", kv[0], rootHash)

		// fmt.Printf("--------------------------------------------\n")
		// tree.printTree(tree.Root, 0)
		// fmt.Printf("--------------------------------------------\n")

		if !compareBytes(rootHash, expectedRootHash) {
			t.Fatalf("RootHash mismatch after deleting key: %x. Got: %x, Expected: %x", kv[0], rootHash, expectedRootHash)
		}
	}
	tree.Close()
}

func TestStateKey(t *testing.T) {
	// Test data
	// data := [][2][]byte{
	// 	{hex2Bytes("d7f99b746f23411983df92806725af8e5cb66eba9f200737accae4a1ab7f47b9"), hex2Bytes("24232437f5b3f2380ba9089bdbc45efaffbe386602cb1ecc2c17f1d0")},
	// 	{hex2Bytes("59ee947b94bcc05634d95efb474742f6cd6531766e44670ec987270a6b5a4211"), hex2Bytes("72fdb0c99cf47feb85b2dad01ee163139ee6d34a8d893029a200aff76f4be5930b9000a1bbb2dc2b6c79f8f3c19906c94a3472349817af21181c3eef6b")},
	// }

	//level_db_path := "../leveldb/BPT"
	// Create a new Merkle Tree
	// tree := NewMerkleTree(nil, test_leveldb_path)

	test_db, _ := initLevelDB()
	rootHash, tree, err := Initial_bpt(test_db)
	if err != nil {
		t.Errorf("Failed to initial BPT %v", err)
	}
	// defer tree.Close()
	fmt.Printf("Root Hash=%x \n", rootHash)
	// Insert key-value pairs one by one
	// for _, kv := range data {
	// 	value := kv[1]
	// 	tree.SetService(255, 100, value)
	// }
	// // tree.printTree(tree.Root, 0)

	// for _, kv := range data {
	// 	key := kv[0]
	// 	value := kv[1]
	// 	tree.SetPreImage(126, key, value)
	// }
	// tree.printTree(tree.Root, 0)

	// Get the root hash of the tree
	// rootHash := tree.GetRootHash()

	value, err := tree.GetPreImageBlob(0, hex2Bytes("e6f0db7107765905cfdc1f19af6eb8ff07d89626f47429556d9a52b4e8b001d7"))
	fmt.Printf("get value=%x, err=%v\n", value, err)

	// for _, kv := range data {
	// 	key := kv[0]
	// 	value, err := tree.GetPreImage(126, key)
	// 	fmt.Printf("getService value=%x, err=%v\n", value, err)
	// }
	tree.printTree(tree.Root, 0)
	tree.Close()
}

// TestInitial tests the initialization of a Merkle tree from a root hash
func TestInitial(t *testing.T) {
	// Initialize the test data
	// level_db_path := "../leveldb/BPT"
	data := [][2][]byte{
		{hex2Bytes("5dffe0e2c9f089d30e50b04ee562445cf2c0e7e7d677580ef0ccf2c6fa3522dd"), hex2Bytes("bb11c256876fe10442213dd78714793394d2016134c28a64eb27376ddc147fc6044df72bdea44d9ec66a3ea1e6d523f7de71db1d05a980e001e9fa")},
		{hex2Bytes("df08871e8a54fde4834d83851469e635713615ab1037128df138a6cd223f1242"), hex2Bytes("b8bded4e1c")},
		{hex2Bytes("7723a8383e43a1713eb920bae44880b2ae9225ea2d38c031cf3b22434b4507e7"), hex2Bytes("e46ddd41a5960807d528f5d9282568e622a023b94b72cb63f0353baff189257d")},
		{hex2Bytes("3e7d409b9037b1fd870120de92ebb7285219ce4526c54701b888c5a13995f73c"), hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
		{hex2Bytes("0200000000000000000000000000000000000000000000000000000000000000"), hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
		{hex2Bytes("0300000000000000000000000000000000000000000000000000000000000000"), hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
		{hex2Bytes("0D00000000000000000000000000000000000000000000000000000000000000"), hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
		{hex2Bytes("0100000000000000000000000000000000000000000000000000000000000000"), hex2Bytes("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000")},
	}

	// Build the initial tree and insert the data
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)
	for _, item := range data {
		tree.Insert(item[0], item[1])
	}

	tree.printTree(tree.Root, 0)

	// Get the root hash of the tree
	rootHash := tree.GetRootHash()

	// Rebuild the recovered tree (rt) from the root hash
	rt, err := InitMerkleTreeFromHash(rootHash, test_db)
	if err != nil {
		t.Errorf("Unexpected error: %v", err)
	}
	rt.printTree(rt.Root, 0)

	// Compare the initial tree with the reconstructed tree
	if !compareTrees(tree.Root, rt.Root) {
		t.Error("The reconstructed tree does not match the initial tree")
	}

	// TODO: stanley to test insert on this recovered tree..
	// recoveredTree.SetState()
	/*
		rt.SetState(C1, coreAuthPoolEncode)
		rt.SetState(C2, authQueueEncode)
		rt.SetState(C3, recentBlocksEncode)
		rt.SetState(CD, safroleStateEncode)
		rt.SetState(C5, disputeState)
		rt.SetState(C6, entropyEncode)
		rt.SetState(C7, nextEpochValidatorsEncode)
		rt.SetState(C8, currEpochValidatorsEncode)
		rt.SetState(C9, priorEpochValidatorEncode)
		rt.SetState(C10, rhoEncode)
		rt.SetState(C11, mostRecentBlockTimeSlotEncode)
		rt.SetState(C12, privilegedServiceIndicesEncode)
		rt.SetState(C13, piEncode)
	*/

}

// Test service
func TestService(t *testing.T) {

	// Build the initial tree and insert the data
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	tree.SetService(255, 42, []byte{1})
	tree.SetService(255, 43, []byte{1, 2})
	tree.SetService(255, 44, []byte{1, 2, 3})

	tree.printTree(tree.Root, 0)

	s1, _ := tree.GetService(255, 42)
	s2, _ := tree.GetService(255, 43)
	s3, _ := tree.GetService(255, 44)
	s4, _ := tree.GetService(255, 45)

	fmt.Println("s1:", s1)
	fmt.Println("s2:", s2)
	fmt.Println("s3:", s3)
	fmt.Println("s4:", s4)
}

// Test PreImage_lookup
func TestServicePreImage_lookup(t *testing.T) {

	// Build the initial tree and insert the data
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	case_a := []byte{1}
	case_b := []byte{1, 2}
	case_c := []byte{1, 2, 3}

	tree.SetPreImageLookup(42, common.Blake2Hash(case_a), uint32(len(case_a)), []uint32{100})
	tree.SetPreImageLookup(43, common.Blake2Hash(case_b), uint32(len(case_b)), []uint32{100, 200})
	tree.SetPreImageLookup(44, common.Blake2Hash(case_c), uint32(len(case_c)), []uint32{100, 200, 300})

	tree.printTree(tree.Root, 0)

	ts1, _ := tree.GetPreImageLookup(42, common.Blake2Hash(case_a), uint32(len(case_a)))
	ts2, _ := tree.GetPreImageLookup(43, common.Blake2Hash(case_b), uint32(len(case_b)))
	ts3, _ := tree.GetPreImageLookup(44, common.Blake2Hash(case_c), uint32(len(case_c)))
	ts4, _ := tree.GetPreImageLookup(45, common.Blake2Hash(case_c), uint32(len(case_c)))

	fmt.Println("ts1:", ts1)
	fmt.Println("ts2:", ts2)
	fmt.Println("ts3:", ts3)
	fmt.Println("ts4:", ts4)

	_ = tree.DeletePreImageLookup(42, common.Blake2Hash(case_a), uint32(len(case_a)))
	_ = tree.DeletePreImageLookup(43, common.Blake2Hash(case_b), uint32(len(case_b)))
	_ = tree.DeletePreImageLookup(44, common.Blake2Hash(case_c), uint32(len(case_c)))

	ts1, _ = tree.GetPreImageLookup(42, common.Blake2Hash(case_a), uint32(len(case_a)))
	ts2, _ = tree.GetPreImageLookup(43, common.Blake2Hash(case_b), uint32(len(case_b)))
	ts3, _ = tree.GetPreImageLookup(44, common.Blake2Hash(case_c), uint32(len(case_c)))

	fmt.Println("ts1:", ts1)
	fmt.Println("ts2:", ts2)
	fmt.Println("ts3:", ts3)

}

// Test PreImage_blob
func TestServicePreImage_blob(t *testing.T) {

	// Build the initial tree and insert the data
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	tree.SetPreImageBlob(42, []byte{1})
	tree.SetPreImageBlob(43, []byte{1, 2})
	tree.SetPreImageBlob(44, []byte{1, 2, 3})

	tree.printTree(tree.Root, 0)

	blob1, _ := tree.GetPreImageBlob(42, common.ComputeHash([]byte{1}))
	blob2, _ := tree.GetPreImageBlob(43, common.ComputeHash([]byte{1, 2}))
	blob3, _ := tree.GetPreImageBlob(44, common.ComputeHash([]byte{1, 2, 3}))
	blob4, _ := tree.GetPreImageBlob(45, common.ComputeHash([]byte{1, 2, 3}))

	fmt.Println("blob1:", blob1)
	fmt.Println("blob2:", blob2)
	fmt.Println("blob3:", blob3)
	fmt.Println("blob4:", blob4)

	_ = tree.DeletePreImageBlob(42, common.ComputeHash([]byte{1}))
	_ = tree.DeletePreImageBlob(43, common.ComputeHash([]byte{1, 2}))
	_ = tree.DeletePreImageBlob(44, common.ComputeHash([]byte{1, 2, 3}))

	blob1, _ = tree.GetPreImageBlob(42, common.ComputeHash([]byte{1}))
	blob2, _ = tree.GetPreImageBlob(43, common.ComputeHash([]byte{1, 2}))
	blob3, _ = tree.GetPreImageBlob(44, common.ComputeHash([]byte{1, 2, 3}))

	fmt.Println("blob1:", blob1)
	fmt.Println("blob2:", blob2)
	fmt.Println("blob3:", blob3)

}

// Test Storage
func TestServiceStorage(t *testing.T) {

	// Build the initial tree and insert the data
	test_db, _ := initLevelDB()
	tree := NewMerkleTree(nil, test_db)

	tree.SetServiceStorage(42, common.ComputeHash([]byte{1}), []byte{1})
	tree.SetServiceStorage(43, common.ComputeHash([]byte{1, 2}), []byte{1, 2})
	tree.SetServiceStorage(44, common.ComputeHash([]byte{1, 2, 3}), []byte{1, 2, 3})

	tree.printTree(tree.Root, 0)

	Storage1, _ := tree.GetServiceStorage(42, common.ComputeHash([]byte{1}))
	Storage2, _ := tree.GetServiceStorage(43, common.ComputeHash([]byte{1, 2}))
	Storage3, _ := tree.GetServiceStorage(44, common.ComputeHash([]byte{1, 2, 3}))
	Storage4, _ := tree.GetServiceStorage(45, common.ComputeHash([]byte{1, 2, 3}))

	fmt.Println("Storage1", Storage1)
	fmt.Println("Storage2", Storage2)
	fmt.Println("Storage3", Storage3)
	fmt.Println("Storage4", Storage4)

	_ = tree.DeleteServiceStorage(42, common.ComputeHash([]byte{1}))
	_ = tree.DeleteServiceStorage(43, common.ComputeHash([]byte{1, 2}))
	_ = tree.DeleteServiceStorage(44, common.ComputeHash([]byte{1, 2, 3}))

	Storage1, _ = tree.GetServiceStorage(42, common.ComputeHash([]byte{1}))
	Storage2, _ = tree.GetServiceStorage(43, common.ComputeHash([]byte{1, 2}))
	Storage3, _ = tree.GetServiceStorage(44, common.ComputeHash([]byte{1, 2, 3}))

	fmt.Println("Storage1", Storage1)
	fmt.Println("Storage2", Storage2)
	fmt.Println("Storage3", Storage3)
}
